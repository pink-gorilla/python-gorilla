;; gorilla-repl.fileformat = 2

;; @@ [meta]
{}

;; @@

;; **
;;; # Python datafy 
;; **

;; @@ [clj]
(use '[pinkgorilla.notebook.repl]) 
(pinkgorilla.notebook.repl/add-dependencies 
 '[[clj-python/libpython-clj "1.40"] ; this is not necessary, as python-gorilla has libpython-clj dependency
  [org.pinkgorilla/python-gorilla "0.0.12" :exclusions [org.pinkgorilla/gorilla-notebook]]  ; not needed if used as a library
   ])
;; @@
;; =>
;;; ["^ ","~:type","~:list-like","~:open",["~:span",["^ ","~:class","clj-map"],"{"],"~:close",["^3",["^ ","^4","clj-map"],"}"],"~:separator",["^3",", "],"~:items",["~#list",[["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","~:html","~:content",["^3",["^ ","^4","clj-symbol"],"org.apache.commons/commons-math3"],"~:value","org.apache.commons/commons-math3"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.6.1\""],"^;","\"3.6.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x490325e6 \"org.apache.commons:commons-math3:jar:3.6.1 (compile)\"], :file #object[java.io.File 0x71533619 \"/home/andreas/.m2/repository/org/apache/commons/commons-math3/3.6.1/commons-math3-3.6.1.jar\"]} [org.apache.commons/commons-math3 \"3.6.1\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x490325e6 \"org.apache.commons:commons-math3:jar:3.6.1 (compile)\"], :file #object[java.io.File 0x71533619 \"/home/andreas/.m2/repository/org/apache/commons/commons-math3/3.6.1/commons-math3-3.6.1.jar\"]} [org.apache.commons/commons-math3 \"3.6.1\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"com.tdunning/t-digest"],"^;","com.tdunning/t-digest"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.2\""],"^;","\"3.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x753d4982 \"com.tdunning:t-digest:jar:3.2 (compile)\"], :file #object[java.io.File 0x39201200 \"/home/andreas/.m2/repository/com/tdunning/t-digest/3.2/t-digest-3.2.jar\"]} [com.tdunning/t-digest \"3.2\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x753d4982 \"com.tdunning:t-digest:jar:3.2 (compile)\"], :file #object[java.io.File 0x39201200 \"/home/andreas/.m2/repository/com/tdunning/t-digest/3.2/t-digest-3.2.jar\"]} [com.tdunning/t-digest \"3.2\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.analyzer.jvm"],"^;","org.clojure/tools.analyzer.jvm"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.7.3\""],"^;","\"0.7.3\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x695c3cd7 \"org.clojure:tools.analyzer.jvm:jar:0.7.3 (compile)\"], :file #object[java.io.File 0x1573c1b \"/home/andreas/.m2/repository/org/clojure/tools.analyzer.jvm/0.7.3/tools.analyzer.jvm-0.7.3.jar\"]} [org.clojure/tools.analyzer.jvm \"0.7.3\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x695c3cd7 \"org.clojure:tools.analyzer.jvm:jar:0.7.3 (compile)\"], :file #object[java.io.File 0x1573c1b \"/home/andreas/.m2/repository/org/clojure/tools.analyzer.jvm/0.7.3/tools.analyzer.jvm-0.7.3.jar\"]} [org.clojure/tools.analyzer.jvm \"0.7.3\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.pinkgorilla/gorilla-renderable"],"^;","org.pinkgorilla/gorilla-renderable"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.0.8\""],"^;","\"3.0.8\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e3914ea \"org.pinkgorilla:gorilla-renderable:jar:3.0.8 (compile)\"], :file #object[java.io.File 0x2730b53f \"/home/andreas/.m2/repository/org/pinkgorilla/gorilla-renderable/3.0.8/gorilla-renderable-3.0.8.jar\"]} [org.pinkgorilla/gorilla-renderable \"3.0.8\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-set"],"#{"],"^5",["^3",["^ ","^4","clj-set"],"}"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/data.codec"],"^;","org.clojure/data.codec"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.1\""],"^;","\"0.1.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f829f8a \"org.clojure:data.codec:jar:0.1.1 (compile)\"], :file #object[java.io.File 0x178dd985 \"/home/andreas/.m2/repository/org/clojure/data.codec/0.1.1/data.codec-0.1.1.jar\"]} [org.clojure/data.codec \"0.1.1\"]"]]],"^;","#{^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f829f8a \"org.clojure:data.codec:jar:0.1.1 (compile)\"], :file #object[java.io.File 0x178dd985 \"/home/andreas/.m2/repository/org/clojure/data.codec/0.1.1/data.codec-0.1.1.jar\"]} [org.clojure/data.codec \"0.1.1\"]}"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e3914ea \"org.pinkgorilla:gorilla-renderable:jar:3.0.8 (compile)\"], :file #object[java.io.File 0x2730b53f \"/home/andreas/.m2/repository/org/pinkgorilla/gorilla-renderable/3.0.8/gorilla-renderable-3.0.8.jar\"]} [org.pinkgorilla/gorilla-renderable \"3.0.8\"] #{^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f829f8a \"org.clojure:data.codec:jar:0.1.1 (compile)\"], :file #object[java.io.File 0x178dd985 \"/home/andreas/.m2/repository/org/clojure/data.codec/0.1.1/data.codec-0.1.1.jar\"]} [org.clojure/data.codec \"0.1.1\"]}]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.reader"],"^;","org.clojure/tools.reader"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"1.3.2\""],"^;","\"1.3.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x41c501da \"org.clojure:tools.reader:jar:1.3.2 (compile)\"], :file #object[java.io.File 0x637ecd90 \"/home/andreas/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar\"]} [org.clojure/tools.reader \"1.3.2\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x41c501da \"org.clojure:tools.reader:jar:1.3.2 (compile)\"], :file #object[java.io.File 0x637ecd90 \"/home/andreas/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar\"]} [org.clojure/tools.reader \"1.3.2\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/data.json"],"^;","org.clojure/data.json"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.2.7\""],"^;","\"0.2.7\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x58bb60ba \"org.clojure:data.json:jar:0.2.7 (compile)\"], :file #object[java.io.File 0x2183dbd9 \"/home/andreas/.m2/repository/org/clojure/data.json/0.2.7/data.json-0.2.7.jar\"]} [org.clojure/data.json \"0.2.7\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x58bb60ba \"org.clojure:data.json:jar:0.2.7 (compile)\"], :file #object[java.io.File 0x2183dbd9 \"/home/andreas/.m2/repository/org/clojure/data.json/0.2.7/data.json-0.2.7.jar\"]} [org.clojure/data.json \"0.2.7\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"camel-snake-kebab"],"^;","camel-snake-kebab"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.4.0\""],"^;","\"0.4.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x48a1c5e2 \"camel-snake-kebab:camel-snake-kebab:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x5da6832b \"/home/andreas/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.0/camel-snake-kebab-0.4.0.jar\"]} [camel-snake-kebab \"0.4.0\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x48a1c5e2 \"camel-snake-kebab:camel-snake-kebab:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x5da6832b \"/home/andreas/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.0/camel-snake-kebab-0.4.0.jar\"]} [camel-snake-kebab \"0.4.0\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.resource"],"^;","techascent/tech.resource"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"4.6\""],"^;","\"4.6\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5e9b9695 \"techascent:tech.resource:jar:4.6 (compile)\"], :file #object[java.io.File 0x61f9d38c \"/home/andreas/.m2/repository/techascent/tech.resource/4.6/tech.resource-4.6.jar\"]} [techascent/tech.resource \"4.6\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5e9b9695 \"techascent:tech.resource:jar:4.6 (compile)\"], :file #object[java.io.File 0x61f9d38c \"/home/andreas/.m2/repository/techascent/tech.resource/4.6/tech.resource-4.6.jar\"]} [techascent/tech.resource \"4.6\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.async"],"^;","org.clojure/core.async"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.7.559\""],"^;","\"0.7.559\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x27b18484 \"org.clojure:core.async:jar:0.7.559 (compile)\"], :file #object[java.io.File 0x4ee7f482 \"/home/andreas/.m2/repository/org/clojure/core.async/0.7.559/core.async-0.7.559.jar\"]} [org.clojure/core.async \"0.7.559\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x27b18484 \"org.clojure:core.async:jar:0.7.559 (compile)\"], :file #object[java.io.File 0x4ee7f482 \"/home/andreas/.m2/repository/org/clojure/core.async/0.7.559/core.async-0.7.559.jar\"]} [org.clojure/core.async \"0.7.559\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"kixi/stats"],"^;","kixi/stats"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.5.2\""],"^;","\"0.5.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x4c4aecf5 \"kixi:stats:jar:0.5.2 (compile)\"], :file #object[java.io.File 0x63802343 \"/home/andreas/.m2/repository/kixi/stats/0.5.2/stats-0.5.2.jar\"]} [kixi/stats \"0.5.2\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x4c4aecf5 \"kixi:stats:jar:0.5.2 (compile)\"], :file #object[java.io.File 0x63802343 \"/home/andreas/.m2/repository/kixi/stats/0.5.2/stats-0.5.2.jar\"]} [kixi/stats \"0.5.2\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/data.codec"],"^;","org.clojure/data.codec"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.1\""],"^;","\"0.1.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f829f8a \"org.clojure:data.codec:jar:0.1.1 (compile)\"], :file #object[java.io.File 0x178dd985 \"/home/andreas/.m2/repository/org/clojure/data.codec/0.1.1/data.codec-0.1.1.jar\"]} [org.clojure/data.codec \"0.1.1\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f829f8a \"org.clojure:data.codec:jar:0.1.1 (compile)\"], :file #object[java.io.File 0x178dd985 \"/home/andreas/.m2/repository/org/clojure/data.codec/0.1.1/data.codec-0.1.1.jar\"]} [org.clojure/data.codec \"0.1.1\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.roaringbitmap/RoaringBitmap"],"^;","org.roaringbitmap/RoaringBitmap"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.13\""],"^;","\"0.8.13\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x483e1e13 \"org.roaringbitmap:RoaringBitmap:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x390cb072 \"/home/andreas/.m2/repository/org/roaringbitmap/RoaringBitmap/0.8.13/RoaringBitmap-0.8.13.jar\"]} [org.roaringbitmap/RoaringBitmap \"0.8.13\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x483e1e13 \"org.roaringbitmap:RoaringBitmap:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x390cb072 \"/home/andreas/.m2/repository/org/roaringbitmap/RoaringBitmap/0.8.13/RoaringBitmap-0.8.13.jar\"]} [org.roaringbitmap/RoaringBitmap \"0.8.13\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.roaringbitmap/shims"],"^;","org.roaringbitmap/shims"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.13\""],"^;","\"0.8.13\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x22badee2 \"org.roaringbitmap:shims:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x40426bcd \"/home/andreas/.m2/repository/org/roaringbitmap/shims/0.8.13/shims-0.8.13.jar\"]} [org.roaringbitmap/shims \"0.8.13\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x22badee2 \"org.roaringbitmap:shims:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x40426bcd \"/home/andreas/.m2/repository/org/roaringbitmap/shims/0.8.13/shims-0.8.13.jar\"]} [org.roaringbitmap/shims \"0.8.13\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.cache"],"^;","org.clojure/core.cache"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.2\""],"^;","\"0.8.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x78343b50 \"org.clojure:core.cache:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x24e79b04 \"/home/andreas/.m2/repository/org/clojure/core.cache/0.8.2/core.cache-0.8.2.jar\"]} [org.clojure/core.cache \"0.8.2\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x78343b50 \"org.clojure:core.cache:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x24e79b04 \"/home/andreas/.m2/repository/org/clojure/core.cache/0.8.2/core.cache-0.8.2.jar\"]} [org.clojure/core.cache \"0.8.2\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"net.java.dev.jna/jna"],"^;","net.java.dev.jna/jna"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"5.2.0\""],"^;","\"5.2.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x50de1cb4 \"net.java.dev.jna:jna:jar:5.2.0 (compile)\"], :file #object[java.io.File 0x3110961 \"/home/andreas/.m2/repository/net/java/dev/jna/jna/5.2.0/jna-5.2.0.jar\"]} [net.java.dev.jna/jna \"5.2.0\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x50de1cb4 \"net.java.dev.jna:jna:jar:5.2.0 (compile)\"], :file #object[java.io.File 0x3110961 \"/home/andreas/.m2/repository/net/java/dev/jna/jna/5.2.0/jna-5.2.0.jar\"]} [net.java.dev.jna/jna \"5.2.0\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"primitive-math"],"^;","primitive-math"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.6\""],"^;","\"0.1.6\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5a264ce8 \"primitive-math:primitive-math:jar:0.1.6 (compile)\"], :file #object[java.io.File 0x4201c313 \"/home/andreas/.m2/repository/primitive-math/primitive-math/0.1.6/primitive-math-0.1.6.jar\"]} [primitive-math \"0.1.6\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5a264ce8 \"primitive-math:primitive-math:jar:0.1.6 (compile)\"], :file #object[java.io.File 0x4201c313 \"/home/andreas/.m2/repository/primitive-math/primitive-math/0.1.6/primitive-math-0.1.6.jar\"]} [primitive-math \"0.1.6\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.memoize"],"^;","org.clojure/core.memoize"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.2\""],"^;","\"0.8.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x629a4c5b \"org.clojure:core.memoize:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x69cb0b68 \"/home/andreas/.m2/repository/org/clojure/core.memoize/0.8.2/core.memoize-0.8.2.jar\"]} [org.clojure/core.memoize \"0.8.2\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x629a4c5b \"org.clojure:core.memoize:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x69cb0b68 \"/home/andreas/.m2/repository/org/clojure/core.memoize/0.8.2/core.memoize-0.8.2.jar\"]} [org.clojure/core.memoize \"0.8.2\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"it.unimi.dsi/fastutil"],"^;","it.unimi.dsi/fastutil"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"8.2.1\""],"^;","\"8.2.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e25bb5 \"it.unimi.dsi:fastutil:jar:8.2.1 (compile)\"], :file #object[java.io.File 0x4db709c1 \"/home/andreas/.m2/repository/it/unimi/dsi/fastutil/8.2.1/fastutil-8.2.1.jar\"]} [it.unimi.dsi/fastutil \"8.2.1\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e25bb5 \"it.unimi.dsi:fastutil:jar:8.2.1 (compile)\"], :file #object[java.io.File 0x4db709c1 \"/home/andreas/.m2/repository/it/unimi/dsi/fastutil/8.2.1/fastutil-8.2.1.jar\"]} [it.unimi.dsi/fastutil \"8.2.1\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/math.combinatorics"],"^;","org.clojure/math.combinatorics"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.4\""],"^;","\"0.1.4\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7d7f7cb8 \"org.clojure:math.combinatorics:jar:0.1.4 (compile)\"], :file #object[java.io.File 0x4c5eb834 \"/home/andreas/.m2/repository/org/clojure/math.combinatorics/0.1.4/math.combinatorics-0.1.4.jar\"]} [org.clojure/math.combinatorics \"0.1.4\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7d7f7cb8 \"org.clojure:math.combinatorics:jar:0.1.4 (compile)\"], :file #object[java.io.File 0x4c5eb834 \"/home/andreas/.m2/repository/org/clojure/math.combinatorics/0.1.4/math.combinatorics-0.1.4.jar\"]} [org.clojure/math.combinatorics \"0.1.4\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.datatype"],"^;","techascent/tech.datatype"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"5.0-beta-10\""],"^;","\"5.0-beta-10\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5ff27df9 \"techascent:tech.datatype:jar:5.0-beta-10 (compile)\"], :file #object[java.io.File 0x2a7e9ec7 \"/home/andreas/.m2/repository/techascent/tech.datatype/5.0-beta-10/tech.datatype-5.0-beta-10.jar\"]} [techascent/tech.datatype \"5.0-beta-10\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5ff27df9 \"techascent:tech.datatype:jar:5.0-beta-10 (compile)\"], :file #object[java.io.File 0x2a7e9ec7 \"/home/andreas/.m2/repository/techascent/tech.datatype/5.0-beta-10/tech.datatype-5.0-beta-10.jar\"]} [techascent/tech.datatype \"5.0-beta-10\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/test.check"],"^;","org.clojure/test.check"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.9.0\""],"^;","\"0.9.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2ce2ad8c \"org.clojure:test.check:jar:0.9.0 (compile)\"], :file #object[java.io.File 0x15c43f3c \"/home/andreas/.m2/repository/org/clojure/test.check/0.9.0/test.check-0.9.0.jar\"]} [org.clojure/test.check \"0.9.0\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2ce2ad8c \"org.clojure:test.check:jar:0.9.0 (compile)\"], :file #object[java.io.File 0x15c43f3c \"/home/andreas/.m2/repository/org/clojure/test.check/0.9.0/test.check-0.9.0.jar\"]} [org.clojure/test.check \"0.9.0\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.pinkgorilla/python-gorilla"],"^;","org.pinkgorilla/python-gorilla"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.0.10\""],"^;","\"0.0.10\""],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":exclusions"],"^;",":exclusions"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.pinkgorilla/gorilla-notebook"],"^;","org.pinkgorilla/gorilla-notebook"]]],"^;","~^{:exclusion #object[org.eclipse.aether.graph.Exclusion 0x3e74f332 \"org.pinkgorilla:gorilla-notebook:*:*\"]} [org.pinkgorilla/gorilla-notebook]"]]],"^;","[^{:exclusion #object[org.eclipse.aether.graph.Exclusion 0x3e74f332 \"org.pinkgorilla:gorilla-notebook:*:*\"]} [org.pinkgorilla/gorilla-notebook]]"]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x599595c8 \"org.pinkgorilla:python-gorilla:jar:0.0.10 (compile)\"], :file #object[java.io.File 0x743b09b \"/home/andreas/.m2/repository/org/pinkgorilla/python-gorilla/0.0.10/python-gorilla-0.0.10.jar\"]} [org.pinkgorilla/python-gorilla \"0.0.10\" :exclusions [^{:exclusion #object[org.eclipse.aether.graph.Exclusion 0x3e74f332 \"org.pinkgorilla:gorilla-notebook:*:*\"]} [org.pinkgorilla/gorilla-notebook]]]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-set"],"#{"],"^5",["^3",["^ ","^4","clj-set"],"}"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.pinkgorilla/gorilla-renderable"],"^;","org.pinkgorilla/gorilla-renderable"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.0.8\""],"^;","\"3.0.8\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e3914ea \"org.pinkgorilla:gorilla-renderable:jar:3.0.8 (compile)\"], :file #object[java.io.File 0x2730b53f \"/home/andreas/.m2/repository/org/pinkgorilla/gorilla-renderable/3.0.8/gorilla-renderable-3.0.8.jar\"]} [org.pinkgorilla/gorilla-renderable \"3.0.8\"]"]]],"^;","#{^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e3914ea \"org.pinkgorilla:gorilla-renderable:jar:3.0.8 (compile)\"], :file #object[java.io.File 0x2730b53f \"/home/andreas/.m2/repository/org/pinkgorilla/gorilla-renderable/3.0.8/gorilla-renderable-3.0.8.jar\"]} [org.pinkgorilla/gorilla-renderable \"3.0.8\"]}"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x599595c8 \"org.pinkgorilla:python-gorilla:jar:0.0.10 (compile)\"], :file #object[java.io.File 0x743b09b \"/home/andreas/.m2/repository/org/pinkgorilla/python-gorilla/0.0.10/python-gorilla-0.0.10.jar\"]} [org.pinkgorilla/python-gorilla \"0.0.10\" :exclusions [^{:exclusion #object[org.eclipse.aether.graph.Exclusion 0x3e74f332 \"org.pinkgorilla:gorilla-notebook:*:*\"]} [org.pinkgorilla/gorilla-notebook]]] #{^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e3914ea \"org.pinkgorilla:gorilla-renderable:jar:3.0.8 (compile)\"], :file #object[java.io.File 0x2730b53f \"/home/andreas/.m2/repository/org/pinkgorilla/gorilla-renderable/3.0.8/gorilla-renderable-3.0.8.jar\"]} [org.pinkgorilla/gorilla-renderable \"3.0.8\"]}]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.logging"],"^;","org.clojure/tools.logging"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.4.1\""],"^;","\"0.4.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0xa7d061f \"org.clojure:tools.logging:jar:0.4.1 (compile)\"], :file #object[java.io.File 0x7fb3f94d \"/home/andreas/.m2/repository/org/clojure/tools.logging/0.4.1/tools.logging-0.4.1.jar\"]} [org.clojure/tools.logging \"0.4.1\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0xa7d061f \"org.clojure:tools.logging:jar:0.4.1 (compile)\"], :file #object[java.io.File 0x7fb3f94d \"/home/andreas/.m2/repository/org/clojure/tools.logging/0.4.1/tools.logging-0.4.1.jar\"]} [org.clojure/tools.logging \"0.4.1\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.parallel"],"^;","techascent/tech.parallel"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"2.8\""],"^;","\"2.8\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x656e5948 \"techascent:tech.parallel:jar:2.8 (compile)\"], :file #object[java.io.File 0x7c9adbb4 \"/home/andreas/.m2/repository/techascent/tech.parallel/2.8/tech.parallel-2.8.jar\"]} [techascent/tech.parallel \"2.8\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x656e5948 \"techascent:tech.parallel:jar:2.8 (compile)\"], :file #object[java.io.File 0x7c9adbb4 \"/home/andreas/.m2/repository/techascent/tech.parallel/2.8/tech.parallel-2.8.jar\"]} [techascent/tech.parallel \"2.8\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.ow2.asm/asm"],"^;","org.ow2.asm/asm"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"7.0\""],"^;","\"7.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1eb567c6 \"org.ow2.asm:asm:jar:7.0 (compile)\"], :file #object[java.io.File 0x7e2c8ccc \"/home/andreas/.m2/repository/org/ow2/asm/asm/7.0/asm-7.0.jar\"]} [org.ow2.asm/asm \"7.0\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1eb567c6 \"org.ow2.asm:asm:jar:7.0 (compile)\"], :file #object[java.io.File 0x7e2c8ccc \"/home/andreas/.m2/repository/org/ow2/asm/asm/7.0/asm-7.0.jar\"]} [org.ow2.asm/asm \"7.0\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.analyzer"],"^;","org.clojure/tools.analyzer"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.7.0\""],"^;","\"0.7.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x699f2e58 \"org.clojure:tools.analyzer:jar:0.7.0 (compile)\"], :file #object[java.io.File 0x43720fa4 \"/home/andreas/.m2/repository/org/clojure/tools.analyzer/0.7.0/tools.analyzer-0.7.0.jar\"]} [org.clojure/tools.analyzer \"0.7.0\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x699f2e58 \"org.clojure:tools.analyzer:jar:0.7.0 (compile)\"], :file #object[java.io.File 0x43720fa4 \"/home/andreas/.m2/repository/org/clojure/tools.analyzer/0.7.0/tools.analyzer-0.7.0.jar\"]} [org.clojure/tools.analyzer \"0.7.0\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.jna"],"^;","techascent/tech.jna"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.23\""],"^;","\"3.23\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x764cdb5b \"techascent:tech.jna:jar:3.23 (compile)\"], :file #object[java.io.File 0x6c9c63b2 \"/home/andreas/.m2/repository/techascent/tech.jna/3.23/tech.jna-3.23.jar\"]} [techascent/tech.jna \"3.23\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x764cdb5b \"techascent:tech.jna:jar:3.23 (compile)\"], :file #object[java.io.File 0x6c9c63b2 \"/home/andreas/.m2/repository/techascent/tech.jna/3.23/tech.jna-3.23.jar\"]} [techascent/tech.jna \"3.23\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/data.priority-map"],"^;","org.clojure/data.priority-map"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.0.7\""],"^;","\"0.0.7\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7c616d97 \"org.clojure:data.priority-map:jar:0.0.7 (compile)\"], :file #object[java.io.File 0x2fbd4290 \"/home/andreas/.m2/repository/org/clojure/data.priority-map/0.0.7/data.priority-map-0.0.7.jar\"]} [org.clojure/data.priority-map \"0.0.7\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7c616d97 \"org.clojure:data.priority-map:jar:0.0.7 (compile)\"], :file #object[java.io.File 0x2fbd4290 \"/home/andreas/.m2/repository/org/clojure/data.priority-map/0.0.7/data.priority-map-0.0.7.jar\"]} [org.clojure/data.priority-map \"0.0.7\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/clojure"],"^;","org.clojure/clojure"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"1.10.1\""],"^;","\"1.10.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x3fbbc23f \"org.clojure:clojure:jar:1.10.1 (compile)\"], :file #object[java.io.File 0x30b5b789 \"/home/andreas/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar\"]} [org.clojure/clojure \"1.10.1\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x3fbbc23f \"org.clojure:clojure:jar:1.10.1 (compile)\"], :file #object[java.io.File 0x30b5b789 \"/home/andreas/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar\"]} [org.clojure/clojure \"1.10.1\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"clj-python/libpython-clj"],"^;","clj-python/libpython-clj"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"1.40\""],"^;","\"1.40\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x47cf79dd \"clj-python:libpython-clj:jar:1.40 (compile)\"], :file #object[java.io.File 0x2230a76 \"/home/andreas/.m2/repository/clj-python/libpython-clj/1.40/libpython-clj-1.40.jar\"]} [clj-python/libpython-clj \"1.40\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-set"],"#{"],"^5",["^3",["^ ","^4","clj-set"],"}"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.apache.commons/commons-math3"],"^;","org.apache.commons/commons-math3"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.6.1\""],"^;","\"3.6.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x490325e6 \"org.apache.commons:commons-math3:jar:3.6.1 (compile)\"], :file #object[java.io.File 0x71533619 \"/home/andreas/.m2/repository/org/apache/commons/commons-math3/3.6.1/commons-math3-3.6.1.jar\"]} [org.apache.commons/commons-math3 \"3.6.1\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"com.tdunning/t-digest"],"^;","com.tdunning/t-digest"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.2\""],"^;","\"3.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x753d4982 \"com.tdunning:t-digest:jar:3.2 (compile)\"], :file #object[java.io.File 0x39201200 \"/home/andreas/.m2/repository/com/tdunning/t-digest/3.2/t-digest-3.2.jar\"]} [com.tdunning/t-digest \"3.2\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.analyzer.jvm"],"^;","org.clojure/tools.analyzer.jvm"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.7.3\""],"^;","\"0.7.3\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x695c3cd7 \"org.clojure:tools.analyzer.jvm:jar:0.7.3 (compile)\"], :file #object[java.io.File 0x1573c1b \"/home/andreas/.m2/repository/org/clojure/tools.analyzer.jvm/0.7.3/tools.analyzer.jvm-0.7.3.jar\"]} [org.clojure/tools.analyzer.jvm \"0.7.3\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.reader"],"^;","org.clojure/tools.reader"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"1.3.2\""],"^;","\"1.3.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x41c501da \"org.clojure:tools.reader:jar:1.3.2 (compile)\"], :file #object[java.io.File 0x637ecd90 \"/home/andreas/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar\"]} [org.clojure/tools.reader \"1.3.2\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/data.json"],"^;","org.clojure/data.json"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.2.7\""],"^;","\"0.2.7\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x58bb60ba \"org.clojure:data.json:jar:0.2.7 (compile)\"], :file #object[java.io.File 0x2183dbd9 \"/home/andreas/.m2/repository/org/clojure/data.json/0.2.7/data.json-0.2.7.jar\"]} [org.clojure/data.json \"0.2.7\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"camel-snake-kebab"],"^;","camel-snake-kebab"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.4.0\""],"^;","\"0.4.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x48a1c5e2 \"camel-snake-kebab:camel-snake-kebab:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x5da6832b \"/home/andreas/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.0/camel-snake-kebab-0.4.0.jar\"]} [camel-snake-kebab \"0.4.0\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.resource"],"^;","techascent/tech.resource"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"4.6\""],"^;","\"4.6\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5e9b9695 \"techascent:tech.resource:jar:4.6 (compile)\"], :file #object[java.io.File 0x61f9d38c \"/home/andreas/.m2/repository/techascent/tech.resource/4.6/tech.resource-4.6.jar\"]} [techascent/tech.resource \"4.6\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.async"],"^;","org.clojure/core.async"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.7.559\""],"^;","\"0.7.559\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x27b18484 \"org.clojure:core.async:jar:0.7.559 (compile)\"], :file #object[java.io.File 0x4ee7f482 \"/home/andreas/.m2/repository/org/clojure/core.async/0.7.559/core.async-0.7.559.jar\"]} [org.clojure/core.async \"0.7.559\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"kixi/stats"],"^;","kixi/stats"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.5.2\""],"^;","\"0.5.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x4c4aecf5 \"kixi:stats:jar:0.5.2 (compile)\"], :file #object[java.io.File 0x63802343 \"/home/andreas/.m2/repository/kixi/stats/0.5.2/stats-0.5.2.jar\"]} [kixi/stats \"0.5.2\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.roaringbitmap/RoaringBitmap"],"^;","org.roaringbitmap/RoaringBitmap"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.13\""],"^;","\"0.8.13\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x483e1e13 \"org.roaringbitmap:RoaringBitmap:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x390cb072 \"/home/andreas/.m2/repository/org/roaringbitmap/RoaringBitmap/0.8.13/RoaringBitmap-0.8.13.jar\"]} [org.roaringbitmap/RoaringBitmap \"0.8.13\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.roaringbitmap/shims"],"^;","org.roaringbitmap/shims"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.13\""],"^;","\"0.8.13\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x22badee2 \"org.roaringbitmap:shims:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x40426bcd \"/home/andreas/.m2/repository/org/roaringbitmap/shims/0.8.13/shims-0.8.13.jar\"]} [org.roaringbitmap/shims \"0.8.13\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.cache"],"^;","org.clojure/core.cache"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.2\""],"^;","\"0.8.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x78343b50 \"org.clojure:core.cache:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x24e79b04 \"/home/andreas/.m2/repository/org/clojure/core.cache/0.8.2/core.cache-0.8.2.jar\"]} [org.clojure/core.cache \"0.8.2\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"net.java.dev.jna/jna"],"^;","net.java.dev.jna/jna"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"5.2.0\""],"^;","\"5.2.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x50de1cb4 \"net.java.dev.jna:jna:jar:5.2.0 (compile)\"], :file #object[java.io.File 0x3110961 \"/home/andreas/.m2/repository/net/java/dev/jna/jna/5.2.0/jna-5.2.0.jar\"]} [net.java.dev.jna/jna \"5.2.0\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"primitive-math"],"^;","primitive-math"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.6\""],"^;","\"0.1.6\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5a264ce8 \"primitive-math:primitive-math:jar:0.1.6 (compile)\"], :file #object[java.io.File 0x4201c313 \"/home/andreas/.m2/repository/primitive-math/primitive-math/0.1.6/primitive-math-0.1.6.jar\"]} [primitive-math \"0.1.6\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.memoize"],"^;","org.clojure/core.memoize"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.8.2\""],"^;","\"0.8.2\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x629a4c5b \"org.clojure:core.memoize:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x69cb0b68 \"/home/andreas/.m2/repository/org/clojure/core.memoize/0.8.2/core.memoize-0.8.2.jar\"]} [org.clojure/core.memoize \"0.8.2\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"it.unimi.dsi/fastutil"],"^;","it.unimi.dsi/fastutil"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"8.2.1\""],"^;","\"8.2.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e25bb5 \"it.unimi.dsi:fastutil:jar:8.2.1 (compile)\"], :file #object[java.io.File 0x4db709c1 \"/home/andreas/.m2/repository/it/unimi/dsi/fastutil/8.2.1/fastutil-8.2.1.jar\"]} [it.unimi.dsi/fastutil \"8.2.1\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/math.combinatorics"],"^;","org.clojure/math.combinatorics"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.4\""],"^;","\"0.1.4\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7d7f7cb8 \"org.clojure:math.combinatorics:jar:0.1.4 (compile)\"], :file #object[java.io.File 0x4c5eb834 \"/home/andreas/.m2/repository/org/clojure/math.combinatorics/0.1.4/math.combinatorics-0.1.4.jar\"]} [org.clojure/math.combinatorics \"0.1.4\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.datatype"],"^;","techascent/tech.datatype"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"5.0-beta-10\""],"^;","\"5.0-beta-10\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5ff27df9 \"techascent:tech.datatype:jar:5.0-beta-10 (compile)\"], :file #object[java.io.File 0x2a7e9ec7 \"/home/andreas/.m2/repository/techascent/tech.datatype/5.0-beta-10/tech.datatype-5.0-beta-10.jar\"]} [techascent/tech.datatype \"5.0-beta-10\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/test.check"],"^;","org.clojure/test.check"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.9.0\""],"^;","\"0.9.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2ce2ad8c \"org.clojure:test.check:jar:0.9.0 (compile)\"], :file #object[java.io.File 0x15c43f3c \"/home/andreas/.m2/repository/org/clojure/test.check/0.9.0/test.check-0.9.0.jar\"]} [org.clojure/test.check \"0.9.0\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.logging"],"^;","org.clojure/tools.logging"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.4.1\""],"^;","\"0.4.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0xa7d061f \"org.clojure:tools.logging:jar:0.4.1 (compile)\"], :file #object[java.io.File 0x7fb3f94d \"/home/andreas/.m2/repository/org/clojure/tools.logging/0.4.1/tools.logging-0.4.1.jar\"]} [org.clojure/tools.logging \"0.4.1\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.parallel"],"^;","techascent/tech.parallel"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"2.8\""],"^;","\"2.8\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x656e5948 \"techascent:tech.parallel:jar:2.8 (compile)\"], :file #object[java.io.File 0x7c9adbb4 \"/home/andreas/.m2/repository/techascent/tech.parallel/2.8/tech.parallel-2.8.jar\"]} [techascent/tech.parallel \"2.8\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.ow2.asm/asm"],"^;","org.ow2.asm/asm"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"7.0\""],"^;","\"7.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1eb567c6 \"org.ow2.asm:asm:jar:7.0 (compile)\"], :file #object[java.io.File 0x7e2c8ccc \"/home/andreas/.m2/repository/org/ow2/asm/asm/7.0/asm-7.0.jar\"]} [org.ow2.asm/asm \"7.0\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/tools.analyzer"],"^;","org.clojure/tools.analyzer"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.7.0\""],"^;","\"0.7.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x699f2e58 \"org.clojure:tools.analyzer:jar:0.7.0 (compile)\"], :file #object[java.io.File 0x43720fa4 \"/home/andreas/.m2/repository/org/clojure/tools.analyzer/0.7.0/tools.analyzer-0.7.0.jar\"]} [org.clojure/tools.analyzer \"0.7.0\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"techascent/tech.jna"],"^;","techascent/tech.jna"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"3.23\""],"^;","\"3.23\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x764cdb5b \"techascent:tech.jna:jar:3.23 (compile)\"], :file #object[java.io.File 0x6c9c63b2 \"/home/andreas/.m2/repository/techascent/tech.jna/3.23/tech.jna-3.23.jar\"]} [techascent/tech.jna \"3.23\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/data.priority-map"],"^;","org.clojure/data.priority-map"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.0.7\""],"^;","\"0.0.7\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7c616d97 \"org.clojure:data.priority-map:jar:0.0.7 (compile)\"], :file #object[java.io.File 0x2fbd4290 \"/home/andreas/.m2/repository/org/clojure/data.priority-map/0.0.7/data.priority-map-0.0.7.jar\"]} [org.clojure/data.priority-map \"0.0.7\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/clojure"],"^;","org.clojure/clojure"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"1.10.1\""],"^;","\"1.10.1\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x3fbbc23f \"org.clojure:clojure:jar:1.10.1 (compile)\"], :file #object[java.io.File 0x30b5b789 \"/home/andreas/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar\"]} [org.clojure/clojure \"1.10.1\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"redux"],"^;","redux"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.3\""],"^;","\"0.1.3\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x63688a37 \"redux:redux:jar:0.1.3 (compile)\"], :file #object[java.io.File 0x7e7c702c \"/home/andreas/.m2/repository/redux/redux/0.1.3/redux-0.1.3.jar\"]} [redux \"0.1.3\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.specs.alpha"],"^;","org.clojure/core.specs.alpha"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.2.44\""],"^;","\"0.2.44\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x42c1efaf \"org.clojure:core.specs.alpha:jar:0.2.44 (compile)\"], :file #object[java.io.File 0x582b3d3b \"/home/andreas/.m2/repository/org/clojure/core.specs.alpha/0.2.44/core.specs.alpha-0.2.44.jar\"]} [org.clojure/core.specs.alpha \"0.2.44\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"insn"],"^;","insn"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.4.0\""],"^;","\"0.4.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7f353d3b \"insn:insn:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x6255dfe1 \"/home/andreas/.m2/repository/insn/insn/0.4.0/insn-0.4.0.jar\"]} [insn \"0.4.0\"]"],["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/spec.alpha"],"^;","org.clojure/spec.alpha"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.2.176\""],"^;","\"0.2.176\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f24e893 \"org.clojure:spec.alpha:jar:0.2.176 (compile)\"], :file #object[java.io.File 0x2ee7caa9 \"/home/andreas/.m2/repository/org/clojure/spec.alpha/0.2.176/spec.alpha-0.2.176.jar\"]} [org.clojure/spec.alpha \"0.2.176\"]"]]],"^;","#{^{:dependency #object[org.eclipse.aether.graph.Dependency 0x490325e6 \"org.apache.commons:commons-math3:jar:3.6.1 (compile)\"], :file #object[java.io.File 0x71533619 \"/home/andreas/.m2/repository/org/apache/commons/commons-math3/3.6.1/commons-math3-3.6.1.jar\"]} [org.apache.commons/commons-math3 \"3.6.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x753d4982 \"com.tdunning:t-digest:jar:3.2 (compile)\"], :file #object[java.io.File 0x39201200 \"/home/andreas/.m2/repository/com/tdunning/t-digest/3.2/t-digest-3.2.jar\"]} [com.tdunning/t-digest \"3.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x695c3cd7 \"org.clojure:tools.analyzer.jvm:jar:0.7.3 (compile)\"], :file #object[java.io.File 0x1573c1b \"/home/andreas/.m2/repository/org/clojure/tools.analyzer.jvm/0.7.3/tools.analyzer.jvm-0.7.3.jar\"]} [org.clojure/tools.analyzer.jvm \"0.7.3\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x41c501da \"org.clojure:tools.reader:jar:1.3.2 (compile)\"], :file #object[java.io.File 0x637ecd90 \"/home/andreas/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar\"]} [org.clojure/tools.reader \"1.3.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x58bb60ba \"org.clojure:data.json:jar:0.2.7 (compile)\"], :file #object[java.io.File 0x2183dbd9 \"/home/andreas/.m2/repository/org/clojure/data.json/0.2.7/data.json-0.2.7.jar\"]} [org.clojure/data.json \"0.2.7\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x48a1c5e2 \"camel-snake-kebab:camel-snake-kebab:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x5da6832b \"/home/andreas/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.0/camel-snake-kebab-0.4.0.jar\"]} [camel-snake-kebab \"0.4.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5e9b9695 \"techascent:tech.resource:jar:4.6 (compile)\"], :file #object[java.io.File 0x61f9d38c \"/home/andreas/.m2/repository/techascent/tech.resource/4.6/tech.resource-4.6.jar\"]} [techascent/tech.resource \"4.6\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x27b18484 \"org.clojure:core.async:jar:0.7.559 (compile)\"], :file #object[java.io.File 0x4ee7f482 \"/home/andreas/.m2/repository/org/clojure/core.async/0.7.559/core.async-0.7.559.jar\"]} [org.clojure/core.async \"0.7.559\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x4c4aecf5 \"kixi:stats:jar:0.5.2 (compile)\"], :file #object[java.io.File 0x63802343 \"/home/andreas/.m2/repository/kixi/stats/0.5.2/stats-0.5.2.jar\"]} [kixi/stats \"0.5.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x483e1e13 \"org.roaringbitmap:RoaringBitmap:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x390cb072 \"/home/andreas/.m2/repository/org/roaringbitmap/RoaringBitmap/0.8.13/RoaringBitmap-0.8.13.jar\"]} [org.roaringbitmap/RoaringBitmap \"0.8.13\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x22badee2 \"org.roaringbitmap:shims:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x40426bcd \"/home/andreas/.m2/repository/org/roaringbitmap/shims/0.8.13/shims-0.8.13.jar\"]} [org.roaringbitmap/shims \"0.8.13\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x78343b50 \"org.clojure:core.cache:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x24e79b04 \"/home/andreas/.m2/repository/org/clojure/core.cache/0.8.2/core.cache-0.8.2.jar\"]} [org.clojure/core.cache \"0.8.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x50de1cb4 \"net.java.dev.jna:jna:jar:5.2.0 (compile)\"], :file #object[java.io.File 0x3110961 \"/home/andreas/.m2/repository/net/java/dev/jna/jna/5.2.0/jna-5.2.0.jar\"]} [net.java.dev.jna/jna \"5.2.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5a264ce8 \"primitive-math:primitive-math:jar:0.1.6 (compile)\"], :file #object[java.io.File 0x4201c313 \"/home/andreas/.m2/repository/primitive-math/primitive-math/0.1.6/primitive-math-0.1.6.jar\"]} [primitive-math \"0.1.6\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x629a4c5b \"org.clojure:core.memoize:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x69cb0b68 \"/home/andreas/.m2/repository/org/clojure/core.memoize/0.8.2/core.memoize-0.8.2.jar\"]} [org.clojure/core.memoize \"0.8.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e25bb5 \"it.unimi.dsi:fastutil:jar:8.2.1 (compile)\"], :file #object[java.io.File 0x4db709c1 \"/home/andreas/.m2/repository/it/unimi/dsi/fastutil/8.2.1/fastutil-8.2.1.jar\"]} [it.unimi.dsi/fastutil \"8.2.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7d7f7cb8 \"org.clojure:math.combinatorics:jar:0.1.4 (compile)\"], :file #object[java.io.File 0x4c5eb834 \"/home/andreas/.m2/repository/org/clojure/math.combinatorics/0.1.4/math.combinatorics-0.1.4.jar\"]} [org.clojure/math.combinatorics \"0.1.4\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5ff27df9 \"techascent:tech.datatype:jar:5.0-beta-10 (compile)\"], :file #object[java.io.File 0x2a7e9ec7 \"/home/andreas/.m2/repository/techascent/tech.datatype/5.0-beta-10/tech.datatype-5.0-beta-10.jar\"]} [techascent/tech.datatype \"5.0-beta-10\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2ce2ad8c \"org.clojure:test.check:jar:0.9.0 (compile)\"], :file #object[java.io.File 0x15c43f3c \"/home/andreas/.m2/repository/org/clojure/test.check/0.9.0/test.check-0.9.0.jar\"]} [org.clojure/test.check \"0.9.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0xa7d061f \"org.clojure:tools.logging:jar:0.4.1 (compile)\"], :file #object[java.io.File 0x7fb3f94d \"/home/andreas/.m2/repository/org/clojure/tools.logging/0.4.1/tools.logging-0.4.1.jar\"]} [org.clojure/tools.logging \"0.4.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x656e5948 \"techascent:tech.parallel:jar:2.8 (compile)\"], :file #object[java.io.File 0x7c9adbb4 \"/home/andreas/.m2/repository/techascent/tech.parallel/2.8/tech.parallel-2.8.jar\"]} [techascent/tech.parallel \"2.8\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1eb567c6 \"org.ow2.asm:asm:jar:7.0 (compile)\"], :file #object[java.io.File 0x7e2c8ccc \"/home/andreas/.m2/repository/org/ow2/asm/asm/7.0/asm-7.0.jar\"]} [org.ow2.asm/asm \"7.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x699f2e58 \"org.clojure:tools.analyzer:jar:0.7.0 (compile)\"], :file #object[java.io.File 0x43720fa4 \"/home/andreas/.m2/repository/org/clojure/tools.analyzer/0.7.0/tools.analyzer-0.7.0.jar\"]} [org.clojure/tools.analyzer \"0.7.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x764cdb5b \"techascent:tech.jna:jar:3.23 (compile)\"], :file #object[java.io.File 0x6c9c63b2 \"/home/andreas/.m2/repository/techascent/tech.jna/3.23/tech.jna-3.23.jar\"]} [techascent/tech.jna \"3.23\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7c616d97 \"org.clojure:data.priority-map:jar:0.0.7 (compile)\"], :file #object[java.io.File 0x2fbd4290 \"/home/andreas/.m2/repository/org/clojure/data.priority-map/0.0.7/data.priority-map-0.0.7.jar\"]} [org.clojure/data.priority-map \"0.0.7\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x3fbbc23f \"org.clojure:clojure:jar:1.10.1 (compile)\"], :file #object[java.io.File 0x30b5b789 \"/home/andreas/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar\"]} [org.clojure/clojure \"1.10.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x63688a37 \"redux:redux:jar:0.1.3 (compile)\"], :file #object[java.io.File 0x7e7c702c \"/home/andreas/.m2/repository/redux/redux/0.1.3/redux-0.1.3.jar\"]} [redux \"0.1.3\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x42c1efaf \"org.clojure:core.specs.alpha:jar:0.2.44 (compile)\"], :file #object[java.io.File 0x582b3d3b \"/home/andreas/.m2/repository/org/clojure/core.specs.alpha/0.2.44/core.specs.alpha-0.2.44.jar\"]} [org.clojure/core.specs.alpha \"0.2.44\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7f353d3b \"insn:insn:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x6255dfe1 \"/home/andreas/.m2/repository/insn/insn/0.4.0/insn-0.4.0.jar\"]} [insn \"0.4.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f24e893 \"org.clojure:spec.alpha:jar:0.2.176 (compile)\"], :file #object[java.io.File 0x2ee7caa9 \"/home/andreas/.m2/repository/org/clojure/spec.alpha/0.2.176/spec.alpha-0.2.176.jar\"]} [org.clojure/spec.alpha \"0.2.176\"]}"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x47cf79dd \"clj-python:libpython-clj:jar:1.40 (compile)\"], :file #object[java.io.File 0x2230a76 \"/home/andreas/.m2/repository/clj-python/libpython-clj/1.40/libpython-clj-1.40.jar\"]} [clj-python/libpython-clj \"1.40\"] #{^{:dependency #object[org.eclipse.aether.graph.Dependency 0x490325e6 \"org.apache.commons:commons-math3:jar:3.6.1 (compile)\"], :file #object[java.io.File 0x71533619 \"/home/andreas/.m2/repository/org/apache/commons/commons-math3/3.6.1/commons-math3-3.6.1.jar\"]} [org.apache.commons/commons-math3 \"3.6.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x753d4982 \"com.tdunning:t-digest:jar:3.2 (compile)\"], :file #object[java.io.File 0x39201200 \"/home/andreas/.m2/repository/com/tdunning/t-digest/3.2/t-digest-3.2.jar\"]} [com.tdunning/t-digest \"3.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x695c3cd7 \"org.clojure:tools.analyzer.jvm:jar:0.7.3 (compile)\"], :file #object[java.io.File 0x1573c1b \"/home/andreas/.m2/repository/org/clojure/tools.analyzer.jvm/0.7.3/tools.analyzer.jvm-0.7.3.jar\"]} [org.clojure/tools.analyzer.jvm \"0.7.3\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x41c501da \"org.clojure:tools.reader:jar:1.3.2 (compile)\"], :file #object[java.io.File 0x637ecd90 \"/home/andreas/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar\"]} [org.clojure/tools.reader \"1.3.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x58bb60ba \"org.clojure:data.json:jar:0.2.7 (compile)\"], :file #object[java.io.File 0x2183dbd9 \"/home/andreas/.m2/repository/org/clojure/data.json/0.2.7/data.json-0.2.7.jar\"]} [org.clojure/data.json \"0.2.7\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x48a1c5e2 \"camel-snake-kebab:camel-snake-kebab:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x5da6832b \"/home/andreas/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.0/camel-snake-kebab-0.4.0.jar\"]} [camel-snake-kebab \"0.4.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5e9b9695 \"techascent:tech.resource:jar:4.6 (compile)\"], :file #object[java.io.File 0x61f9d38c \"/home/andreas/.m2/repository/techascent/tech.resource/4.6/tech.resource-4.6.jar\"]} [techascent/tech.resource \"4.6\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x27b18484 \"org.clojure:core.async:jar:0.7.559 (compile)\"], :file #object[java.io.File 0x4ee7f482 \"/home/andreas/.m2/repository/org/clojure/core.async/0.7.559/core.async-0.7.559.jar\"]} [org.clojure/core.async \"0.7.559\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x4c4aecf5 \"kixi:stats:jar:0.5.2 (compile)\"], :file #object[java.io.File 0x63802343 \"/home/andreas/.m2/repository/kixi/stats/0.5.2/stats-0.5.2.jar\"]} [kixi/stats \"0.5.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x483e1e13 \"org.roaringbitmap:RoaringBitmap:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x390cb072 \"/home/andreas/.m2/repository/org/roaringbitmap/RoaringBitmap/0.8.13/RoaringBitmap-0.8.13.jar\"]} [org.roaringbitmap/RoaringBitmap \"0.8.13\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x22badee2 \"org.roaringbitmap:shims:jar:0.8.13 (compile)\"], :file #object[java.io.File 0x40426bcd \"/home/andreas/.m2/repository/org/roaringbitmap/shims/0.8.13/shims-0.8.13.jar\"]} [org.roaringbitmap/shims \"0.8.13\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x78343b50 \"org.clojure:core.cache:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x24e79b04 \"/home/andreas/.m2/repository/org/clojure/core.cache/0.8.2/core.cache-0.8.2.jar\"]} [org.clojure/core.cache \"0.8.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x50de1cb4 \"net.java.dev.jna:jna:jar:5.2.0 (compile)\"], :file #object[java.io.File 0x3110961 \"/home/andreas/.m2/repository/net/java/dev/jna/jna/5.2.0/jna-5.2.0.jar\"]} [net.java.dev.jna/jna \"5.2.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5a264ce8 \"primitive-math:primitive-math:jar:0.1.6 (compile)\"], :file #object[java.io.File 0x4201c313 \"/home/andreas/.m2/repository/primitive-math/primitive-math/0.1.6/primitive-math-0.1.6.jar\"]} [primitive-math \"0.1.6\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x629a4c5b \"org.clojure:core.memoize:jar:0.8.2 (compile)\"], :file #object[java.io.File 0x69cb0b68 \"/home/andreas/.m2/repository/org/clojure/core.memoize/0.8.2/core.memoize-0.8.2.jar\"]} [org.clojure/core.memoize \"0.8.2\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1e25bb5 \"it.unimi.dsi:fastutil:jar:8.2.1 (compile)\"], :file #object[java.io.File 0x4db709c1 \"/home/andreas/.m2/repository/it/unimi/dsi/fastutil/8.2.1/fastutil-8.2.1.jar\"]} [it.unimi.dsi/fastutil \"8.2.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7d7f7cb8 \"org.clojure:math.combinatorics:jar:0.1.4 (compile)\"], :file #object[java.io.File 0x4c5eb834 \"/home/andreas/.m2/repository/org/clojure/math.combinatorics/0.1.4/math.combinatorics-0.1.4.jar\"]} [org.clojure/math.combinatorics \"0.1.4\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x5ff27df9 \"techascent:tech.datatype:jar:5.0-beta-10 (compile)\"], :file #object[java.io.File 0x2a7e9ec7 \"/home/andreas/.m2/repository/techascent/tech.datatype/5.0-beta-10/tech.datatype-5.0-beta-10.jar\"]} [techascent/tech.datatype \"5.0-beta-10\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2ce2ad8c \"org.clojure:test.check:jar:0.9.0 (compile)\"], :file #object[java.io.File 0x15c43f3c \"/home/andreas/.m2/repository/org/clojure/test.check/0.9.0/test.check-0.9.0.jar\"]} [org.clojure/test.check \"0.9.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0xa7d061f \"org.clojure:tools.logging:jar:0.4.1 (compile)\"], :file #object[java.io.File 0x7fb3f94d \"/home/andreas/.m2/repository/org/clojure/tools.logging/0.4.1/tools.logging-0.4.1.jar\"]} [org.clojure/tools.logging \"0.4.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x656e5948 \"techascent:tech.parallel:jar:2.8 (compile)\"], :file #object[java.io.File 0x7c9adbb4 \"/home/andreas/.m2/repository/techascent/tech.parallel/2.8/tech.parallel-2.8.jar\"]} [techascent/tech.parallel \"2.8\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x1eb567c6 \"org.ow2.asm:asm:jar:7.0 (compile)\"], :file #object[java.io.File 0x7e2c8ccc \"/home/andreas/.m2/repository/org/ow2/asm/asm/7.0/asm-7.0.jar\"]} [org.ow2.asm/asm \"7.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x699f2e58 \"org.clojure:tools.analyzer:jar:0.7.0 (compile)\"], :file #object[java.io.File 0x43720fa4 \"/home/andreas/.m2/repository/org/clojure/tools.analyzer/0.7.0/tools.analyzer-0.7.0.jar\"]} [org.clojure/tools.analyzer \"0.7.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x764cdb5b \"techascent:tech.jna:jar:3.23 (compile)\"], :file #object[java.io.File 0x6c9c63b2 \"/home/andreas/.m2/repository/techascent/tech.jna/3.23/tech.jna-3.23.jar\"]} [techascent/tech.jna \"3.23\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7c616d97 \"org.clojure:data.priority-map:jar:0.0.7 (compile)\"], :file #object[java.io.File 0x2fbd4290 \"/home/andreas/.m2/repository/org/clojure/data.priority-map/0.0.7/data.priority-map-0.0.7.jar\"]} [org.clojure/data.priority-map \"0.0.7\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x3fbbc23f \"org.clojure:clojure:jar:1.10.1 (compile)\"], :file #object[java.io.File 0x30b5b789 \"/home/andreas/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar\"]} [org.clojure/clojure \"1.10.1\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x63688a37 \"redux:redux:jar:0.1.3 (compile)\"], :file #object[java.io.File 0x7e7c702c \"/home/andreas/.m2/repository/redux/redux/0.1.3/redux-0.1.3.jar\"]} [redux \"0.1.3\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x42c1efaf \"org.clojure:core.specs.alpha:jar:0.2.44 (compile)\"], :file #object[java.io.File 0x582b3d3b \"/home/andreas/.m2/repository/org/clojure/core.specs.alpha/0.2.44/core.specs.alpha-0.2.44.jar\"]} [org.clojure/core.specs.alpha \"0.2.44\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7f353d3b \"insn:insn:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x6255dfe1 \"/home/andreas/.m2/repository/insn/insn/0.4.0/insn-0.4.0.jar\"]} [insn \"0.4.0\"] ^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f24e893 \"org.clojure:spec.alpha:jar:0.2.176 (compile)\"], :file #object[java.io.File 0x2ee7caa9 \"/home/andreas/.m2/repository/org/clojure/spec.alpha/0.2.176/spec.alpha-0.2.176.jar\"]} [org.clojure/spec.alpha \"0.2.176\"]}]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"redux"],"^;","redux"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.1.3\""],"^;","\"0.1.3\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x63688a37 \"redux:redux:jar:0.1.3 (compile)\"], :file #object[java.io.File 0x7e7c702c \"/home/andreas/.m2/repository/redux/redux/0.1.3/redux-0.1.3.jar\"]} [redux \"0.1.3\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x63688a37 \"redux:redux:jar:0.1.3 (compile)\"], :file #object[java.io.File 0x7e7c702c \"/home/andreas/.m2/repository/redux/redux/0.1.3/redux-0.1.3.jar\"]} [redux \"0.1.3\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/core.specs.alpha"],"^;","org.clojure/core.specs.alpha"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.2.44\""],"^;","\"0.2.44\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x42c1efaf \"org.clojure:core.specs.alpha:jar:0.2.44 (compile)\"], :file #object[java.io.File 0x582b3d3b \"/home/andreas/.m2/repository/org/clojure/core.specs.alpha/0.2.44/core.specs.alpha-0.2.44.jar\"]} [org.clojure/core.specs.alpha \"0.2.44\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x42c1efaf \"org.clojure:core.specs.alpha:jar:0.2.44 (compile)\"], :file #object[java.io.File 0x582b3d3b \"/home/andreas/.m2/repository/org/clojure/core.specs.alpha/0.2.44/core.specs.alpha-0.2.44.jar\"]} [org.clojure/core.specs.alpha \"0.2.44\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"insn"],"^;","insn"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.4.0\""],"^;","\"0.4.0\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7f353d3b \"insn:insn:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x6255dfe1 \"/home/andreas/.m2/repository/insn/insn/0.4.0/insn-0.4.0.jar\"]} [insn \"0.4.0\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x7f353d3b \"insn:insn:jar:0.4.0 (compile)\"], :file #object[java.io.File 0x6255dfe1 \"/home/andreas/.m2/repository/insn/insn/0.4.0/insn-0.4.0.jar\"]} [insn \"0.4.0\"] nil]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^1","^2",["^3",["^ ","^4","clj-vector"],"["],"^5",["^3",["^ ","^4","clj-vector"],"]"],"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-symbol"],"org.clojure/spec.alpha"],"^;","org.clojure/spec.alpha"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-string"],"\"0.2.176\""],"^;","\"0.2.176\""]]],"^;","~^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f24e893 \"org.clojure:spec.alpha:jar:0.2.176 (compile)\"], :file #object[java.io.File 0x2ee7caa9 \"/home/andreas/.m2/repository/org/clojure/spec.alpha/0.2.176/spec.alpha-0.2.176.jar\"]} [org.clojure/spec.alpha \"0.2.176\"]"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-nil"],"nil"],"^;","nil"]]],"^;","[^{:dependency #object[org.eclipse.aether.graph.Dependency 0x2f24e893 \"org.clojure:spec.alpha:jar:0.2.176 (compile)\"], :file #object[java.io.File 0x2ee7caa9 \"/home/andreas/.m2/repository/org/clojure/spec.alpha/0.2.176/spec.alpha-0.2.176.jar\"]} [org.clojure/spec.alpha \"0.2.176\"] nil]"]]],"^;","{[org.apache.commons/commons-math3 \"3.6.1\"] nil, [com.tdunning/t-digest \"3.2\"] nil, [org.clojure/tools.analyzer.jvm \"0.7.3\"] nil, [org.pinkgorilla/gorilla-renderable \"3.0.8\"] #{[org.clojure/data.codec \"0.1.1\"]}, [org.clojure/tools.reader \"1.3.2\"] nil, [org.clojure/data.json \"0.2.7\"] nil, [camel-snake-kebab \"0.4.0\"] nil, [techascent/tech.resource \"4.6\"] nil, [org.clojure/core.async \"0.7.559\"] nil, [kixi/stats \"0.5.2\"] nil, [org.clojure/data.codec \"0.1.1\"] nil, [org.roaringbitmap/RoaringBitmap \"0.8.13\"] nil, [org.roaringbitmap/shims \"0.8.13\"] nil, [org.clojure/core.cache \"0.8.2\"] nil, [net.java.dev.jna/jna \"5.2.0\"] nil, [primitive-math \"0.1.6\"] nil, [org.clojure/core.memoize \"0.8.2\"] nil, [it.unimi.dsi/fastutil \"8.2.1\"] nil, [org.clojure/math.combinatorics \"0.1.4\"] nil, [techascent/tech.datatype \"5.0-beta-10\"] nil, [org.clojure/test.check \"0.9.0\"] nil, [org.pinkgorilla/python-gorilla \"0.0.10\" :exclusions [[org.pinkgorilla/gorilla-notebook]]] #{[org.pinkgorilla/gorilla-renderable \"3.0.8\"]}, [org.clojure/tools.logging \"0.4.1\"] nil, [techascent/tech.parallel \"2.8\"] nil, [org.ow2.asm/asm \"7.0\"] nil, [org.clojure/tools.analyzer \"0.7.0\"] nil, [techascent/tech.jna \"3.23\"] nil, [org.clojure/data.priority-map \"0.0.7\"] nil, [org.clojure/clojure \"1.10.1\"] nil, [clj-python/libpython-clj \"1.40\"] #{[org.apache.commons/commons-math3 \"3.6.1\"] [com.tdunning/t-digest \"3.2\"] [org.clojure/tools.analyzer.jvm \"0.7.3\"] [org.clojure/tools.reader \"1.3.2\"] [org.clojure/data.json \"0.2.7\"] [camel-snake-kebab \"0.4.0\"] [techascent/tech.resource \"4.6\"] [org.clojure/core.async \"0.7.559\"] [kixi/stats \"0.5.2\"] [org.roaringbitmap/RoaringBitmap \"0.8.13\"] [org.roaringbitmap/shims \"0.8.13\"] [org.clojure/core.cache \"0.8.2\"] [net.java.dev.jna/jna \"5.2.0\"] [primitive-math \"0.1.6\"] [org.clojure/core.memoize \"0.8.2\"] [it.unimi.dsi/fastutil \"8.2.1\"] [org.clojure/math.combinatorics \"0.1.4\"] [techascent/tech.datatype \"5.0-beta-10\"] [org.clojure/test.check \"0.9.0\"] [org.clojure/tools.logging \"0.4.1\"] [techascent/tech.parallel \"2.8\"] [org.ow2.asm/asm \"7.0\"] [org.clojure/tools.analyzer \"0.7.0\"] [techascent/tech.jna \"3.23\"] [org.clojure/data.priority-map \"0.0.7\"] [org.clojure/clojure \"1.10.1\"] [redux \"0.1.3\"] [org.clojure/core.specs.alpha \"0.2.44\"] [insn \"0.4.0\"] [org.clojure/spec.alpha \"0.2.176\"]}, [redux \"0.1.3\"] nil, [org.clojure/core.specs.alpha \"0.2.44\"] nil, [insn \"0.4.0\"] nil, [org.clojure/spec.alpha \"0.2.176\"] nil}"]
;; <=

;; @@ [clj]
(ns datafy-demo
  (:require 
   [clojure.datafy :refer [datafy]]
   [libpython-clj.require :refer [require-python]] ; pydafy
   [libpython-clj.python :as py :refer [py. py.. py.-]]
   [libpython-clj.metadata :refer [ datafy-module  nav-module ]]
   [pinkgorilla.python.core :refer [py-initialize! pydoc]]
   [pinkgorilla.python.plot :refer [with-show]]))
;; @@
;; ->
;;; python config:  {:python-executable ~/.conda/envs/pyclj/bin/python3.7, :library-path ~/.conda/envs/pyclj/lib/libpython3.7m.dylib}
;; <-
;; =>
;;; ["^ ","~:type","~:html","~:content",["~:span",["^ ","~:class","clj-nil"],"nil"],"~:value","nil"]
;; <=

;; @@ [clj]
(require-python '[matplotlib.pyplot :as pyplot])
;(require-python '[numpy :as numpy])
(require-python '[numpy :as numpy :bind-ns])
;;;; you will need matplotlib, numpy, and pillow installed to run this in python3
;; @@
;; =>
;;; ["^ ","~:type","~:html","~:content",["~:span",["^ ","~:class","clj-keyword"],":ok"],"~:value",":ok"]
;; <=

;; @@ [clj]
(def x (numpy/linspace 0 2 50))
x
;; @@
;; =>
;;; ["^ ","~:type","~:html","~:content",["~:span",["^ ","~:class","clj-unkown"],"[0.         0.04081633 0.08163265 0.12244898 0.16326531 0.20408163\n 0.24489796 0.28571429 0.32653061 0.36734694 0.40816327 0.44897959\n 0.48979592 0.53061224 0.57142857 0.6122449  0.65306122 0.69387755\n 0.73469388 0.7755102  0.81632653 0.85714286 0.89795918 0.93877551\n 0.97959184 1.02040816 1.06122449 1.10204082 1.14285714 1.18367347\n 1.2244898  1.26530612 1.30612245 1.34693878 1.3877551  1.42857143\n 1.46938776 1.51020408 1.55102041 1.59183673 1.63265306 1.67346939\n 1.71428571 1.75510204 1.79591837 1.83673469 1.87755102 1.91836735\n 1.95918367 2.        ]"],"~:value","[0.         0.04081633 0.08163265 0.12244898 0.16326531 0.20408163\n 0.24489796 0.28571429 0.32653061 0.36734694 0.40816327 0.44897959\n 0.48979592 0.53061224 0.57142857 0.6122449  0.65306122 0.69387755\n 0.73469388 0.7755102  0.81632653 0.85714286 0.89795918 0.93877551\n 0.97959184 1.02040816 1.06122449 1.10204082 1.14285714 1.18367347\n 1.2244898  1.26530612 1.30612245 1.34693878 1.3877551  1.42857143\n 1.46938776 1.51020408 1.55102041 1.59183673 1.63265306 1.67346939\n 1.71428571 1.75510204 1.79591837 1.83673469 1.87755102 1.91836735\n 1.95918367 2.        ]"]
;; <=

;; @@ [clj]
(with-show (matplotlib.pyplot/plot [[1 2 3 4 5] [1 2 3 4 10]] :label "linear"))
;; @@
;; =>
;;; ["^ ","~:type","~:html","~:content","<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAA10dzkAAAtT0lEQVR4Xu3deZBmZXU/cCkxEMsEQyIqEiCmiKZCWSZFJTEarYp/WD+xJJVKTBkSsUwlAUFBVBBBR1EWBVEUhp2ZAYZBlhl2GJbZ933f956N2ffpWc8vz5100+87W/c8vd2+n0/VqZl5+22rcjnp8+1733vPOwIAgEp5R/0LAAD0bAIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwACABQMQIgAEDFCIAAABUjAAIAVIwAmOHAgQPR0NAQW7Zsia1btyqllFKqBJXmdprfaY5XlQCYITXPO97xDqWUUkqVsNIcryoBMEP6DaKpgep/u1BKKaVU96ymEzhpjleVAJghNVFqoPQnAFAO5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3z04AA4fPjy+8IUvxAc/+MHiP/KgQYNqvn7w4MH4wQ9+EB/4wAfi1FNPjc9+9rOxYMGCmvccjwYCgPIxv3twAHz55Zfj+uuvj4EDBx4xAN56661x2mmnxbPPPhvTp0+PL37xi/Enf/InsXv37pr3HYsGAoDyMb97cABsqT4AprN/6czfbbfd1vxaWgh9yimnxIABA5pfOx4NBADlY35XNAAuXry4eG3q1Kkt3hXx6U9/Or75zW/WvNZSY2Nj0SxN1dDQUPkGAoD2tn/fgVgwcW0MvH1yrF3S/jNWAKxoABw9enTx2urVq1u8K+Jf/uVf4ktf+lLNay316tWr+L76qnIDAUB72b5pd4x7bnE8/N2Rcdf/vFnUG31n178tmwAoALZ41/EDoDOAANC+Dh44GCvmbIyX75kRd182pDn4pRCYwuC2ja3/bH5rCYAVDYAnegm4ngYCgBOze8femPbGinjsh2ObQ1+qdNk3Xf5Nl4E7ivld0QDYdBPI7bff3vxaagI3gQBAx1q3fFu8+cicuPeKoc2h774rh8Xwx+fFhlXb69/eIczvHhwAt2/fXpzhS5X+I99xxx3F35cvX158PT0G5r3vfW8899xzMWPGjLjooos8BgYAOsC+vftj7tjV8dStE2vO9g24cVzMHL4y9uzeV/8tHcr87sEBcOjQocV/3Pq65JJLiq83PQj6/e9/f3HmLz0Iev78+bX/I8ehgQDg6Las2xWjn14YD149ojn09f76kBj84KxYtXBzMYu7gvndgwNgZ9BAAFDrwIGDsXT6+nj+19PirkvfPtvX97pRMfHlpbFz6576b+l05rcAmEUDAcAhKdhNemVp9LtudM1l3ud/PTWW/G8gTMGwuzC/BcAsGgiAKkuXcFcv2hKvPTQrel/+9iNcHvjW8Bj11ILY/NbO+m/pFsxvATCLBgKgitJNG7NGrIwBPxlfc7bvyVsmxpzRq2Pfnv3139KtmN8CYBYNBECVbFy9I4Y/MT/uv3JYc+i754qh8Wa/OfHWsvLMQvNbAMyigQDo6fbvPxALJ70Vg+6YXHO279EbxsTU15cXD3QuG/NbAMyigQDoqbZvaozxzy+Oh695ey/v3Ze+GS/1nh4rZm8sVriVlfktAGbRQAD0JOmmjoa5G+OVe2v38j7UgXt5u4L5LQBm0UAA9ASNO7tuL29XML8FwCwaCIAyS3t5h6S9vN9osZf3m8NiWNrLu7Jz9vJ2BfNbAMyigQAom7SXd964NYft5X38x+Ni5rCGTt/L2xXMbwEwiwYCoCy2rt8Vo585wl7eB2bGqgVdt5e3K5jfAmAWDQRAd1bs5Z2xPl74Td1e3u+NiokvLY0dWxrrv6USzG8BMIsGAqA72rVtT0x+dVn0+37tXt7n7pwai6euiwP7e9ZNHW1lfguAWTQQAN1FuoS7ZvGWeO3hw/fyjkx7edd2z728XcH8FgCzaCAAutrexv3FXt4nflq3l/fmCTFn9KrY28338nYF81sAzKKBAOgqm9bsiBFpL+9Vw5tDX9rL+0bf2bF2qbl0LOa3AJhFAwHQmdJe3kWT017eKTVn+x65YUxMeW157N5evr28XcH8FgCzaCAAOsOOzY0x/oUl0aduL++Ld0+P5bM2lHovb1cwvwXALBoIgI5S7OWdtyleua9uL+93RsTYZxf1mL28XcH8FgCzaCAA2lvjrn0xfciK6N+rdi/vM7dNigUTet5e3q5gfguAWTQQAO1l3YptMeSxuYfv5e3fs/fydgXzWwDMooEAyLF/74FiL+/TP5tUc7av/4/GxYyhDbFnV8/fy9sVzG8BMIsGAuBEpL28YwYuige/3WIv72VD4tViL++mSu3l7QrmtwCYRQMB0FrpTt1lMzfEi3cdaS/vksru5e0K5rcAmEUDAXA8u7bvicmDl8Uj19ft5f3VFHt5u4j5LQBm0UAAHEnTXt7X+8yOey5/+6aOYi/vk/bydjXzWwDMooEAaCnt3Z09ctVhe3l/e9OEmD3KXt7uwvwWALNoIACStJd35G8X1O7lvXxovNFndqxdstVNHd2M+S0AZtFAANWVPru3aMpb8ewv6/byXj86pgy2l7c7M78FwCwaCKB60t26E15cEn2uHfV28Pu/vbzL7OUtBfNbAMyigQCqIV3CXTk/7eWdWTyvryn4pb28YwYtKp7rR3mY3wJgFg0E0LMd2svbUGzmaHmZ95mfT4r549cUmzwoH/NbAMyigQB6pvUN22No2sv7zWHNoS/9Pb22vmFb/dspGfNbAMyigQB6jnQ2L53VS2f3Wp7t699rbHEWMJ0NpGcwvwXALBoIoPy2bthVfI4vfZ6vKfSlz/mlz/utnGcvb09kfguAWTQQQDkVe3lnbSju3L27xV7edGdvusPXXt6ezfwWALNoIIBySc/mS8/oe+SGMTWXedOz/NIz/ezlrQbzWwDMooEAur90CTdt40hbOVru5U1bO9L2jrTFg2oxvwXALBoIoPsq9vKOWlXs4W15ti/t6S328jbay1tV5rcAmEUDAXQ/m9fujJFPLogHvlW7l/f1PrNjzZItburA/A4BMIsGAuge0mf3Fk9dF8/96vC9vJMHL4td2/fUfwsVZn4LgFk0EEDXSnfrTnxpSfT9Xt1e3rumxbKZ9vJyZOa3AJhFAwF0vnQJd9WCTfHqA7V7eR/89ogYM9BeXo7P/BYAs2gggM6zZ9e+mDG0IR7/ce1e3qd/NinmjbOXl9YzvwXALBoIoONtWLk9hvWfF/e13Mv7jaEx5LG5sW6Fvby0nfktAGbRQAAdY/++A7Fgwtp45rYj7eVdYS8vWcxvATCLBgJoX9s27o6xz9bu5b272Ms7Ixrs5aWdmN8CYBYNBJAv3am7/Eh7ea8ZGeNfWBLbN9nLS/syvwXALBoI4MTt3rE3pr6+PB6t28s76I4psWjyW7HfXl46iPktAGbRQABtt3bp1nij7+y454oWe3mvHBYjnpgfG1fby0vHM78FwCwaCKB19u3ZH3NGr4onbz58L++sESvt5aVTmd8CYBYNBHBsxV7ep2r38va+fEi89vCsWLPYXl66hvktAGbRQACHa97Le+fUmrN9/b4/Oia/uix2bbOXl65lfguAWTQQwNt2bt0TE19aethe3hd+My2WzlgfB+zlpZswvwXALBoIqLpDe3k3x+C0l/frLfbyXp328i60l5duyfwWALNoIKCq9uzeFzOHHWkv78RiL+++vW7qoPsyvwXALBoIqJpiL+/jR9jL++jcWLfcXl7KwfwWALNoIKAKir28E9fGwNsn15zte+yHY2Pamyuicefe+m+Bbs38FgCzaCCgJ0t7ecc9tzge+u7I5tBX7OW9d0Y0zN3oES6UlvktAGbRQEBPk/byrpi9MV7qXbuX9+G0l/f5xfby0iOY3wJgFg0E9BTNe3l/UL+Xd3IsnGQvLz2L+S0AZtFAQNm9tWxrvNlvTtxbt5d3eNrLu8peXnom81sAzKKBgDJKe3nnjlkdT94yseZs34AbD+3lTY94gZ7M/BYAs2ggoEy2rNsZo55eGA9cXbeX96FZsXqRvbxUh/ld4QC4f//+uOGGG+Lcc8+NU089NT784Q/HjTfe2KYfgBoI6O7S+rUl09fH87+u28t73eiY9MrSYn0bVI35XeEAeNNNN8Uf/uEfxosvvhhLly6Np556Kt7znvfEnXfeWf/Wo9JAQHeVgl0KeH2vq93L+/yvp8XS6fbyUm3md4UD4IUXXhhf+9rXal77p3/6p7j44otrXjsWDQR0J+kKxuqFm2Pwg7Nq9vKmS76jn15YXAIGzO+ksgEwnQE855xzYv78+cW/p02bFmeccUY89thjde98W2NjY9EsTdXQ0FD5BgK6XrGXd/jK4iaOlpd5n7p1Yswdu9peXqgjAFY4AB44cCCuvfbaOOmkk+Lkk08u/rz55pvr31ajV69eRcPUV5UbCOg6G1Ztj+FpL++VLfbyXjE03nxkTvF4F+DIBMAKB8ABAwbEWWedVfw5Y8aMeOSRR+L000+Pvn371r+1mTOAQFc75l7eN1YUD3QGjk0ArHAATOHvrrvuqnntJz/5SXzkIx+pee1YNBDQWbZvOrSX9+GWe3kvfTNevmdGrLCXF9rE/K5wAExn+3r37l3zWroEfN5559W8diwaCOhIKdStmLOxCHl3X/b2TR0pBI4r9vLurv8WoBXM7woHwEsuuSQ+9KEPNT8GZuDAgfFHf/RHcc0119S/9ag0ENAR0mXcdDk3XdZteZl30C/s5YX2YH5XOABu27Ytrrzyyjj77LObHwR9/fXXx549rX8oqgYC2tO65duKGzha7uVNN3gMHzC/uOEDaB/md4UDYHvQQECu9IiW9KiW9MiWlmf7Btw4rni0i7280P7MbwEwiwYCTtSWdbuKhzM/ePWI5tCXHt6cHuKcHubspg7oOOa3AJhFAwFtkdavpTVsaR1bWsvWFPzSujZ7eaHzmN8CYBYNBLRG017efteNrrnM+/yvp8YSe3mh05nfAmAWDQQcTbGXd9GWeO2hWdH78tq9vKOeXhib37KXF7qK+S0AZtFAQL1008asEStjwE9q9/I+ecvEmDtmdezbYy8vdDXzWwDMooGAJhtX74jhT8yP+1vs5b0n7eXtZy8vdDfmtwCYRQNBtaUHMqcHMw+6o3Yv76M/GBNTX19uLy90U+a3AJhFA0E1bd/UGOOfXxwPX1O7l/el3tNjxeyNcdBNHdCtmd8CYBYNBNWRbupomLsxXrm3di/vQ2kv73OLY9tGe3mhLMxvATCLBoKer3Hn3pj25uF7eQfePjkWTFwb+/fZywtlY34LgFk0EPRcaS/vkEfnxr3faLGX95vDYtjj82LDSnt5oczMbwEwiwaCniXt5Z03bs1he3kf//G4mDmswV5e6CHMbwEwiwaCnmHr+l0x+pkj7+VdZS8v9DjmtwCYRQNBeRV7eWesjxd+U7eX93ujYuJLS2PHlsb6bwF6CPNbAMyigaB8dm3bE5NfXRb9vl+3l/fOqbF46ro4sN9NHdDTmd8CYBYNBOWQLuGuWbwlXnu4bi/vt4bHqKcWxOa19vJClZjfAmAWDQTd297G/cVe3id+WreX9+YJMWe0vbxQVea3AJhFA0H3tGnNjhiR9vJeNbw59KW9vG/0mxNrl/r/V6g681sAzKKBoPtIe3kXTU57eafUnO179AZ7eYFa5rcAmEUDQdfbsbkxxr+wJPocYS/v8tkb7OUFDmN+C4BZNBB0jWIv77xN8cp9dXt5vzMixj67yF5e4JjMbwEwiwaCztW4a19MH7Ii+veq3cv7zG2TYsEEe3mB1jG/BcAsGgg6x/qGbTHksSPs5e1vLy/Qdua3AJhFA0HH2b/3QLGX9+mfTao525f28s4Y2hB7dtnLC5wY81sAzKKBoP2lvbxjBi6KB7/dYi/vZUPi1QdmxqoFm+zlBbKZ3wJgFg0E7SPdqbts5oZ48a4j7eVdYi8v0K7MbwEwiwaCPLu274nJg5fFI9fX7uV97ldT7OUFOoz5LQBm0UDQdsVe3iVb4vU+s+Oey9++qSPt5R35pL28QMczvwXALBoIWm/vnv0xe9Sq+O1NE2rO9qV/p9fT1wE6g/ktAGbRQHB8aS/vyN8uqN3Le/nQeKPP7Fi7ZKubOoBOZ34LgFk0EBxZ+uzeoilvxbO/rN3Lmz7rN2Xw8ti93V5eoOuY3wJgFg0EtdLduhNeXBJ9rh3VHPrSXt4X754ey2bZywt0D+a3AJhFA8GhmzpWzk97eWcWz+trCn7FXt5Bi2Lrhl313wLQpcxvATCLBqLKDu3lbYj+PxpXc5k37eWdP2FNsckDoDsyvwXALBqIKlrfsD2Gpr283xzWHPrS34f2n1d8DaC7M78FwCwaiKpIZ/Pmj18Tz/y8di9vOvtnLy9QNua3AJhFA9HTpc/vjRm0qPg8X1PoK/by3j+z+NyfR7gAZWR+C4BZNBA9UbGXd9aG4s7ddAdvU/BLd/amO3zt5QXKzvwWALNoIHqS9Gy+9Iy+R24YU3OZNz3Lb/EUe3mBnsP8FgCzaCDKLl3CTds40laOlnt509aOtL0jbfEA6GnMbwEwiwairI62l/eJn44/tJe30V5eoOcyvwXALBqIstm8dmeMfHJBPPCt2r28r/eZHWuWbHFTB1AJ5rcAmEUDUQbps3uLp66L5351+F7eyYOXxa7te+q/BaBHM78FwCwaiO4s3a078aUl0fd7b+/lvSvt5b1rWiybaS8vUF3mtwCYRQPR3aRLuKsWbIpXH6jdy/vgt0fEmIGLYut6e3kBzG8BMIsGortImzjSRo7Hf1y7l/fpn02KeePs5QVoyfwWALNoILrahpXbY1j/eXFf3V7eIY/NjXUrttW/HYAwvxMBMIMGoivs33cgFkxYG8/cVreXt9fYmD6kIRrt5QU4JvNbAMyigehM2zbujrHP1u7lvfuyIfHKfTOiYZ69vACtZX4LgFk0EB0t3am7/Eh7ea8ZGeNfWBI7NtvLC9BW5rcAmEUD0VF279gbU19fHo8eYS/voilvxX57eQFOmPktAGbRQLS3tUu3xht9Z8c9V9Tu5R3x2/n28gK0E/NbAMyigWgP+/bsjzmjV8WTNx9hL+9Ie3kB2pv5LQBm0UDk2PzWzhj5VO1e3t6XD4nXH54daxbbywvQUcxvATCLBqKtmvfy3jm15mxfv++PjsmvLotd2+zlBeho5rcAmEUD0Vo7t+6JiS8tPWwv7wt3TYulM9bHAXt5ATqN+S0AZtFAHMuhvbybY3Day/v1+r28C+3lBegi5rcAmEUDcSR7du+LmcOOtJd3YrGXd99eN3UAdCXzWwDMooFoqdjL+3jdXt5vDI0hj86Ndcvt5QXoLsxvATCLBqLYyztxbQy8fXLN2b7Hfjg2pr25Ihp37q3/FgC6mPktAGbRQNWV9vKOe25xPPTdkc2hr9jLe++MaJi70SNcALox81sAzKKBqiXt5V0xe2O81Lt2L+/DaS/v84tj+yZ7eQHKwPwWALNooGpo3sv7g9q9vIPumBwLJ9nLC1A25nfFA+DKlSvj4osvjtNPPz1OPfXUOP/882PixIn1bzsqDdSzvbVsa7zZb07c23Iv75XDYvgT82Pjant5AcrK/K5wANy0aVOcc8458dWvfjXGjx8fS5YsicGDB8eiRYvq33pUGqjnSXt5545ZHU/eMrHmbN+An4yPWSNWFo94AaDczO8KB8Brr702PvWpT9W/3CYaqOfYsm5njHp6YTxwde1e3tcemhWrF9nLC9CTmN8VDoB//ud/HldddVX88z//c7zvfe+Lj3/843H//ffXv+2YNFC5pfVrS6avj+d/XbeX9zp7eQF6MvO7wgHwlFNOKeq6666LKVOmxH333Vd8DrBv3771b23W2NhYNEtTNTQ0VL6Byijt5Z30ytLoe13dXt7f2MsLUAUCYIUD4Lve9a74xCc+UfPaN77xjfjbv/3bmtda6tWrV9Ew9VXlBiqLdAl39cLNMfjBWbV7ea8eEaOfWRhb1tnLC1AVAmCFA+DZZ58d//mf/1nzWu/evePMM8+sea0lZwDLp9jLO3xlDLhxfM1l3qdunRjzxq62lxegggTACgfAL3/5y4fdBJI+E1h/VvBYNFD3tWHV9hie9vJe2WIv7xVDY8gjc+zlBag487vCAXDChAlx8sknx0033RQLFy6M/v37x7vf/e547LHH6t96VBqoe0kPZE4PZh70iyPs5X1jRfFAZwAwvyscAJMXXnihePhzuhnkox/9qLuAS2r7pkN7eR+u28v78r0zYoW9vADUMb8rHgBzaaCuk0Ldijkb4+V7ZhRhryn4pRA4rtjLu7v+WwCgYH4LgFk0UOdLl3HT5dx0WbflZd502ddeXgBaw/wWALNooM6Tbtx485HavbzpBo/hA+bHxlX28gLQeua3AJhFA3Ws9IiWuWNXF49saXm2Lz3SJT3axV5eAE6E+S0AZtFAHSM9lHn00wuLhzQ3hb708Ob0EOf0MGc3dQCQw/wWALNooPaT1q8tLfbyTivWsjUFv7SuLa1tS+vbAKA9mN8CYBYNlK9pL2+/60bXXOZ9/tdTY8l0e3kBaH/mtwCYRQOdmGIv76It8dpDs6L35W8/wuWBq4fHqKfTXt6d9d8CAO3G/BYAs2igtkk3bcwasTIG/KR2L++Tt0yMuWNWx7499vIC0PHMbwEwiwZqnY2rd8TwJ+bH/S328t5zxdB4s9+ceGuZYwdA5zK/BcAsGujomvfy3lG7l/fRH4yJqa8vt5cXgC5jfguAWTTQ4bZvaozxzy+Oh69psZf30jfjpd7TY8XsjXHQTR0AdDHzWwDMooEOSTd1NMzdGK/cW7uX96G0l/e5xbFto728AHQf5rcAmKXqDdS4c29Me/PwvbwDb58cCyaujf377OUFoPup+vxOBMAMVW2gtJd3yKNz495v1O3lfXxebFi1vf7tANCtVHV+tyQAZqhSA6W9vPPGrTlsL+/jPx5nLy8ApVKl+X00AmCGKjTQ1vW7YszAhfHgtw/fy7vKXl4ASqgK8/t4BMAMPbWBir28M9bHC3fV7eX93qiY+LK9vACUW0+d320hAGboaQ20a9uemPzqsuj3/bq9vHdOjSXT1sWB/W7qAKD8etr8PhECYIae0EDpEu6axVvitYfr9vJ+a3iMempBbH7LXl4AepaeML9zCYAZytxAexv3F3t5n/hp3V7emyfEnNH28gLQc5V5frcXATBDGRto05odMSLt5b1qeHPoS3t53+g3J9YuLc//HQBwoso4v9ubAJihLA2U9vIumpz28k6pOdv36A328gJQPWWZ3x1JAMzQ3Rtox+bGGP/CkuhzhL28y2dvsJcXgErq7vO7MwiAGbpjAxV7eedtilfuq9vL+50RMfbZRfbyAlB53XF+dzYBMEN3aqDGXfti+pAV0b9X7V7eZ26bFAsm2MsLAE260/zuKgJghu7QQOsbtsWQx+r28n5zWAzrPy82rLSXFwDqdYf53dUEwAxd1UD79x4o9vI+/bNJNWf70l7eGUMbYs8ue3kB4Gi6an53JwJghs5uoEN7eRfV7uW9bEgMfmBmrFqwyV5eAGiFzp7f3ZEAmKEzGijdqbts5oZ48Uh7eV9aGju2NNZ/CwBwDJ0xv7s7ATBDRzbQru17YvLgZfHI9bV7eZ/71ZRYPNVeXgA4UR05v8tCAMzQUQ2Unt13z+Vv39SR9vKOTHt519rLCwC5Omp+l4kAmKGjGmjm8JVF8PvtTWkv76rYay8vALSbjprfZSIAZuioBtqze5+9vADQQTpqfpeJAJhBAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0ANrvllluKZrjyyivrv3RUGggAysf8FgALEyZMiHPPPTc+9rGPCYAA0MOZ3wJgbN++Pc4777x4/fXX4zOf+Uy3CIAHDx6MAzt3KqWUUpWvNBPbW0fN7zKpfAD8yle+EldddVXx9+MFwMbGxqJZmqqhoaFDGig1/JyPfFQppZSqfKWZ2N4EwIoHwAEDBsT5558fu3fvLv59vADYq1evomHqq70bSABUSimlDpUA2DEqGwBXrFgRZ5xxRkyfPr35teMFwM46A+gSsFJKKXWoXALuGJUNgIMGDSr+47/zne9srvTvk046qfj7/v3767/lMBoIAMrH/K5wANy2bVvMnDmzpi644IL493//9+LvraGBAKB8zO8KB8AjOd4l4HoaCADKx/wWAGsIgADQ85nfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZumoBjp48GDs3LtTKaWUqnylmdjeOmp+l4kAmKGjGig1/Pl9z1dKKaUqX2kmtreOmt9lIgBm6KgGEgCVUkqpQyUAdgwBMENHNZBLwEoppdShcgm4YwiAGTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfFQ+AN998c1xwwQXxnve8J973vvfFRRddFPPmzat/21FpIAAoH/O74gHwc5/7XPTp0ydmzZoV06ZNi89//vNx9tlnx44dO+rfekQaCADKx/yueACst27duqIhhg8fXv+lI+qwBjp4MGLPDqWUUkqlmdjOOmx+l4gA2MLChQuLhpg5c2b9lwqNjY1FszRVQ0NDxzRQavhev6+UUkqpNBPbmQAoADY7cOBAXHjhhfHJT36y/kvNevXqVTRMfbV7AwmASiml1KESADuEAPh/Lr300jjnnHOKs3pH02lnAF0CVkoppQ6VS8AdQgD8X5dffnmcddZZsWTJkvovHZMGAoDyMb8rHgAP/u9vFSn8nXnmmbFgwYL6Lx+XBgKA8jG/Kx4AL7vssjjttNNi2LBhsWbNmubatWtX/VuPSAMBQPmY3xUPgPU3czRVejZga2ggACgf87viATCXBgKA8jG/BcAsGggAysf8FgCzaCAAKB/zWwDMooEAoHzMbwEwiwYCgPIxvwXALBoIAMrH/BYAs2ggACgf81sAzKKBAKB8zG8BMIsGAoDyMb8FwCwaCADKx/wWALNoIAAoH/NbAMyigQCgfMxvATCLBgKA8jG/BcAsGggAysf8FgCzaCAAKB/zWwDMooEAoHzMbwEwiwYCgPIxvwXALBoIAMrH/BYAs2ggACgf81sAzKKBAKB8zG8BMIsGAoDyMb8FwCwaCADKx/wWALNoIAAoH/NbAMyigQCgfMxvATCLBgKA8jG/BcAsGggAysf8FgCzaCAAKB/zWwDMooEAoHzMbwEwiwYCgPIxvwXALB3VQAcPHoyde/YppZRSla80E9tbR83vMhEAM3RUA6WGP+faF5VSSqnKV5qJ7a2j5neZCIAZOqqBBECllFLqUAmAHUMAzNBRDeQSsFJKKXWoXALuGAJgBg0EAOVjfguAWTQQAJSP+S0AZtFAAFA+5rcAmEUDAUD5mN8CYBYNBADlY34LgFk0EACUj/ktAGbRQABQPua3AJhFAwFA+ZjfAmAWDQQA5WN+C4BZNBAAlI/5LQBm0UAAUD7mtwCYRQMBQPmY3wJgFg0EAOVjfguAWTQQAJSP+S0AZtmyZUvRQA0NDUUTKaWUUqr7V5rbaX6nOV5VAmCGpgZSSimlVPkqzfGqEgAzHDhwoGie9BtE/W8XudUULp1d7NhynDunHOfOKce5c8px7pzqyOOc5nb6301zvKoEwG4qNWhq/PQnHcdx7hyOc+dwnDuH49w5HOeOJQB2Uxq/czjOncNx7hyOc+dwnDuH49yxBMBuSuN3Dse5czjOncNx7hyOc+dwnDuWANhNNTY2Rq9evYo/6TiOc+dwnDuH49w5HOfO4Th3LAEQAKBiBEAAgIoRAAEAKkYABACoGAEQAKBiBMAuctddd8U555wTp5xySvz1X/91jB8/vv4tNZ588sn4yEc+Urz//PPPj5deeqn+LRxFW471/fffH5/61Kfive99b1Gf/exnj/l+3taW49zSgAEDikc9XHTRRfVf4gjaepw3b94cX//61+MDH/hA/M7v/E6cd955fn60QluP8y9/+cv4sz/7szj11FPjrLPOiquuuip2795d/zZaGD58eHzhC1+ID37wg8XPgEGDBtW/5TBDhw6Nv/zLvyx6+U//9E+jT58+9W+hlQTALvDEE08Uzfvwww/H7Nmz47/+67+KsPHWW2/Vv7UwevToeOc73xk///nPY86cOXHDDTfEu971rpg5c2b9W6nT1mP9b//2b3H33XfH1KlTY+7cufHVr341TjvttFi5cmX9W2mhrce5ydKlS+NDH/pQ/P3f/70A2AptPc579uyJCy64ID7/+c/HqFGjiuM9bNiwmDZtWv1baaGtx7l///5FUEx/pmM8ePDgItR861vfqn8rLbz88stx/fXXx8CBA1sVAJcsWRLvfve74+qrry5m4W9+85tiNr766qv1b6UVBMAukH6bvPzyy5v/nXYRnnnmmXHLLbe0eNfbvvSlL8WFF15Y89rf/M3fxP/8z//UvMbh2nqs6+3fvz9+7/d+L/r161f/JVo4keOcju3f/d3fxYMPPhiXXHKJANgKbT3O99xzT3z4wx+OvXv31n+JY2jrcU7v/Yd/+Iea11JI+eQnP1nzGkfXmgB4zTXXxF/8xV/UvPav//qv8bnPfa7mNVpHAOxk6Tfy9BtLfaN/5StfiS9+8Ys1rzX54z/+4+LyQks//OEP42Mf+1jNa9Q6kWNdb9u2bcUlnRdeeKH+S/yfEz3OqYf/8R//sfi7AHh8J3Kc/9//+39x8cUXF2ewzjjjjGJ43nTTTUX45shO5DinM3/pSkHTZeLFixfHRz/60eJY0zqtCYDpSsGVV15Z81o6S/v7v//7Na/ROgJgJ1u1alXR6GPGjKl5/bvf/W7xW+eRpMu9jz/+eM1r6TJl+oHO0Z3Isa532WWXFWdQfJbn6E7kOI8cObK49Lt+/fri3wLg8Z3IcW763PDXvva1mDRpUnFp8/TTT48f/ehH9W/l/5zIcU7uvPPO4mf1ySefXHz/pZdeWv8WjqE1ATB9fvXmm2+ueS19njV9765du2pe5/gEwE52Ij9cBMATcyLHuqV0uecP/uAPYvr06fVfooW2Hud0VvXcc88tPv/TRAA8vrYe5yQNzHQFoeUZv1/84hfFDSEc2Ykc53Rjwvvf//544IEHYsaMGcVn2tJxv/HGG+vfylEIgJ1PAOxkJ3J5wSXgE3Mix7rJbbfdVlzSmThxYv2XqNPW45xusEk/sNP3NNVJJ51UVPr7okWL6r+FaPtxTj796U8Xd7K3lIJ3Ov7pf4/DnchxTk8O+M53vlPz2qOPPhq/+7u/W3x+kONrTQB0Cbh9CYBdIP0WecUVVzT/O/2ASJfDjvYB43QTSLpVvqVPfOITbgJphbYe6+RnP/tZ8QNl7Nix9V/iKNpynNPl9HQHe8tKZ//Sh+jT3wWTo2vLcU6uu+664lEmLUPIr371q+IOVY6urcf5r/7qr4obFFpKV21SAPR5y9ZpTQBMxzg9Bq2lL3/5y24COUECYBdIn8NJn8vp27dvcSv7f//3fxePGFi7dm3x9f/4j/+I733ve83vT4+BSZ8ruf3224tHk/Tq1ctjYFqprcf61ltvLR7/8PTTT8eaNWuaa/v27c3v4XBtPc71XAJunbYe5xUrVhR3sacwM3/+/HjxxReLj4789Kc/bX4Ph2vrcU4/k9NxTs+0TI8qee2114pn1KVf3jm69HM1XRFouipwxx13FH9fvnx58fV0jNOxbtL0GJh0OT7NwvRRKI+BOXECYBdJzy86++yzi7CRftscN25c89c+85nPFAOxpfQg6PSQ0fT+dCefB7m2XluOdTpbkn4Q1Vf6Ac+xteU41xMAW6+txzl9li09NioFmnRDk7uAW6ctx3nfvn3FjTUp9KWnBqSP7aSHb6eHcHN06bOT9T9rUzUd2/RnOtb13/Pxj3+8+O+S+tmDoE+cAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFSMAAgAUDECIABAxQiAAAAVIwACAFTM/wd9XSFXn22o4AAAAABJRU5ErkJggg==\" width=\"640\" height=\"480\" alt=\"\" />","~:value","#object[java.awt.image.BufferedImage 0x4aa4adae \"BufferedImage@4aa4adae: type = 2 DirectColorModel: rmask=ff0000 gmask=ff00 bmask=ff amask=ff000000 IntegerInterleavedRaster: width = 640 height = 480 #Bands = 4 xOff = 0 yOff = 0 dataOffset[0] 0\"]"]
;; <=

;; @@ [clj]
^:R [:p/frisk (datafy-module numpy/linspace)]
;; @@
;; =>
;;; ["^ ","~:type","~:reagent","~:content",["^ ","~:hiccup",["~#with-meta",[["~:p/frisk",["^ ","__eq__",["^ ","~:args",["self"],"~:varkw","kwargs","~:name","__eq__","~:varargs","args","^0","~:method-wrapper","~:kwonlydefaults",null,"~:defaults",null,"~:kwonlyargs",[],"~:str","<method-wrapper '__eq__' of function object at 0x7fa3d573b950>","~:annotations",["^ "],"~:arglists",[["~$self","~$&",["~$args",["^ ","~:as","~$kwargs"]]]],"~:flags",["~#set",["~:callable?"]],"~:doc","Return self==value."],"__globals__",["^ ","^0","~:dict","^I","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^?","{'implementation': <function linspace at 0x7fa3d573b7a0>, 'dispatcher': <function _linspace_dispatcher at 0x7fa3d5735d40>, 'functools': <module 'functools' from '/usr/lib64/python3.7/functools.py'>, 'implement_array_function': <built-in function implement_array_function>, '__builtins__': {'__name__': 'builtins', '__doc__': \"Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.\", '__package__': '', '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': ModuleSpec(name='builtins', loader=<class '_frozen_importlib.BuiltinImporter'>), '__build_class__': <built-in function __build_class__>, '__import__': <built-in function __import__>, 'abs': <built-in function abs>, 'all': <built-in function all>, 'any': <built-in function any>, 'ascii': <built-in function ascii>, 'bin': <built-in function bin>, 'breakpoint': <built-in function breakpoint>, 'callable': <built-in function callable>, 'chr': <built-in function chr>, 'compile': <built-in function compile>, 'delattr': <built-in function delattr>, 'dir': <built-in function dir>, 'divmod': <built-in function divmod>, 'eval': <built-in function eval>, 'exec': <built-in function exec>, 'format': <built-in function format>, 'getattr': <built-in function getattr>, 'globals': <built-in function globals>, 'hasattr': <built-in function hasattr>, 'hash': <built-in function hash>, 'hex': <built-in function hex>, 'id': <built-in function id>, 'input': <built-in function input>, 'isinstance': <built-in function isinstance>, 'issubclass': <built-in function issubclass>, 'iter': <built-in function iter>, 'len': <built-in function len>, 'locals': <built-in function locals>, 'max': <built-in function max>, 'min': <built-in function min>, 'next': <built-in function next>, 'oct': <built-in function oct>, 'ord': <built-in function ord>, 'pow': <built-in function pow>, 'print': <built-in function print>, 'repr': <built-in function repr>, 'round': <built-in function round>, 'setattr': <built-in function setattr>, 'sorted': <built-in function sorted>, 'sum': <built-in function sum>, 'vars': <built-in function vars>, 'None': None, 'Ellipsis': Ellipsis, 'NotImplemented': NotImplemented, 'False': False, 'True': True, 'bool': <class 'bool'>, 'memoryview': <class 'memoryview'>, 'bytearray': <class 'bytearray'>, 'bytes': <class 'bytes'>, 'classmethod': <class 'classmethod'>, 'complex': <class 'complex'>, 'dict': <class 'dict'>, 'enumerate': <class 'enumerate'>, 'filter': <class 'filter'>, 'float': <class 'float'>, 'frozenset': <class 'frozenset'>, 'property': <class 'property'>, 'int': <class 'int'>, 'list': <class 'list'>, 'map': <class 'map'>, 'object': <class 'object'>, 'range': <class 'range'>, 'reversed': <class 'reversed'>, 'set': <class 'set'>, 'slice': <class 'slice'>, 'staticmethod': <class 'staticmethod'>, 'str': <class 'str'>, 'super': <class 'super'>, 'tuple': <class 'tuple'>, 'type': <class 'type'>, 'zip': <class 'zip'>, '__debug__': True, 'BaseException': <class 'BaseException'>, 'Exception': <class 'Exception'>, 'TypeError': <class 'TypeError'>, 'StopAsyncIteration': <class 'StopAsyncIteration'>, 'StopIteration': <class 'StopIteration'>, 'GeneratorExit': <class 'GeneratorExit'>, 'SystemExit': <class 'SystemExit'>, 'KeyboardInterrupt': <class 'KeyboardInterrupt'>, 'ImportError': <class 'ImportError'>, 'ModuleNotFoundError': <class 'ModuleNotFoundError'>, 'OSError': <class 'OSError'>, 'EnvironmentError': <class 'OSError'>, 'IOError': <class 'OSError'>, 'EOFError': <class 'EOFError'>, 'RuntimeError': <class 'RuntimeError'>, 'RecursionError': <class 'RecursionError'>, 'NotImplementedError': <class 'NotImplementedError'>, 'NameError': <class 'NameError'>, 'UnboundLocalError': <class 'UnboundLocalError'>, 'AttributeError': <class 'AttributeError'>, 'SyntaxError': <class 'SyntaxError'>, 'IndentationError': <class 'IndentationError'>, 'TabError': <class 'TabError'>, 'LookupError': <class 'LookupError'>, 'IndexError': <class 'IndexError'>, 'KeyError': <class 'KeyError'>, 'ValueError': <class 'ValueError'>, 'UnicodeError': <class 'UnicodeError'>, 'UnicodeEncodeError': <class 'UnicodeEncodeError'>, 'UnicodeDecodeError': <class 'UnicodeDecodeError'>, 'UnicodeTranslateError': <class 'UnicodeTranslateError'>, 'AssertionError': <class 'AssertionError'>, 'ArithmeticError': <class 'ArithmeticError'>, 'FloatingPointError': <class 'FloatingPointError'>, 'OverflowError': <class 'OverflowError'>, 'ZeroDivisionError': <class 'ZeroDivisionError'>, 'SystemError': <class 'SystemError'>, 'ReferenceError': <class 'ReferenceError'>, 'MemoryError': <class 'MemoryError'>, 'BufferError': <class 'BufferError'>, 'Warning': <class 'Warning'>, 'UserWarning': <class 'UserWarning'>, 'DeprecationWarning': <class 'DeprecationWarning'>, 'PendingDeprecationWarning': <class 'PendingDeprecationWarning'>, 'SyntaxWarning': <class 'SyntaxWarning'>, 'RuntimeWarning': <class 'RuntimeWarning'>, 'FutureWarning': <class 'FutureWarning'>, 'ImportWarning': <class 'ImportWarning'>, 'UnicodeWarning': <class 'UnicodeWarning'>, 'BytesWarning': <class 'BytesWarning'>, 'ResourceWarning': <class 'ResourceWarning'>, 'ConnectionError': <class 'ConnectionError'>, 'BlockingIOError': <class 'BlockingIOError'>, 'BrokenPipeError': <class 'BrokenPipeError'>, 'ChildProcessError': <class 'ChildProcessError'>, 'ConnectionAbortedError': <class 'ConnectionAbortedError'>, 'ConnectionRefusedError': <class 'ConnectionRefusedError'>, 'ConnectionResetError': <class 'ConnectionResetError'>, 'FileExistsError': <class 'FileExistsError'>, 'FileNotFoundError': <class 'FileNotFoundError'>, 'IsADirectoryError': <class 'IsADirectoryError'>, 'NotADirectoryError': <class 'NotADirectoryError'>, 'InterruptedError': <class 'InterruptedError'>, 'PermissionError': <class 'PermissionError'>, 'ProcessLookupError': <class 'ProcessLookupError'>, 'TimeoutError': <class 'TimeoutError'>, 'open': <built-in function open>, 'quit': Use quit() or Ctrl-D (i.e. EOF) to exit, 'exit': Use exit() or Ctrl-D (i.e. EOF) to exit, 'copyright': Copyright (c) 2001-2019 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved., 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information., 'license': See https://www.python.org/psf/license/, 'help': Type help() for interactive help, or help(object) for help about object.}, 'linspace': <function linspace at 0x7fa3d573b950>}","^F",["^G",[]]],"__lt__",["^ ","^7",["self"],"^8","kwargs","^9","__lt__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__lt__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self<value."],"__call__",["^ ","^7",["self"],"^8","kwargs","^9","__call__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__call__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Call self as a function."],"__reduce__",["^ ","^7",["self"],"^8",null,"^9","__reduce__","^:",null,"^0","~:builtin-function-or-method","^<",null,"^=",null,"~:module",null,"^>",[],"^?","<built-in method __reduce__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B"]],"^F",["^G",["~:fn?","~:method?","^H"]],"^I","Helper for pickle."],"__setattr__",["^ ","^7",["self"],"^8","kwargs","^9","__setattr__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__setattr__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Implement setattr(self, name, value)."],"__ge__",["^ ","^7",["self"],"^8","kwargs","^9","__ge__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__ge__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self>=value."],"__str__",["^ ","^7",["self"],"^8","kwargs","^9","__str__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__str__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return str(self)."],"^9","linspace","__getattribute__",["^ ","^7",["self"],"^8","kwargs","^9","__getattribute__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__getattribute__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return getattr(self, name)."],"__ne__",["^ ","^7",["self"],"^8","kwargs","^9","__ne__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__ne__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self!=value."],"__hash__",["^ ","^7",["self"],"^8","kwargs","^9","__hash__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__hash__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return hash(self)."],"_implementation",["^ ","^7",["start","stop","num","endpoint","retstep","dtype","axis"],"^8",null,"^9","_implementation","^:",null,"^0","~:function","^<",null,"^=",[50,true,false,null,0],"^P","numpy.core.function_base","^>",[],"^?","<function linspace at 0x7fa3d573b7a0>","^@",["^ "],"^A",[["~$start","~$stop","~$&",[["^ ","~$num","~:num","~$endpoint","~:endpoint","~$retstep","~:retstep","~$dtype","~:dtype","~$axis","~:axis","~:or",["^ ","^11",50,"^13",true,"^15",false,"^17",null,"^19",0]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^17","^18","^1;",["^ ","^11",50,"^13",true,"^15",false,"^17",null]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^1;",["^ ","^11",50,"^13",true,"^15",false]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^1;",["^ ","^11",50,"^13",true]]]],["^[","^10","~$&",[["^ ","^11","^12","^1;",["^ ","^11",50]]]],["^[","^10"]],"^F",["^G",["^Q","^H"]],"^I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    "],"__code__",["^ ","^0","~:code","^I","code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,\n      constants, names, varnames, filename, name, firstlineno,\n      lnotab[, freevars[, cellvars]])\n\nCreate a code object.  Not for the faint of heart.","^?","<code object linspace at 0x7fa3d573b810, file \"<__array_function__ internals>\", line 2>","^F",["^G",[]]],"__annotations__",["^ ","^0","^K","^I","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^?","{}","^F",["^G",[]]],"__wrapped__",["^ ","^7",["start","stop","num","endpoint","retstep","dtype","axis"],"^8",null,"^9","__wrapped__","^:",null,"^0","^Z","^<",null,"^=",[50,true,false,null,0],"^P","numpy.core.function_base","^>",[],"^?","<function linspace at 0x7fa3d573b7a0>","^@",["^ "],"^A",[["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^17","^18","^19","^1:","^1;",["^ ","^11",50,"^13",true,"^15",false,"^17",null,"^19",0]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^17","^18","^1;",["^ ","^11",50,"^13",true,"^15",false,"^17",null]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^1;",["^ ","^11",50,"^13",true,"^15",false]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^1;",["^ ","^11",50,"^13",true]]]],["^[","^10","~$&",[["^ ","^11","^12","^1;",["^ ","^11",50]]]],["^[","^10"]],"^F",["^G",["^Q","^H"]],"^I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    "],"__sizeof__",["^ ","^7",["self"],"^8",null,"^9","__sizeof__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __sizeof__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B"]],"^F",["^G",["^Q","^R","^H"]],"^I","Size of object in memory, in bytes."],"^0","^Z","__le__",["^ ","^7",["self"],"^8","kwargs","^9","__le__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__le__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self<=value."],"__gt__",["^ ","^7",["self"],"^8","kwargs","^9","__gt__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__gt__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self>value."],"__reduce_ex__",["^ ","^7",["self","protocol"],"^8",null,"^9","__reduce_ex__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __reduce_ex__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$protocol"]],"^F",["^G",["^Q","^R","^H"]],"^I","Helper for pickle."],"__dir__",["^ ","^7",["self"],"^8",null,"^9","__dir__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __dir__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B"]],"^F",["^G",["^Q","^R","^H"]],"^I","Default dir() implementation."],"^P","numpy","__repr__",["^ ","^7",["self"],"^8","kwargs","^9","__repr__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__repr__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return repr(self)."],"__dict__",["^ ","^0","^K","^I","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^?","{'__wrapped__': <function linspace at 0x7fa3d573b7a0>, '_implementation': <function linspace at 0x7fa3d573b7a0>}","^F",["^G",[]]],"__module__",["^ ","^0","^?","^I","","^?","numpy","^F",["^G",[]],"~:value","numpy"],"__init_subclass__",["^ ","^7",["self"],"^8","kwargs","^9","__init_subclass__","^:","args","^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __init_subclass__ of type object at 0x7fa3ea2d7700>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^Q","^R","^H"]],"^I","This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n"],"__qualname__",["^ ","^0","^?","^I","","^?","linspace","^F",["^G",[]],"^1I","linspace"],"^?","<function linspace at 0x7fa3d573b950>","__subclasshook__",["^ ","^7",["self"],"^8","kwargs","^9","__subclasshook__","^:","args","^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __subclasshook__ of type object at 0x7fa3ea2d7700>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^Q","^R","^H"]],"^I","Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n"],"__new__",["^ ","^7",["type"],"^8","kwargs","^9","__new__","^:","args","^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __new__ of type object at 0x7fa3ea2d7700>","^@",["^ "],"^A",[["~$type","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^Q","^R","^H"]],"^I","Create and return a new object.  See help(type) for accurate signature."],"__doc__",["^ ","^0","^?","^I","","^?","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    ","^F",["^G",[]],"^1I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    "],"^F",["^G",["^Q","^H"]],"^I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    ","__format__",["^ ","^7",["self","format_spec"],"^8",null,"^9","__format__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __format__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$format_spec"]],"^F",["^G",["^Q","^R","^H"]],"^I","Default object formatter."],"__delattr__",["^ ","^7",["self"],"^8","kwargs","^9","__delattr__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__delattr__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Implement delattr(self, name)."],"__name__",["^ ","^0","^?","^I","","^?","linspace","^F",["^G",[]],"^1I","linspace"],"__init__",["^ ","^7",["self"],"^8","kwargs","^9","__init__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__init__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Initialize self.  See help(type(self)) for accurate signature."],"__class__",["^ ","^7",["self"],"^8","kwargs","^9","__class__","^:","args","^0","^0","^<",null,"^=",null,"^P","builtins","^>",[],"^?","builtins.function","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["~:pyclass?","^H"]],"^I","Create a function object.\n\n  code\n    a code object\n  globals\n    the globals dictionary\n  name\n    a string that overrides the name from the code object\n  argdefs\n    a tuple that specifies the default argument values\n  closure\n    a tuple that supplies the bindings for free variables"],"__get__",["^ ","^7",["self"],"^8","kwargs","^9","__get__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__get__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return an attribute of instance, which is of type owner."]]],["^ ","~:R",true]]],"~:map-keywords",true,"~:widget",true]]
;; <=

;; @@ [clj]
(defn convert [item] 
  (if (map? item)
      (select-keys item [:name :doc :type])
      {}
    ))
;; @@
;; =>
;;; ["^ ","~:type","~:html","~:content",["~:span",["^ ","~:class","clj-var"],"#'datafy-demo/convert"],"~:value","#'datafy-demo/convert"]
;; <=

;; @@ [clj]
^:R [:p/pydoc (map convert  (vals (datafy numpy)))]
;; @@
;; =>
;;; ["^ ","~:type","~:reagent","~:content",["^ ","~:hiccup",["~#with-meta",[["~:p/pydoc",["~#list",[["^ ","~:name","result_type","~:doc","\n    result_type(*arrays_and_dtypes)\n\n    Returns the type that results from applying the NumPy\n    type promotion rules to the arguments.\n\n    Type promotion in NumPy works similarly to the rules in languages\n    like C++, with some slight differences.  When both scalars and\n    arrays are used, the array's type takes precedence and the actual value\n    of the scalar is taken into account.\n\n    For example, calculating 3*a, where a is an array of 32-bit floats,\n    intuitively should result in a 32-bit float output.  If the 3 is a\n    32-bit integer, the NumPy rules indicate it can't convert losslessly\n    into a 32-bit float, so a 64-bit float should be the result type.\n    By examining the value of the constant, '3', we see that it fits in\n    an 8-bit integer, which can be cast losslessly into the 32-bit float.\n\n    Parameters\n    ----------\n    arrays_and_dtypes : list of arrays and dtypes\n        The operands of some operation whose result type is needed.\n\n    Returns\n    -------\n    out : dtype\n        The result type.\n\n    See also\n    --------\n    dtype, promote_types, min_scalar_type, can_cast\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The specific algorithm used is as follows.\n\n    Categories are determined by first checking which of boolean,\n    integer (int/uint), or floating point (float/complex) the maximum\n    kind of all the arrays and the scalars are.\n\n    If there are only scalars or the maximum category of the scalars\n    is higher than the maximum category of the arrays,\n    the data types are combined with :func:`promote_types`\n    to produce the return value.\n\n    Otherwise, `min_scalar_type` is called on each array, and\n    the resulting data types are all combined with :func:`promote_types`\n    to produce the return value.\n\n    The set of int values is not a subset of the uint values for types\n    with the same number of bits, something not reflected in\n    :func:`min_scalar_type`, but handled as a special case in `result_type`.\n\n    Examples\n    --------\n    >>> np.result_type(3, np.arange(7, dtype='i1'))\n    dtype('int8')\n\n    >>> np.result_type('i4', 'c8')\n    dtype('complex128')\n\n    >>> np.result_type(3.0, -2)\n    dtype('float64')\n\n    ","^0","~:function"],["^ ","^7","float","^8","Convert a string or number to a floating point number, if possible.","^0","^0"],["^ ","^7","ravel_multi_index","^8","\n    ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.\n\n    Parameters\n    ----------\n    multi_index : tuple of array_like\n        A tuple of integer arrays, one array for each dimension.\n    dims : tuple of ints\n        The shape of array into which the indices from ``multi_index`` apply.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead.\n    order : {'C', 'F'}, optional\n        Determines whether the multi-index should be viewed as\n        indexing in row-major (C-style) or column-major\n        (Fortran-style) order.\n\n    Returns\n    -------\n    raveled_indices : ndarray\n        An array of indices into the flattened version of an array\n        of dimensions ``dims``.\n\n    See Also\n    --------\n    unravel_index\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Examples\n    --------\n    >>> arr = np.array([[3,6,6],[4,5,1]])\n    >>> np.ravel_multi_index(arr, (7,6))\n    array([22, 41, 37])\n    >>> np.ravel_multi_index(arr, (7,6), order='F')\n    array([31, 41, 13])\n    >>> np.ravel_multi_index(arr, (4,6), mode='clip')\n    array([22, 23, 19])\n    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\n    array([12, 13, 13])\n\n    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n    1621\n    ","^0","^9"],["^ ","^7","vdot","^8","\n    vdot(a, b)\n\n    Return the dot product of two vectors.\n\n    The vdot(`a`, `b`) function handles complex numbers differently than\n    dot(`a`, `b`).  If the first argument is complex the complex conjugate\n    of the first argument is used for the calculation of the dot product.\n\n    Note that `vdot` handles multidimensional arrays differently than `dot`:\n    it does *not* perform a matrix product, but flattens input arguments\n    to 1-D vectors first. Consequently, it should only be used for vectors.\n\n    Parameters\n    ----------\n    a : array_like\n        If `a` is complex the complex conjugate is taken before calculation\n        of the dot product.\n    b : array_like\n        Second argument to the dot product.\n\n    Returns\n    -------\n    output : ndarray\n        Dot product of `a` and `b`.  Can be an int, float, or\n        complex depending on the types of `a` and `b`.\n\n    See Also\n    --------\n    dot : Return the dot product without using the complex conjugate of the\n          first argument.\n\n    Examples\n    --------\n    >>> a = np.array([1+2j,3+4j])\n    >>> b = np.array([5+6j,7+8j])\n    >>> np.vdot(a, b)\n    (70-8j)\n    >>> np.vdot(b, a)\n    (70+8j)\n\n    Note that higher-dimensional arrays are flattened!\n\n    >>> a = np.array([[1, 4], [5, 6]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.vdot(a, b)\n    30\n    >>> np.vdot(b, a)\n    30\n    >>> 1*4 + 4*1 + 5*2 + 6*2\n    30\n\n    ","^0","^9"],["^ ","^7","int16","^8","Signed integer type, compatible with C ``short``.\n    Character code: ``'h'``.\n    Canonical name: ``np.short``.\n    Alias *on this platform*: ``np.int16``: 16-bit signed integer (-32768 to 32767).","^0","^0"],["^ ","^8","","^0","~:float"],["^ ","^7","MachAr","^8","\n    Diagnosing machine parameters.\n\n    Attributes\n    ----------\n    ibeta : int\n        Radix in which numbers are represented.\n    it : int\n        Number of base-`ibeta` digits in the floating point mantissa M.\n    machep : int\n        Exponent of the smallest (most negative) power of `ibeta` that,\n        added to 1.0, gives something different from 1.0\n    eps : float\n        Floating-point number ``beta**machep`` (floating point precision)\n    negep : int\n        Exponent of the smallest power of `ibeta` that, subtracted\n        from 1.0, gives something different from 1.0.\n    epsneg : float\n        Floating-point number ``beta**negep``.\n    iexp : int\n        Number of bits in the exponent (including its sign and bias).\n    minexp : int\n        Smallest (most negative) power of `ibeta` consistent with there\n        being no leading zeros in the mantissa.\n    xmin : float\n        Floating point number ``beta**minexp`` (the smallest [in\n        magnitude] usable floating value).\n    maxexp : int\n        Smallest (positive) power of `ibeta` that causes overflow.\n    xmax : float\n        ``(1-epsneg) * beta**maxexp`` (the largest [in magnitude]\n        usable floating value).\n    irnd : int\n        In ``range(6)``, information on what kind of rounding is done\n        in addition, and on how underflow is handled.\n    ngrd : int\n        Number of 'guard digits' used when truncating the product\n        of two mantissas to fit the representation.\n    epsilon : float\n        Same as `eps`.\n    tiny : float\n        Same as `xmin`.\n    huge : float\n        Same as `xmax`.\n    precision : float\n        ``- int(-log10(eps))``\n    resolution : float\n        ``- 10**(-precision)``\n\n    Parameters\n    ----------\n    float_conv : function, optional\n        Function that converts an integer or integer array to a float\n        or float array. Default is `float`.\n    int_conv : function, optional\n        Function that converts a float or float array to an integer or\n        integer array. Default is `int`.\n    float_to_float : function, optional\n        Function that converts a float array to float. Default is `float`.\n        Note that this does not seem to do anything useful in the current\n        implementation.\n    float_to_str : function, optional\n        Function that converts a single float to a string. Default is\n        ``lambda v:'%24.16e' %v``.\n    title : str, optional\n        Title that is printed in the string representation of `MachAr`.\n\n    See Also\n    --------\n    finfo : Machine limits for floating point types.\n    iinfo : Machine limits for integer types.\n\n    References\n    ----------\n    .. [1] Press, Teukolsky, Vetterling and Flannery,\n           \"Numerical Recipes in C++,\" 2nd ed,\n           Cambridge University Press, 2002, p. 31.\n\n    ","^0","^0"],["^ ","^7","kron","^8","\n    Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.\n\n    Parameters\n    ----------\n    a, b : array_like\n\n    Returns\n    -------\n    out : ndarray\n\n    See Also\n    --------\n    outer : The outer product\n\n    Notes\n    -----\n    The function assumes that the number of dimensions of `a` and `b`\n    are the same, if necessary prepending the smallest with ones.\n    If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,\n    the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.\n    The elements are products of elements from `a` and `b`, organized\n    explicitly by::\n\n        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n    where::\n\n        kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\n    Examples\n    --------\n    >>> np.kron([1,10,100], [5,6,7])\n    array([  5,   6,   7, ..., 500, 600, 700])\n    >>> np.kron([5,6,7], [1,10,100])\n    array([  5,  50, 500, ...,   7,  70, 700])\n\n    >>> np.kron(np.eye(2), np.ones((2,2)))\n    array([[1.,  1.,  0.,  0.],\n           [1.,  1.,  0.,  0.],\n           [0.,  0.,  1.,  1.],\n           [0.,  0.,  1.,  1.]])\n\n    >>> a = np.arange(100).reshape((2,5,2,5))\n    >>> b = np.arange(24).reshape((2,3,4))\n    >>> c = np.kron(a,b)\n    >>> c.shape\n    (2, 10, 6, 20)\n    >>> I = (1,3,0,2)\n    >>> J = (0,2,1)\n    >>> J1 = (0,) + J             # extend to ndim=4\n    >>> S1 = (1,) + b.shape\n    >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n    >>> c[K] == a[I]*b[J]\n    True\n\n    ","^0","^9"],["^ ","^7","flexible","^8","Abstract base class of all scalar types without predefined length.\n    The actual size of these types depends on the specific `np.dtype`\n    instantiation.","^0","^0"],["^ ","^7","recfromcsv","^8","\n    Load ASCII data stored in a comma-separated file.\n\n    The returned array is a record array (if ``usemask=False``, see\n    `recarray`) or a masked record array (if ``usemask=True``,\n    see `ma.mrecords.MaskedRecords`).\n\n    Parameters\n    ----------\n    fname, kwargs : For a description of input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function to load ASCII data.\n\n    Notes\n    -----\n    By default, `dtype` is None, which means that the data-type of the output\n    array will be determined from the data.\n\n    ","^0","^9"],["^ ","^7","inexact","^8","Abstract base class of all numeric scalar types with a (potentially)\n    inexact representation of the values in its range, such as\n    floating-point numbers.","^0","^0"],["^ ","^7","floor","^8","floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the floor of the input, element-wise.\n\nThe floor of the scalar `x` is the largest integer `i`, such that\n`i <= x`.  It is often denoted as :math:`\\lfloor x \\rfloor`.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The floor of each element in `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nceil, trunc, rint\n\nNotes\n-----\nSome spreadsheet programs calculate the \"floor-towards-zero\", in other\nwords ``floor(-2.5) == -2``.  NumPy instead uses the definition of\n`floor` where `floor(-2.5) == -3`.\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])","^0","~:ufunc"],["^ ","^8","","^0","~:int"],["^ ","^7","compress","^8","\n    Return selected slices of an array along given axis.\n\n    When working along a given axis, a slice along that axis is returned in\n    `output` for each index where `condition` evaluates to True. When\n    working on a 1-D array, `compress` is equivalent to `extract`.\n\n    Parameters\n    ----------\n    condition : 1-D array of bools\n        Array that selects which entries to return. If len(condition)\n        is less than the size of `a` along the given axis, then output is\n        truncated to the length of the condition array.\n    a : array_like\n        Array from which to extract a part.\n    axis : int, optional\n        Axis along which to take slices. If None (default), work on the\n        flattened array.\n    out : ndarray, optional\n        Output array.  Its type is preserved and it must be of the right\n        shape to hold the output.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        A copy of `a` without the slices along axis for which `condition`\n        is false.\n\n    See Also\n    --------\n    take, choose, diag, diagonal, select\n    ndarray.compress : Equivalent method in ndarray\n    np.extract: Equivalent method when working on 1-D arrays\n    ufuncs-output-type\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> a\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.compress([0, 1], a, axis=0)\n    array([[3, 4]])\n    >>> np.compress([False, True, True], a, axis=0)\n    array([[3, 4],\n           [5, 6]])\n    >>> np.compress([False, True], a, axis=1)\n    array([[2],\n           [4],\n           [6]])\n\n    Working on the flattened array does not return slices along an axis but\n    selects elements.\n\n    >>> np.compress([False, True], a)\n    array([2])\n\n    ","^0","^9"],["^ ","^7","longfloat","^8","Extended-precision floating-point number type, compatible with C\n    ``long double`` but not necessarily with IEEE 754 quadruple-precision.\n    Character code: ``'g'``.\n    Canonical name: ``np.longdouble``.\n    Alias: ``np.longfloat``.\n    Alias *on this platform*: ``np.float128``: 128-bit extended-precision floating-point number type.","^0","^0"],["^ ","^7","log1p","^8","log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the natural logarithm of one plus the input array, element-wise.\n\nCalculates ``log(1 + x)``.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    Natural logarithm of `1 + x`, element-wise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nexpm1 : ``exp(x) - 1``, the inverse of `log1p`.\n\nNotes\n-----\nFor real-valued input, `log1p` is accurate also for `x` so small\nthat `1 + x == 1` in floating-point accuracy.\n\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `exp(z) = 1 + x`. The convention is to return\nthe `z` whose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log1p` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log1p` is a complex analytical function that\nhas a branch cut `[-inf, -1]` and is continuous from above on it.\n`log1p` handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm\n\nExamples\n--------\n>>> np.log1p(1e-99)\n1e-99\n>>> np.log(1 + 1e-99)\n0.0","^0","^;"],["^ ","^7","arctan2","^8","arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.\n\nThe quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is\nthe signed angle in radians between the ray ending at the origin and\npassing through the point (1,0), and the ray ending at the origin and\npassing through the point (`x2`, `x1`).  (Note the role reversal: the\n\"`y`-coordinate\" is the first function parameter, the \"`x`-coordinate\"\nis the second.)  By IEEE convention, this function is defined for\n`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see\nNotes for specific values).\n\nThis function is not defined for complex-valued arguments; for the\nso-called argument of complex values, use `angle`.\n\nParameters\n----------\nx1 : array_like, real-valued\n    `y`-coordinates.\nx2 : array_like, real-valued\n    `x`-coordinates. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nangle : ndarray\n    Array of angles in radians, in the range ``[-pi, pi]``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\narctan, tan, angle\n\nNotes\n-----\n*arctan2* is identical to the `atan2` function of the underlying\nC library.  The following special values are defined in the C\nstandard: [1]_\n\n====== ====== ================\n`x1`   `x2`   `arctan2(x1,x2)`\n====== ====== ================\n+/- 0  +0     +/- 0\n+/- 0  -0     +/- pi\n > 0   +/-inf +0 / +pi\n < 0   +/-inf -0 / -pi\n+/-inf +inf   +/- (pi/4)\n+/-inf -inf   +/- (3*pi/4)\n====== ====== ================\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf\nand -inf.\n\nReferences\n----------\n.. [1] ISO/IEC standard 9899:1999, \"Programming language C.\"\n\nExamples\n--------\nConsider four points in different quadrants:\n\n>>> x = np.array([-1, +1, +1, -1])\n>>> y = np.array([-1, -1, +1, +1])\n>>> np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n\nNote the order of the parameters. `arctan2` is defined also when `x2` = 0\nand at several other special points, obtaining values in\nthe range ``[-pi, pi]``:\n\n>>> np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([ 0.        ,  3.14159265,  0.78539816])","^0","^;"],["^ ","^7","ceil","^8","ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the ceiling of the input, element-wise.\n\nThe ceil of the scalar `x` is the smallest integer `i`, such that\n`i >= x`.  It is often denoted as :math:`\\lceil x \\rceil`.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The ceiling of each element in `x`, with `float` dtype.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nfloor, trunc, rint\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])","^0","^;"],["^ ","^7","int","^8","int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4","^0","^0"],["^ ","^7","asfortranarray","^8","\n    Return an array (ndim >= 1) laid out in Fortran order in memory.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        By default, the data-type is inferred from the input data.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` in Fortran, or column-major, order.\n\n    See Also\n    --------\n    ascontiguousarray : Convert input to a contiguous (C order) array.\n    asanyarray : Convert input to an ndarray with either row or\n        column-major memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> y = np.asfortranarray(x)\n    >>> x.flags['F_CONTIGUOUS']\n    False\n    >>> y.flags['F_CONTIGUOUS']\n    True\n\n    Note: This function returns an array with at least one-dimension (1-d) \n    so it will not preserve 0-d arrays.  \n\n    ","^0","^9"],["^ ","^7","logical_and","^8","logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 AND x2 element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    Boolean result of the logical AND operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_or, logical_not, logical_xor\nbitwise_and\n\nExamples\n--------\n>>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False])\n\n>>> x = np.arange(5)\n>>> np.logical_and(x>1, x<4)\narray([False, False,  True,  True, False])","^0","^;"],["^ ","^7","object","^8","The most base type","^0","^0"],["^ ","^7","flatnonzero","^8","\n    Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to np.nonzero(np.ravel(a))[0].\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of `a.ravel()`\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n\n    ","^0","^9"],["^ ","^7","isscalar","^8","\n    Returns True if the type of `element` is a scalar type.\n\n    Parameters\n    ----------\n    element : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `element` is a scalar type, False if it is not.\n\n    See Also\n    --------\n    ndim : Get the number of dimensions of an array\n\n    Notes\n    -----\n    If you need a stricter way to identify a *numerical* scalar, use\n    ``isinstance(x, numbers.Number)``, as that returns ``False`` for most\n    non-numerical elements such as strings.\n\n    In most cases ``np.ndim(x) == 0`` should be used instead of this function,\n    as that will also return true for 0d arrays. This is how numpy overloads\n    functions in the style of the ``dx`` arguments to `gradient` and the ``bins``\n    argument to `histogram`. Some key differences:\n\n    +--------------------------------------+---------------+-------------------+\n    | x                                    |``isscalar(x)``|``np.ndim(x) == 0``|\n    +======================================+===============+===================+\n    | PEP 3141 numeric objects (including  | ``True``      | ``True``          |\n    | builtins)                            |               |                   |\n    +--------------------------------------+---------------+-------------------+\n    | builtin string and buffer objects    | ``True``      | ``True``          |\n    +--------------------------------------+---------------+-------------------+\n    | other builtin objects, like          | ``False``     | ``True``          |\n    | `pathlib.Path`, `Exception`,         |               |                   |\n    | the result of `re.compile`           |               |                   |\n    +--------------------------------------+---------------+-------------------+\n    | third-party objects like             | ``False``     | ``True``          |\n    | `matplotlib.figure.Figure`           |               |                   |\n    +--------------------------------------+---------------+-------------------+\n    | zero-dimensional numpy arrays        | ``False``     | ``True``          |\n    +--------------------------------------+---------------+-------------------+\n    | other numpy arrays                   | ``False``     | ``False``         |\n    +--------------------------------------+---------------+-------------------+\n    | `list`, `tuple`, and other sequence  | ``False``     | ``False``         |\n    | objects                              |               |                   |\n    +--------------------------------------+---------------+-------------------+\n\n    Examples\n    --------\n    >>> np.isscalar(3.1)\n    True\n    >>> np.isscalar(np.array(3.1))\n    False\n    >>> np.isscalar([3.1])\n    False\n    >>> np.isscalar(False)\n    True\n    >>> np.isscalar('numpy')\n    True\n\n    NumPy supports PEP 3141 numbers:\n\n    >>> from fractions import Fraction\n    >>> np.isscalar(Fraction(5, 17))\n    True\n    >>> from numbers import Number\n    >>> np.isscalar(Number())\n    True\n\n    ","^0","^9"],["^ ","^7","common_type","^8","\n    Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays except int64 and uint64 can be safely cast to the\n    returned dtype without loss of information.\n\n    Parameters\n    ----------\n    array1, array2, ... : ndarrays\n        Input arrays.\n\n    Returns\n    -------\n    out : data type code\n        Data type code.\n\n    See Also\n    --------\n    dtype, mintypecode\n\n    Examples\n    --------\n    >>> np.common_type(np.arange(2, dtype=np.float32))\n    <class 'numpy.float32'>\n    >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n    <class 'numpy.float64'>\n    >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n    <class 'numpy.complex128'>\n\n    ","^0","^9"],["^ ","^7","clongdouble","^8","Complex number type composed of two extended-precision floating-point\n    numbers.\n    Character code: ``'G'``.\n    Canonical name: ``np.clongdouble``.\n    Alias: ``np.clongfloat``.\n    Alias: ``np.longcomplex``.\n    Alias *on this platform*: ``np.complex256``: Complex number type composed of 2 128-bit extended-precision floating-point numbers.","^0","^0"],["^ ","^7","diag","^8","\n    Extract a diagonal or construct a diagonal array.\n\n    See the more detailed documentation for ``numpy.diagonal`` if you use this\n    function to extract a diagonal and wish to write to the resulting array;\n    whether it returns a copy or a view depends on what version of numpy you\n    are using.\n\n    Parameters\n    ----------\n    v : array_like\n        If `v` is a 2-D array, return a copy of its `k`-th diagonal.\n        If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th\n        diagonal.\n    k : int, optional\n        Diagonal in question. The default is 0. Use `k>0` for diagonals\n        above the main diagonal, and `k<0` for diagonals below the main\n        diagonal.\n\n    Returns\n    -------\n    out : ndarray\n        The extracted diagonal or constructed diagonal array.\n\n    See Also\n    --------\n    diagonal : Return specified diagonals.\n    diagflat : Create a 2-D array with the flattened input as a diagonal.\n    trace : Sum along diagonals.\n    triu : Upper triangle of an array.\n    tril : Lower triangle of an array.\n\n    Examples\n    --------\n    >>> x = np.arange(9).reshape((3,3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n\n    >>> np.diag(x)\n    array([0, 4, 8])\n    >>> np.diag(x, k=1)\n    array([1, 5])\n    >>> np.diag(x, k=-1)\n    array([3, 7])\n\n    >>> np.diag(np.diag(x))\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 8]])\n\n    ","^0","^9"],["^ ","^7","nanmax","^8","\n    Return the maximum of an array or maximum along an axis, ignoring any\n    NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is\n    raised and NaN is returned for that slice.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose maximum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the maximum is computed. The default is to compute\n        the maximum of the flattened array.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        `ufuncs-output-type` for more details.\n\n        .. versionadded:: 1.8.0\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `max` method\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n        .. versionadded:: 1.8.0\n\n    Returns\n    -------\n    nanmax : ndarray\n        An array with the same shape as `a`, with the specified axis removed.\n        If `a` is a 0-d array, or if axis is None, an ndarray scalar is\n        returned.  The same dtype as `a` is returned.\n\n    See Also\n    --------\n    nanmin :\n        The minimum value of an array along a given axis, ignoring any NaNs.\n    amax :\n        The maximum value of an array along a given axis, propagating any NaNs.\n    fmax :\n        Element-wise maximum of two arrays, ignoring any NaNs.\n    maximum :\n        Element-wise maximum of two arrays, propagating any NaNs.\n    isnan :\n        Shows which elements are Not a Number (NaN).\n    isfinite:\n        Shows which elements are neither NaN nor infinity.\n\n    amin, fmin, minimum\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative\n    infinity is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.max.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmax(a)\n    3.0\n    >>> np.nanmax(a, axis=0)\n    array([3.,  2.])\n    >>> np.nanmax(a, axis=1)\n    array([2.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmax([1, 2, np.nan, np.NINF])\n    2.0\n    >>> np.nanmax([1, 2, np.nan, np.inf])\n    inf\n\n    ","^0","^9"],["^ ","^7","generic","^8","Base class for numpy scalar types.\n\n    Class from which most (all?) numpy scalar types are derived.  For\n    consistency, exposes the same API as `ndarray`, despite many\n    consequent attributes being either \"get-only,\" or completely irrelevant.\n    This is the class from which it is strongly suggested users should derive\n    custom scalar types.","^0","^0"],["^ ","^8","","^0","~:str"],["^ ","^7","digitize","^8","\n    Return the indices of the bins to which each value in input array belongs.\n\n    =========  =============  ============================\n    `right`    order of bins  returned index `i` satisfies\n    =========  =============  ============================\n    ``False``  increasing     ``bins[i-1] <= x < bins[i]``\n    ``True``   increasing     ``bins[i-1] < x <= bins[i]``\n    ``False``  decreasing     ``bins[i-1] > x >= bins[i]``\n    ``True``   decreasing     ``bins[i-1] >= x > bins[i]``\n    =========  =============  ============================\n\n    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is\n    returned as appropriate.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array to be binned. Prior to NumPy 1.10.0, this array had to\n        be 1-dimensional, but can now have any shape.\n    bins : array_like\n        Array of bins. It has to be 1-dimensional and monotonic.\n    right : bool, optional\n        Indicating whether the intervals include the right or the left bin\n        edge. Default behavior is (right==False) indicating that the interval\n        does not include the right edge. The left bin end is open in this\n        case, i.e., bins[i-1] <= x < bins[i] is the default behavior for\n        monotonically increasing bins.\n\n    Returns\n    -------\n    indices : ndarray of ints\n        Output array of indices, of same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `bins` is not monotonic.\n    TypeError\n        If the type of the input is complex.\n\n    See Also\n    --------\n    bincount, histogram, unique, searchsorted\n\n    Notes\n    -----\n    If values in `x` are such that they fall outside the bin range,\n    attempting to index `bins` with the indices that `digitize` returns\n    will result in an IndexError.\n\n    .. versionadded:: 1.10.0\n\n    `np.digitize` is  implemented in terms of `np.searchsorted`. This means\n    that a binary search is used to bin the values, which scales much better\n    for larger number of bins than the previous linear search. It also removes\n    the requirement for the input array to be 1-dimensional.\n\n    For monotonically _increasing_ `bins`, the following are equivalent::\n\n        np.digitize(x, bins, right=True)\n        np.searchsorted(bins, x, side='left')\n\n    Note that as the order of the arguments are reversed, the side must be too.\n    The `searchsorted` call is marginally faster, as it does not do any\n    monotonicity checks. Perhaps more importantly, it supports all dtypes.\n\n    Examples\n    --------\n    >>> x = np.array([0.2, 6.4, 3.0, 1.6])\n    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n    >>> inds = np.digitize(x, bins)\n    >>> inds\n    array([1, 4, 3, 2])\n    >>> for n in range(x.size):\n    ...   print(bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]])\n    ...\n    0.0 <= 0.2 < 1.0\n    4.0 <= 6.4 < 10.0\n    2.5 <= 3.0 < 4.0\n    1.0 <= 1.6 < 2.5\n\n    >>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])\n    >>> bins = np.array([0, 5, 10, 15, 20])\n    >>> np.digitize(x,bins,right=True)\n    array([1, 2, 3, 4, 4])\n    >>> np.digitize(x,bins,right=False)\n    array([1, 3, 3, 4, 5])\n    ","^0","^9"],["^ ","^7","array_split","^8","\n    Split an array into multiple sub-arrays.\n\n    Please refer to the ``split`` documentation.  The only difference\n    between these functions is that ``array_split`` allows\n    `indices_or_sections` to be an integer that does *not* equally\n    divide the axis. For an array of length l that should be split\n    into n sections, it returns l % n sub-arrays of size l//n + 1\n    and the rest of size l//n.\n\n    See Also\n    --------\n    split : Split array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n        [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n\n    >>> x = np.arange(7.0)\n    >>> np.array_split(x, 3)\n        [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]\n\n    ","^0","^9"],["^ ","^7","numpy.random","^8","\n========================\nRandom Number Generation\n========================\n\nUse ``default_rng()`` to create a `Generator` and call its methods.\n\n=============== =========================================================\nGenerator\n--------------- ---------------------------------------------------------\nGenerator       Class implementing all of the random number distributions\ndefault_rng     Default constructor for ``Generator``\n=============== =========================================================\n\n============================================= ===\nBitGenerator Streams that work with Generator\n--------------------------------------------- ---\nMT19937\nPCG64\nPhilox\nSFC64\n============================================= ===\n\n============================================= ===\nGetting entropy to initialize a BitGenerator\n--------------------------------------------- ---\nSeedSequence\n============================================= ===\n\n\nLegacy\n------\n\nFor backwards compatibility with previous versions of numpy before 1.17, the\nvarious aliases to the global `RandomState` methods are left alone and do not\nuse the new `Generator` API.\n\n==================== =========================================================\nUtility functions\n-------------------- ---------------------------------------------------------\nrandom               Uniformly distributed floats over ``[0, 1)``\nbytes                Uniformly distributed random bytes.\npermutation          Randomly permute a sequence / generate a random sequence.\nshuffle              Randomly permute a sequence in place.\nchoice               Random sample from 1-D array.\n==================== =========================================================\n\n==================== =========================================================\nCompatibility\nfunctions - removed\nin the new API\n-------------------- ---------------------------------------------------------\nrand                 Uniformly distributed values.\nrandn                Normally distributed values.\nranf                 Uniformly distributed floating point numbers.\nrandom_integers      Uniformly distributed integers in a given range.\n                     (deprecated, use ``integers(..., closed=True)`` instead)\nrandom_sample        Alias for `random_sample`\nrandint              Uniformly distributed integers in a given range\nseed                 Seed the legacy random number generator.\n==================== =========================================================\n\n==================== =========================================================\nUnivariate\ndistributions\n-------------------- ---------------------------------------------------------\nbeta                 Beta distribution over ``[0, 1]``.\nbinomial             Binomial distribution.\nchisquare            :math:`\\chi^2` distribution.\nexponential          Exponential distribution.\nf                    F (Fisher-Snedecor) distribution.\ngamma                Gamma distribution.\ngeometric            Geometric distribution.\ngumbel               Gumbel distribution.\nhypergeometric       Hypergeometric distribution.\nlaplace              Laplace distribution.\nlogistic             Logistic distribution.\nlognormal            Log-normal distribution.\nlogseries            Logarithmic series distribution.\nnegative_binomial    Negative binomial distribution.\nnoncentral_chisquare Non-central chi-square distribution.\nnoncentral_f         Non-central F distribution.\nnormal               Normal / Gaussian distribution.\npareto               Pareto distribution.\npoisson              Poisson distribution.\npower                Power distribution.\nrayleigh             Rayleigh distribution.\ntriangular           Triangular distribution.\nuniform              Uniform distribution.\nvonmises             Von Mises circular distribution.\nwald                 Wald (inverse Gaussian) distribution.\nweibull              Weibull distribution.\nzipf                 Zipf's distribution over ranked data.\n==================== =========================================================\n\n==================== ==========================================================\nMultivariate\ndistributions\n-------------------- ----------------------------------------------------------\ndirichlet            Multivariate generalization of Beta distribution.\nmultinomial          Multivariate generalization of the binomial distribution.\nmultivariate_normal  Multivariate generalization of the normal distribution.\n==================== ==========================================================\n\n==================== =========================================================\nStandard\ndistributions\n-------------------- ---------------------------------------------------------\nstandard_cauchy      Standard Cauchy-Lorentz distribution.\nstandard_exponential Standard exponential distribution.\nstandard_gamma       Standard Gamma distribution.\nstandard_normal      Standard normal distribution.\nstandard_t           Standard Student's t-distribution.\n==================== =========================================================\n\n==================== =========================================================\nInternal functions\n-------------------- ---------------------------------------------------------\nget_state            Get tuple representing internal state of generator.\nset_state            Set state of generator.\n==================== =========================================================\n\n\n","^0","~:module"],["^ ","^7","get_include","^8","\n    Return the directory that contains the NumPy \\*.h header files.\n\n    Extension modules that need to compile against NumPy should use this\n    function to locate the appropriate include directory.\n\n    Notes\n    -----\n    When using ``distutils``, for example in ``setup.py``.\n    ::\n\n        import numpy as np\n        ...\n        Extension('extension_name', ...\n                include_dirs=[np.get_include()])\n        ...\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^8","","^0","^<"],["^ ","^7","numpy.__config__","^8",null,"^0","^>"],["^ ","^7","alen","^8","\n    Return the length of the first dimension of the input array.\n\n    Parameters\n    ----------\n    a : array_like\n       Input array.\n\n    Returns\n    -------\n    alen : int\n       Length of the first dimension of `a`.\n\n    See Also\n    --------\n    shape, size\n\n    Examples\n    --------\n    >>> a = np.zeros((7,4,5))\n    >>> a.shape[0]\n    7\n    >>> np.alen(a)\n    7\n\n    ","^0","^9"],["^ ","^7","save","^8","\n    Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        File or filename to which the data is saved.  If file is a file-object,\n        then the filename is unchanged.  If file is a string or Path, a ``.npy``\n        extension will be appended to the filename if it does not already\n        have one.\n    arr : array_like\n        Array data to be saved.\n    allow_pickle : bool, optional\n        Allow saving object arrays using Python pickles. Reasons for disallowing\n        pickles include security (loading pickled data can execute arbitrary\n        code) and portability (pickled objects may not be loadable on different\n        Python installations, for example if the stored objects require libraries\n        that are not available, and not all pickled data is compatible between\n        Python 2 and Python 3).\n        Default: True\n    fix_imports : bool, optional\n        Only useful in forcing objects in object arrays on Python 3 to be\n        pickled in a Python 2 compatible way. If `fix_imports` is True, pickle\n        will try to map the new Python 3 names to the old module names used in\n        Python 2, so that the pickle data stream is readable with Python 2.\n\n    See Also\n    --------\n    savez : Save several arrays into a ``.npz`` archive\n    savetxt, load\n\n    Notes\n    -----\n    For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.\n\n    Any data saved to the file is appended to the end of the file.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n\n    >>> x = np.arange(10)\n    >>> np.save(outfile, x)\n\n    >>> _ = outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> np.load(outfile)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n    >>> with open('test.npy', 'wb') as f:\n    ...     np.save(f, np.array([1, 2]))\n    ...     np.save(f, np.array([1, 3]))\n    >>> with open('test.npy', 'rb') as f:\n    ...     a = np.load(f)\n    ...     b = np.load(f)\n    >>> print(a, b)\n    # [1 2] [1 3]\n    ","^0","^9"],["^ ","^7","cosh","^8","cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic cosine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array of same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.cosh(0)\n1.0\n\nThe hyperbolic cosine describes the shape of a hanging cable:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-4, 4, 1000)\n>>> plt.plot(x, np.cosh(x))\n>>> plt.show()","^0","^;"],["^ ","^7","ix_","^8","\n    Construct an open mesh from multiple sequences.\n\n    This function takes N 1-D sequences and returns N outputs with N\n    dimensions each, such that the shape is 1 in all but one dimension\n    and the dimension with the non-unit shape value cycles through all\n    N dimensions.\n\n    Using `ix_` one can quickly construct index arrays that will index\n    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array\n    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.\n\n    Parameters\n    ----------\n    args : 1-D sequences\n        Each sequence should be of integer or boolean type.\n        Boolean sequences will be interpreted as boolean masks for the\n        corresponding dimension (equivalent to passing in\n        ``np.nonzero(boolean_sequence)``).\n\n    Returns\n    -------\n    out : tuple of ndarrays\n        N arrays with N dimensions each, with N the number of input\n        sequences. Together these arrays form an open mesh.\n\n    See Also\n    --------\n    ogrid, mgrid, meshgrid\n\n    Examples\n    --------\n    >>> a = np.arange(10).reshape(2, 5)\n    >>> a\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> ixgrid = np.ix_([0, 1], [2, 4])\n    >>> ixgrid\n    (array([[0],\n           [1]]), array([[2, 4]]))\n    >>> ixgrid[0].shape, ixgrid[1].shape\n    ((2, 1), (1, 2))\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n\n    >>> ixgrid = np.ix_([True, True], [2, 4])\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n    >>> ixgrid = np.ix_([True, True], [False, False, True, False, True])\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n\n    ","^0","^9"],["^ ","^8","","^0","^:"],["^ ","^7","int_asbuffer","^8",null,"^0","~:builtin-function-or-method"],["^ ","^7","ufunc","^8","Functions that operate element by element on whole arrays.\n\n    To see the documentation for a specific ufunc, use `info`.  For\n    example, ``np.info(np.sin)``.  Because ufuncs are written in C\n    (for speed) and linked into Python with NumPy's ufunc facility,\n    Python's help() function finds this page whenever help() is called\n    on a ufunc.\n\n    A detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.\n\n    Calling ufuncs:\n    ===============\n\n    op(*x[, out], where=True, **kwargs)\n    Apply `op` to the arguments `*x` elementwise, broadcasting the arguments.\n\n    The broadcasting rules are:\n\n    * Dimensions of length 1 may be prepended to either array.\n    * Arrays may be repeated along dimensions of length 1.\n\n    Parameters\n    ----------\n    *x : array_like\n        Input arrays.\n    out : ndarray, None, or tuple of ndarray and None, optional\n        Alternate array object(s) in which to put the result; if provided, it\n        must have a shape that the inputs broadcast to. A tuple of arrays\n        (possible only as a keyword argument) must have length equal to the\n        number of outputs; use None for uninitialized outputs to be\n        allocated by the ufunc.\n    where : array_like, optional\n        This condition is broadcast over the input. At locations where the\n        condition is True, the `out` array will be set to the ufunc result.\n        Elsewhere, the `out` array will retain its original value.\n        Note that if an uninitialized `out` array is created via the default\n        ``out=None``, locations within it where the condition is False will\n        remain uninitialized.\n    **kwargs\n        For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.\n\n    Returns\n    -------\n    r : ndarray or tuple of ndarray\n        `r` will have the shape that the arrays in `x` broadcast to; if `out` is\n        provided, it will be returned. If not, `r` will be allocated and\n        may contain uninitialized values. If the function has more than one\n        output, then the result will be a tuple of arrays.","^0","^0"],["^ ","^7","TooHardError","^8",null,"^0","^0"],["^ ","^7","sctype2char","^8","\n    Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, `sctype2char` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type can not be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:\n    ...     print(np.sctype2char(sctype))\n    l # may vary\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> np.sctype2char(x)\n    'D'\n    >>> np.sctype2char(list)\n    'O'\n\n    ","^0","^9"],["^ ","^7","unique","^8","\n    Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are three optional\n    outputs in addition to the unique elements:\n\n    * the indices of the input array that give the unique values\n    * the indices of the unique array that reconstruct the input array\n    * the number of times each unique value comes up in the input array\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. Unless `axis` is specified, this will be flattened if it\n        is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` (along the specified axis,\n        if provided, or in the flattened array) that result in the unique array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array (for the specified\n        axis, if provided) that can be used to reconstruct `ar`.\n    return_counts : bool, optional\n        If True, also return the number of times each unique item appears\n        in `ar`.\n\n        .. versionadded:: 1.9.0\n\n    axis : int or None, optional\n        The axis to operate on. If None, `ar` will be flattened. If an integer,\n        the subarrays indexed by the given axis will be flattened and treated\n        as the elements of a 1-D array with the dimension of the given axis,\n        see the notes for more details.  Object arrays or structured arrays\n        that contain objects are not supported if the `axis` kwarg is used. The\n        default is None.\n\n        .. versionadded:: 1.13.0\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the first occurrences of the unique values in the\n        original array. Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the original array from the\n        unique array. Only provided if `return_inverse` is True.\n    unique_counts : ndarray, optional\n        The number of times each of the unique values comes up in the\n        original array. Only provided if `return_counts` is True.\n\n        .. versionadded:: 1.9.0\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n    When an axis is specified the subarrays indexed by the axis are sorted.\n    This is done by making the specified axis the first dimension of the array\n    (move the axis to the first dimension to keep the order of the other axes)\n    and then flattening the subarrays in C order. The flattened subarrays are\n    then viewed as a structured type with each element given a label, with the\n    effect that we end up with a 1-D array of structured types that can be\n    treated in the same way as any other 1-D array. The result is that the\n    flattened subarrays are sorted in lexicographic order starting with the\n    first element.\n\n    Examples\n    --------\n    >>> np.unique([1, 1, 2, 2, 3, 3])\n    array([1, 2, 3])\n    >>> a = np.array([[1, 1], [2, 3]])\n    >>> np.unique(a)\n    array([1, 2, 3])\n\n    Return the unique rows of a 2D array\n\n    >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])\n    >>> np.unique(a, axis=0)\n    array([[1, 0, 0], [2, 3, 4]])\n\n    Return the indices of the original array that give the unique values:\n\n    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])\n    >>> u, indices = np.unique(a, return_index=True)\n    >>> u\n    array(['a', 'b', 'c'], dtype='<U1')\n    >>> indices\n    array([0, 1, 3])\n    >>> a[indices]\n    array(['a', 'b', 'c'], dtype='<U1')\n\n    Reconstruct the input array from the unique values:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> u, indices = np.unique(a, return_inverse=True)\n    >>> u\n    array([1, 2, 3, 4, 6])\n    >>> indices\n    array([0, 1, 4, ..., 1, 2, 1])\n    >>> u[indices]\n    array([1, 2, 6, ..., 2, 3, 2])\n\n    ","^0","^9"],["^ ","^7","min","^8","\n    Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to operate.  By default, flattened input is\n        used.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, the minimum is selected over multiple axes,\n        instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `amin` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    initial : scalar, optional\n        The maximum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        Elements to compare for the minimum. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    amin : ndarray or scalar\n        Minimum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    amax :\n        The maximum value of an array along a given axis, propagating any NaNs.\n    nanmin :\n        The minimum value of an array along a given axis, ignoring any NaNs.\n    minimum :\n        Element-wise minimum of two arrays, propagating any NaNs.\n    fmin :\n        Element-wise minimum of two arrays, ignoring any NaNs.\n    argmin :\n        Return the indices of the minimum values.\n\n    nanmax, maximum, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding min value will be NaN as well. To ignore NaN values\n    (MATLAB behavior), please use nanmin.\n\n    Don't use `amin` for element-wise comparison of 2 arrays; when\n    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than\n    ``amin(a, axis=0)``.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)   # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)   # Minima along the second axis\n    array([0, 2])\n    >>> np.amin(a, where=[False, True], initial=10, axis=0)\n    array([10,  1])\n\n    >>> b = np.arange(5, dtype=float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.amin(b, where=~np.isnan(b), initial=10)\n    0.0\n    >>> np.nanmin(b)\n    0.0\n\n    >>> np.min([[-50], [10]], axis=-1, initial=0)\n    array([-50,   0])\n\n    Notice that the initial value is used as one of the elements for which the\n    minimum is determined, unlike for the default argument Python's max\n    function, which is only used for empty iterables.\n\n    Notice that this isn't the same as Python's ``default`` argument.\n\n    >>> np.min([6], initial=5)\n    5\n    >>> min([6], default=5)\n    6\n    ","^0","^9"],["^ ","^7","histogram2d","^8","\n    Compute the bi-dimensional histogram of two data samples.\n\n    Parameters\n    ----------\n    x : array_like, shape (N,)\n        An array containing the x coordinates of the points to be\n        histogrammed.\n    y : array_like, shape (N,)\n        An array containing the y coordinates of the points to be\n        histogrammed.\n    bins : int or array_like or [int, int] or [array, array], optional\n        The bin specification:\n\n          * If int, the number of bins for the two dimensions (nx=ny=bins).\n          * If array_like, the bin edges for the two dimensions\n            (x_edges=y_edges=bins).\n          * If [int, int], the number of bins in each dimension\n            (nx, ny = bins).\n          * If [array, array], the bin edges in each dimension\n            (x_edges, y_edges = bins).\n          * A combination [int, array] or [array, int], where int\n            is the number of bins and array is the bin edges.\n\n    range : array_like, shape(2,2), optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n        will be considered outliers and not tallied in the histogram.\n    density : bool, optional\n        If False, the default, returns the number of samples in each bin.\n        If True, returns the probability *density* function at the bin,\n        ``bin_count / sample_count / bin_area``.\n    normed : bool, optional\n        An alias for the density argument that behaves identically. To avoid\n        confusion with the broken normed argument to `histogram`, `density`\n        should be preferred.\n    weights : array_like, shape(N,), optional\n        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.\n        Weights are normalized to 1 if `normed` is True. If `normed` is\n        False, the values of the returned histogram are equal to the sum of\n        the weights belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray, shape(nx, ny)\n        The bi-dimensional histogram of samples `x` and `y`. Values in `x`\n        are histogrammed along the first dimension and values in `y` are\n        histogrammed along the second dimension.\n    xedges : ndarray, shape(nx+1,)\n        The bin edges along the first dimension.\n    yedges : ndarray, shape(ny+1,)\n        The bin edges along the second dimension.\n\n    See Also\n    --------\n    histogram : 1D histogram\n    histogramdd : Multidimensional histogram\n\n    Notes\n    -----\n    When `normed` is True, then the returned histogram is the sample\n    density, defined such that the sum over bins of the product\n    ``bin_value * bin_area`` is 1.\n\n    Please note that the histogram does not follow the Cartesian convention\n    where `x` values are on the abscissa and `y` values on the ordinate\n    axis.  Rather, `x` is histogrammed along the first dimension of the\n    array (vertical), and `y` along the second dimension of the array\n    (horizontal).  This ensures compatibility with `histogramdd`.\n\n    Examples\n    --------\n    >>> from matplotlib.image import NonUniformImage\n    >>> import matplotlib.pyplot as plt\n\n    Construct a 2-D histogram with variable bin width. First define the bin\n    edges:\n\n    >>> xedges = [0, 1, 3, 5]\n    >>> yedges = [0, 2, 3, 4, 6]\n\n    Next we create a histogram H with random bin content:\n\n    >>> x = np.random.normal(2, 1, 100)\n    >>> y = np.random.normal(1, 1, 100)\n    >>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))\n    >>> H = H.T  # Let each row list bins with common y range.\n\n    :func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:\n\n    >>> fig = plt.figure(figsize=(7, 3))\n    >>> ax = fig.add_subplot(131, title='imshow: square bins')\n    >>> plt.imshow(H, interpolation='nearest', origin='low',\n    ...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])\n    <matplotlib.image.AxesImage object at 0x...>\n\n    :func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:\n\n    >>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',\n    ...         aspect='equal')\n    >>> X, Y = np.meshgrid(xedges, yedges)\n    >>> ax.pcolormesh(X, Y, H)\n    <matplotlib.collections.QuadMesh object at 0x...>\n\n    :class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to\n    display actual bin edges with interpolation:\n\n    >>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',\n    ...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])\n    >>> im = NonUniformImage(ax, interpolation='bilinear')\n    >>> xcenters = (xedges[:-1] + xedges[1:]) / 2\n    >>> ycenters = (yedges[:-1] + yedges[1:]) / 2\n    >>> im.set_data(xcenters, ycenters, H)\n    >>> ax.images.append(im)\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","array_str","^8","\n    Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","zeros","^8","zeros(shape, dtype=float, order='C')\n\n    Return a new array of given shape and type, filled with zeros.\n\n    Parameters\n    ----------\n    shape : int or tuple of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        The desired data-type for the array, e.g., `numpy.int8`.  Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: 'C'\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n\n    Returns\n    -------\n    out : ndarray\n        Array of zeros with the given shape, dtype, and order.\n\n    See Also\n    --------\n    zeros_like : Return an array of zeros with shape and type of input.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    full : Return a new array of given shape filled with value.\n\n    Examples\n    --------\n    >>> np.zeros(5)\n    array([ 0.,  0.,  0.,  0.,  0.])\n\n    >>> np.zeros((5,), dtype=int)\n    array([0, 0, 0, 0, 0])\n\n    >>> np.zeros((2, 1))\n    array([[ 0.],\n           [ 0.]])\n\n    >>> s = (2,2)\n    >>> np.zeros(s)\n    array([[ 0.,  0.],\n           [ 0.,  0.]])\n\n    >>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\n    array([(0, 0), (0, 0)],\n          dtype=[('x', '<i4'), ('y', '<i4')])","^0","^?"],["^ ","^8","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^0","~:dict"],["^ ","^7","invert","^8","invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``~``.\n\nFor signed integer inputs, the two's complement is returned.  In a\ntwo's-complement system negative numbers are represented by the two's\ncomplement of the absolute value. This is the most common method of\nrepresenting signed integers on computers [1]_. A N-bit\ntwo's-complement system can represent every integer in the range\n:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\nParameters\n----------\nx : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nbitwise_and, bitwise_or, bitwise_xor\nlogical_not\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nNotes\n-----\n`bitwise_not` is an alias for `invert`:\n\n>>> np.bitwise_not is np.invert\nTrue\n\nReferences\n----------\n.. [1] Wikipedia, \"Two's complement\",\n    https://en.wikipedia.org/wiki/Two's_complement\n\nExamples\n--------\nWe've seen that 13 is represented by ``00001101``.\nThe invert or bit-wise NOT of 13 is then:\n\n>>> x = np.invert(np.array(13, dtype=np.uint8))\n>>> x\n242\n>>> np.binary_repr(x, width=8)\n'11110010'\n\nThe result depends on the bit-width:\n\n>>> x = np.invert(np.array(13, dtype=np.uint16))\n>>> x\n65522\n>>> np.binary_repr(x, width=16)\n'1111111111110010'\n\nWhen using signed integer types the result is the two's complement of\nthe result for the unsigned type:\n\n>>> np.invert(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n>>> np.binary_repr(-14, width=8)\n'11110010'\n\nBooleans are accepted as well:\n\n>>> np.invert(np.array([True, False]))\narray([False,  True])","^0","^;"],["^ ","^7","floor_divide","^8","floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python ``//`` operator and pairs with the\nPython ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``\nup to roundoff.\n\nParameters\n----------\nx1 : array_like\n    Numerator.\nx2 : array_like\n    Denominator. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    y = floor(`x1`/`x2`)\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nremainder : Remainder complementary to floor_divide.\ndivmod : Simultaneous floor division and remainder.\ndivide : Standard division.\nfloor : Round a number to the nearest integer toward minus infinity.\nceil : Round a number to the nearest integer toward infinity.\n\nExamples\n--------\n>>> np.floor_divide(7,3)\n2\n>>> np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])","^0","^;"],["^ ","^7","uint0","^8","Unsigned integer type, compatible with C ``unsigned long``.\n    Character code: ``'L'``.\n    Canonical name: ``np.uint``.\n    Alias *on this platform*: ``np.uint64``: 64-bit unsigned integer (0 to 18446744073709551615).\n    Alias *on this platform*: ``np.uintp``: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.","^0","^0"],["^ ","^7","numpy.ctypeslib","^8","\n============================\n``ctypes`` Utility Functions\n============================\n\nSee Also\n---------\nload_library : Load a C library.\nndpointer : Array restype/argtype with verification.\nas_ctypes : Create a ctypes array from an ndarray.\nas_array : Create an ndarray from a ctypes array.\n\nReferences\n----------\n.. [1] \"SciPy Cookbook: ctypes\", https://scipy-cookbook.readthedocs.io/items/Ctypes.html\n\nExamples\n--------\nLoad the C library:\n\n>>> _lib = np.ctypeslib.load_library('libmystuff', '.')     #doctest: +SKIP\n\nOur result type, an ndarray that must be of type double, be 1-dimensional\nand is C-contiguous in memory:\n\n>>> array_1d_double = np.ctypeslib.ndpointer(\n...                          dtype=np.double,\n...                          ndim=1, flags='CONTIGUOUS')    #doctest: +SKIP\n\nOur C-function typically takes an array and updates its values\nin-place.  For example::\n\n    void foo_func(double* x, int length)\n    {\n        int i;\n        for (i = 0; i < length; i++) {\n            x[i] = i*i;\n        }\n    }\n\nWe wrap it using:\n\n>>> _lib.foo_func.restype = None                      #doctest: +SKIP\n>>> _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIP\n\nThen, we're ready to call ``foo_func``:\n\n>>> out = np.empty(15, dtype=np.double)\n>>> _lib.foo_func(out, len(out))                #doctest: +SKIP\n\n","^0","^>"],["^ ","^7","bool_","^8","Boolean type (True or False), stored as a byte.\n    Character code: ``'?'``.\n    Alias: ``np.bool8``.","^0","^0"],["^ ","^7","void0","^8",null,"^0","^0"],["^ ","^7","bytes_","^8",null,"^0","^0"],["^ ","^7","seterr","^8","\n    Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).\n        - raise: Raise a `FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall, errstate\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]_:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] https://en.wikipedia.org/wiki/IEEE_754\n\n    Examples\n    --------\n    >>> old_settings = np.seterr(all='ignore')  #seterr to known value\n    >>> np.seterr(over='raise')\n    {'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n    >>> np.seterr(**old_settings)  # reset to default\n    {'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}\n\n    >>> np.int16(32000) * np.int16(3)\n    30464\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in short_scalars\n\n    >>> from collections import OrderedDict\n    >>> old_settings = np.seterr(all='print')\n    >>> OrderedDict(np.geterr())\n    OrderedDict([('divide', 'print'), ('over', 'print'), ('under', 'print'), ('invalid', 'print')])\n    >>> np.int16(32000) * np.int16(3)\n    30464\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","isinf","^8","isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for positive or negative infinity.\n\nReturns a boolean array of the same shape as `x`, True where ``x ==\n+/-inf``, otherwise False.\n\nParameters\n----------\nx : array_like\n    Input values\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : bool (scalar) or boolean ndarray\n    True where ``x`` is positive or negative infinity, false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisneginf, isposinf, isnan, isfinite\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\n\nErrors result if the second argument is supplied when the first\nargument is a scalar, or if the first and second arguments have\ndifferent shapes.\n\nExamples\n--------\n>>> np.isinf(np.inf)\nTrue\n>>> np.isinf(np.nan)\nFalse\n>>> np.isinf(np.NINF)\nTrue\n>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isinf(x, y)\narray([1, 0, 1])\n>>> y\narray([1, 0, 1])","^0","^;"],["^ ","^7","spacing","^8","spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the distance between x and the nearest adjacent number.\n\nParameters\n----------\nx : array_like\n    Values to find the spacing of.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The spacing of values of `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIt can be considered as a generalization of EPS:\n``spacing(np.float64(1)) == np.finfo(np.float64).eps``, and there\nshould not be any representable number between ``x + spacing(x)`` and\nx for any finite x.\n\nSpacing of +- inf and NaN is NaN.\n\nExamples\n--------\n>>> np.spacing(1) == np.finfo(np.float64).eps\nTrue","^0","^;"],["^ ","^7","float_","^8","Double-precision floating-point number type, compatible with Python `float`\n    and C ``double``.\n    Character code: ``'d'``.\n    Canonical name: ``np.double``.\n    Alias: ``np.float_``.\n    Alias *on this platform*: ``np.float64``: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.","^0","^0"],["^ ","^7","RankWarning","^8","\n    Issued by `polyfit` when the Vandermonde matrix is rank deficient.\n\n    For more information, a way to suppress the warning, and an example of\n    `RankWarning` being issued, see `polyfit`.\n\n    ","^0","^0"],["^ ","^7","polyval","^8","\n    Evaluate a polynomial at specific values.\n\n    If `p` is of length N, this function returns the value:\n\n        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``\n\n    If `x` is a sequence, then `p(x)` is returned for each element of `x`.\n    If `x` is another polynomial then the composite polynomial `p(x(t))`\n    is returned.\n\n    Parameters\n    ----------\n    p : array_like or poly1d object\n       1D array of polynomial coefficients (including coefficients equal\n       to zero) from highest degree to the constant term, or an\n       instance of poly1d.\n    x : array_like or poly1d object\n       A number, an array of numbers, or an instance of poly1d, at\n       which to evaluate `p`.\n\n    Returns\n    -------\n    values : ndarray or poly1d\n       If `x` is a poly1d instance, the result is the composition of the two\n       polynomials, i.e., `x` is \"substituted\" in `p` and the simplified\n       result is returned. In addition, the type of `x` - array_like or\n       poly1d - governs the type of the output: `x` array_like => `values`\n       array_like, `x` a poly1d object => `values` is also.\n\n    See Also\n    --------\n    poly1d: A polynomial class.\n\n    Notes\n    -----\n    Horner's scheme [1]_ is used to evaluate the polynomial. Even so,\n    for polynomials of high degree the values may be inaccurate due to\n    rounding errors. Use carefully.\n\n    If `x` is a subtype of `ndarray` the return value will be of the same type.\n\n    References\n    ----------\n    .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\n       trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand\n       Reinhold Co., 1985, pg. 720.\n\n    Examples\n    --------\n    >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n    76\n    >>> np.polyval([3,0,1], np.poly1d(5))\n    poly1d([76.])\n    >>> np.polyval(np.poly1d([3,0,1]), 5)\n    76\n    >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\n    poly1d([76.])\n\n    ","^0","^9"],["^ ","^8","\n    Translates slice objects to concatenation along the first axis.\n\n    This is a simple way to build up arrays quickly. There are two use cases.\n\n    1. If the index expression contains comma separated arrays, then stack\n       them along their first axis.\n    2. If the index expression contains slice notation or scalars then create\n       a 1-D array with a range indicated by the slice notation.\n\n    If slice notation is used, the syntax ``start:stop:step`` is equivalent\n    to ``np.arange(start, stop, step)`` inside of the brackets. However, if\n    ``step`` is an imaginary number (i.e. 100j) then its integer portion is\n    interpreted as a number-of-points desired and the start and stop are\n    inclusive. In other words ``start:stop:stepj`` is interpreted as\n    ``np.linspace(start, stop, step, endpoint=1)`` inside of the brackets.\n    After expansion of slice notation, all comma separated sequences are\n    concatenated together.\n\n    Optional character strings placed as the first element of the index\n    expression can be used to change the output. The strings 'r' or 'c' result\n    in matrix output. If the result is 1-D and 'r' is specified a 1 x N (row)\n    matrix is produced. If the result is 1-D and 'c' is specified, then a N x 1\n    (column) matrix is produced. If the result is 2-D then both provide the\n    same matrix result.\n\n    A string integer specifies which axis to stack multiple comma separated\n    arrays along. A string of two comma-separated integers allows indication\n    of the minimum number of dimensions to force each entry into as the\n    second integer (the axis to concatenate along is still the first integer).\n\n    A string with three comma-separated integers allows specification of the\n    axis to concatenate along, the minimum number of dimensions to force the\n    entries to, and which axis should contain the start of the arrays which\n    are less than the specified number of dimensions. In other words the third\n    integer allows you to specify where the 1's should be placed in the shape\n    of the arrays that have their shapes upgraded. By default, they are placed\n    in the front of the shape tuple. The third argument allows you to specify\n    where the start of the array should be instead. Thus, a third argument of\n    '0' would place the 1's at the end of the array shape. Negative integers\n    specify where in the new shape tuple the last dimension of upgraded arrays\n    should be placed, so the default is '-1'.\n\n    Parameters\n    ----------\n    Not a function, so takes no parameters\n\n\n    Returns\n    -------\n    A concatenated ndarray or matrix.\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays along an existing axis.\n    c_ : Translates slice objects to concatenation along the second axis.\n\n    Examples\n    --------\n    >>> np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]\n    array([1, 2, 3, ..., 4, 5, 6])\n    >>> np.r_[-1:1:6j, [0]*3, 5, 6]\n    array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])\n\n    String integers specify the axis to concatenate along or the minimum\n    number of dimensions to force entries into.\n\n    >>> a = np.array([[0, 1, 2], [3, 4, 5]])\n    >>> np.r_['-1', a, a] # concatenate along last axis\n    array([[0, 1, 2, 0, 1, 2],\n           [3, 4, 5, 3, 4, 5]])\n    >>> np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim>=2\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    >>> np.r_['0,2,0', [1,2,3], [4,5,6]]\n    array([[1],\n           [2],\n           [3],\n           [4],\n           [5],\n           [6]])\n    >>> np.r_['1,2,0', [1,2,3], [4,5,6]]\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n\n    Using 'r' or 'c' as a first string argument creates a matrix.\n\n    >>> np.r_['r',[1,2,3], [4,5,6]]\n    matrix([[1, 2, 3, 4, 5, 6]])\n\n    ","^0","~:r-class"],["^ ","^7","ndindex","^8","\n    An N-dimensional iterator object to index arrays.\n\n    Given the shape of an array, an `ndindex` instance iterates over\n    the N-dimensional index of the array. At each iteration a tuple\n    of indices is returned, the last dimension is iterated over first.\n\n    Parameters\n    ----------\n    `*args` : ints\n      The size of each dimension of the array.\n\n    See Also\n    --------\n    ndenumerate, flatiter\n\n    Examples\n    --------\n    >>> for index in np.ndindex(3, 2, 1):\n    ...     print(index)\n    (0, 0, 0)\n    (0, 1, 0)\n    (1, 0, 0)\n    (1, 1, 0)\n    (2, 0, 0)\n    (2, 1, 0)\n\n    ","^0","^0"],["^ ","^8","","^0","^:"],["^ ","^7","deprecate","^8","\n    Issues a DeprecationWarning, adds warning to `old_name`'s\n    docstring, rebinds ``old_name.__name__`` and returns the new\n    function object.\n\n    This function may also be used as a decorator.\n\n    Parameters\n    ----------\n    func : function\n        The function to be deprecated.\n    old_name : str, optional\n        The name of the function to be deprecated. Default is None, in\n        which case the name of `func` is used.\n    new_name : str, optional\n        The new name for the function. Default is None, in which case the\n        deprecation message is that `old_name` is deprecated. If given, the\n        deprecation message is that `old_name` is deprecated and `new_name`\n        should be used instead.\n    message : str, optional\n        Additional explanation of the deprecation.  Displayed in the\n        docstring after the warning.\n\n    Returns\n    -------\n    old_func : function\n        The deprecated function.\n\n    Examples\n    --------\n    Note that ``olduint`` returns a value after printing Deprecation\n    Warning:\n\n    >>> olduint = np.deprecate(np.uint)\n    DeprecationWarning: `uint64` is deprecated! # may vary\n    >>> olduint(6)\n    6\n\n    ","^0","^9"],["^ ","^7","set_printoptions","^8","\n    Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int or None, optional\n        Number of digits of precision for floating point output (default 8).\n        May be None if `floatmode` is not `fixed`, to print as many digits as\n        necessary to uniquely specify the value.\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n        To always use the full repr without summarization, pass `sys.maxsize`.\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        If True, always print floating point numbers using fixed point\n        notation, in which case numbers equal to zero in the current precision\n        will print as zero.  If False, then scientific notation is used when\n        absolute value of the smallest number is < 1e-4 or the ratio of the\n        maximum absolute value to the minimum is > 1e3. The default is False.\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n    sign : string, either '-', '+', or ' ', optional\n        Controls printing of the sign of floating-point types. If '+', always\n        print the sign of positive values. If ' ', always prints a space\n        (whitespace character) in the sign position of positive values.  If\n        '-', omit the sign character of positive values. (default '-')\n    formatter : dict of callables, optional\n        If not None, the keys should indicate the type(s) that the respective\n        formatting function applies to.  Callables should return a string.\n        Types that are not specified (by their corresponding keys) are handled\n        by the default formatters.  Individual types for which a formatter\n        can be set are:\n\n        - 'bool'\n        - 'int'\n        - 'timedelta' : a `numpy.timedelta64`\n        - 'datetime' : a `numpy.datetime64`\n        - 'float'\n        - 'longfloat' : 128-bit floats\n        - 'complexfloat'\n        - 'longcomplexfloat' : composed of two 128-bit floats\n        - 'numpystr' : types `numpy.string_` and `numpy.unicode_`\n        - 'object' : `np.object_` arrays\n        - 'str' : all other strings\n\n        Other keys that can be used to set a group of types at once are:\n\n        - 'all' : sets all types\n        - 'int_kind' : sets 'int'\n        - 'float_kind' : sets 'float' and 'longfloat'\n        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n        - 'str_kind' : sets 'str' and 'numpystr'\n    floatmode : str, optional\n        Controls the interpretation of the `precision` option for\n        floating-point types. Can take the following values\n        (default maxprec_equal):\n\n        * 'fixed': Always print exactly `precision` fractional digits,\n                even if this would print more or fewer digits than\n                necessary to specify the value uniquely.\n        * 'unique': Print the minimum number of fractional digits necessary\n                to represent each value uniquely. Different elements may\n                have a different number of digits. The value of the\n                `precision` option is ignored.\n        * 'maxprec': Print at most `precision` fractional digits, but if\n                an element can be uniquely represented with fewer digits\n                only print it with that many.\n        * 'maxprec_equal': Print at most `precision` fractional digits,\n                but if every element in the array can be uniquely\n                represented with an equal number of fewer digits, use that\n                many digits for all elements.\n    legacy : string or `False`, optional\n        If set to the string `'1.13'` enables 1.13 legacy printing mode. This\n        approximates numpy 1.13 print output by including a space in the sign\n        position of floats and different behavior for 0d arrays. If set to\n        `False`, disables legacy mode. Unrecognized strings will be ignored\n        with a warning for forward compatibility.\n\n        .. versionadded:: 1.14.0\n\n    See Also\n    --------\n    get_printoptions, printoptions, set_string_function, array2string\n\n    Notes\n    -----\n    `formatter` is always reset with a call to `set_printoptions`.\n\n    Use `printoptions` as a context manager to set the values temporarily.\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> np.set_printoptions(precision=4)\n    >>> np.array([1.123456789])\n    [1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> np.arange(10)\n    array([0, 1, 2, ..., 7, 8, 9])\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    A custom formatter can be used to display array elements as desired:\n\n    >>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n    >>> x = np.arange(3)\n    >>> x\n    array([int: 0, int: -1, int: -2])\n    >>> np.set_printoptions()  # formatter gets reset\n    >>> x\n    array([0, 1, 2])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3, infstr='inf',\n    ... linewidth=75, nanstr='nan', precision=8,\n    ... suppress=False, threshold=1000, formatter=None)\n\n    Also to temporarily override options, use `printoptions` as a context manager:\n\n    >>> with np.printoptions(precision=2, suppress=True, threshold=5):\n    ...     np.linspace(0, 10, 10)\n    array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ])\n\n    ","^0","^9"],["^ ","^7","pad","^8","\n    Pad an array.\n\n    Parameters\n    ----------\n    array : array_like of rank N\n        The array to pad.\n    pad_width : {sequence, array_like, int}\n        Number of values padded to the edges of each axis.\n        ((before_1, after_1), ... (before_N, after_N)) unique pad widths\n        for each axis.\n        ((before, after),) yields same before and after pad for each axis.\n        (pad,) or int is a shortcut for before = after = pad width for all\n        axes.\n    mode : str or function, optional\n        One of the following string values or a user supplied function.\n\n        'constant' (default)\n            Pads with a constant value.\n        'edge'\n            Pads with the edge values of array.\n        'linear_ramp'\n            Pads with the linear ramp between end_value and the\n            array edge value.\n        'maximum'\n            Pads with the maximum value of all or part of the\n            vector along each axis.\n        'mean'\n            Pads with the mean value of all or part of the\n            vector along each axis.\n        'median'\n            Pads with the median value of all or part of the\n            vector along each axis.\n        'minimum'\n            Pads with the minimum value of all or part of the\n            vector along each axis.\n        'reflect'\n            Pads with the reflection of the vector mirrored on\n            the first and last values of the vector along each\n            axis.\n        'symmetric'\n            Pads with the reflection of the vector mirrored\n            along the edge of the array.\n        'wrap'\n            Pads with the wrap of the vector along the axis.\n            The first values are used to pad the end and the\n            end values are used to pad the beginning.\n        'empty'\n            Pads with undefined values.\n\n            .. versionadded:: 1.17\n\n        <function>\n            Padding function, see Notes.\n    stat_length : sequence or int, optional\n        Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of\n        values at edge of each axis used to calculate the statistic value.\n\n        ((before_1, after_1), ... (before_N, after_N)) unique statistic\n        lengths for each axis.\n\n        ((before, after),) yields same before and after statistic lengths\n        for each axis.\n\n        (stat_length,) or int is a shortcut for before = after = statistic\n        length for all axes.\n\n        Default is ``None``, to use the entire axis.\n    constant_values : sequence or scalar, optional\n        Used in 'constant'.  The values to set the padded values for each\n        axis.\n\n        ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants\n        for each axis.\n\n        ``((before, after),)`` yields same before and after constants for each\n        axis.\n\n        ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for\n        all axes.\n\n        Default is 0.\n    end_values : sequence or scalar, optional\n        Used in 'linear_ramp'.  The values used for the ending value of the\n        linear_ramp and that will form the edge of the padded array.\n\n        ``((before_1, after_1), ... (before_N, after_N))`` unique end values\n        for each axis.\n\n        ``((before, after),)`` yields same before and after end values for each\n        axis.\n\n        ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for\n        all axes.\n\n        Default is 0.\n    reflect_type : {'even', 'odd'}, optional\n        Used in 'reflect', and 'symmetric'.  The 'even' style is the\n        default with an unaltered reflection around the edge value.  For\n        the 'odd' style, the extended part of the array is created by\n        subtracting the reflected values from two times the edge value.\n\n    Returns\n    -------\n    pad : ndarray\n        Padded array of rank equal to `array` with shape increased\n        according to `pad_width`.\n\n    Notes\n    -----\n    .. versionadded:: 1.7.0\n\n    For an array with rank greater than 1, some of the padding of later\n    axes is calculated from padding of previous axes.  This is easiest to\n    think about with a rank 2 array where the corners of the padded array\n    are calculated by using padded values from the first axis.\n\n    The padding function, if used, should modify a rank 1 array in-place. It\n    has the following signature::\n\n        padding_func(vector, iaxis_pad_width, iaxis, kwargs)\n\n    where\n\n        vector : ndarray\n            A rank 1 array already padded with zeros.  Padded values are\n            vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].\n        iaxis_pad_width : tuple\n            A 2-tuple of ints, iaxis_pad_width[0] represents the number of\n            values padded at the beginning of vector where\n            iaxis_pad_width[1] represents the number of values padded at\n            the end of vector.\n        iaxis : int\n            The axis currently being calculated.\n        kwargs : dict\n            Any keyword arguments the function requires.\n\n    Examples\n    --------\n    >>> a = [1, 2, 3, 4, 5]\n    >>> np.pad(a, (2, 3), 'constant', constant_values=(4, 6))\n    array([4, 4, 1, ..., 6, 6, 6])\n\n    >>> np.pad(a, (2, 3), 'edge')\n    array([1, 1, 1, ..., 5, 5, 5])\n\n    >>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))\n    array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])\n\n    >>> np.pad(a, (2,), 'maximum')\n    array([5, 5, 1, 2, 3, 4, 5, 5, 5])\n\n    >>> np.pad(a, (2,), 'mean')\n    array([3, 3, 1, 2, 3, 4, 5, 3, 3])\n\n    >>> np.pad(a, (2,), 'median')\n    array([3, 3, 1, 2, 3, 4, 5, 3, 3])\n\n    >>> a = [[1, 2], [3, 4]]\n    >>> np.pad(a, ((3, 2), (2, 3)), 'minimum')\n    array([[1, 1, 1, 2, 1, 1, 1],\n           [1, 1, 1, 2, 1, 1, 1],\n           [1, 1, 1, 2, 1, 1, 1],\n           [1, 1, 1, 2, 1, 1, 1],\n           [3, 3, 3, 4, 3, 3, 3],\n           [1, 1, 1, 2, 1, 1, 1],\n           [1, 1, 1, 2, 1, 1, 1]])\n\n    >>> a = [1, 2, 3, 4, 5]\n    >>> np.pad(a, (2, 3), 'reflect')\n    array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])\n\n    >>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')\n    array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])\n\n    >>> np.pad(a, (2, 3), 'symmetric')\n    array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])\n\n    >>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')\n    array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])\n\n    >>> np.pad(a, (2, 3), 'wrap')\n    array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])\n\n    >>> def pad_with(vector, pad_width, iaxis, kwargs):\n    ...     pad_value = kwargs.get('padder', 10)\n    ...     vector[:pad_width[0]] = pad_value\n    ...     vector[-pad_width[1]:] = pad_value\n    >>> a = np.arange(6)\n    >>> a = a.reshape((2, 3))\n    >>> np.pad(a, 2, pad_with)\n    array([[10, 10, 10, 10, 10, 10, 10],\n           [10, 10, 10, 10, 10, 10, 10],\n           [10, 10,  0,  1,  2, 10, 10],\n           [10, 10,  3,  4,  5, 10, 10],\n           [10, 10, 10, 10, 10, 10, 10],\n           [10, 10, 10, 10, 10, 10, 10]])\n    >>> np.pad(a, 2, pad_with, padder=100)\n    array([[100, 100, 100, 100, 100, 100, 100],\n           [100, 100, 100, 100, 100, 100, 100],\n           [100, 100,   0,   1,   2, 100, 100],\n           [100, 100,   3,   4,   5, 100, 100],\n           [100, 100, 100, 100, 100, 100, 100],\n           [100, 100, 100, 100, 100, 100, 100]])\n    ","^0","^9"],["^ ","^8",null,"^0","~:type-na-dict"],["^ ","^7","who","^8","\n    Print the NumPy arrays in the given dictionary.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    NumPy arrays in the globals() dictionary (all NumPy arrays in the\n    namespace).\n\n    Parameters\n    ----------\n    vardict : dict, optional\n        A dictionary possibly containing ndarrays.  Default is globals().\n\n    Returns\n    -------\n    out : None\n        Returns 'None'.\n\n    Notes\n    -----\n    Prints out the name, shape, bytes and type of all of the ndarrays\n    present in `vardict`.\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> b = np.ones(20)\n    >>> np.who()\n    Name            Shape            Bytes            Type\n    ===========================================================\n    a               10               80               int64\n    b               20               160              float64\n    Upper bound on total bytes  =       240\n\n    >>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n    ... 'idx':5}\n    >>> np.who(d)\n    Name            Shape            Bytes            Type\n    ===========================================================\n    x               2                16               float64\n    y               3                24               float64\n    Upper bound on total bytes  =       40\n\n    ","^0","^9"],["^ ","^7","histogram_bin_edges","^8","\n    Function to calculate only the edges of the bins used by the `histogram`\n    function.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data. The histogram is computed over the flattened array.\n    bins : int or sequence of scalars or str, optional\n        If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a\n        sequence, it defines the bin edges, including the rightmost\n        edge, allowing for non-uniform bin widths.\n\n        If `bins` is a string from the list below, `histogram_bin_edges` will use\n        the method chosen to calculate the optimal bin width and\n        consequently the number of bins (see `Notes` for more detail on\n        the estimators) from the data that falls within the requested\n        range. While the bin width will be optimal for the actual data\n        in the range, the number of bins will be computed to fill the\n        entire range, including the empty portions. For visualisation,\n        using the 'auto' option is suggested. Weighted data is not\n        supported for automated bin size selection.\n\n        'auto'\n            Maximum of the 'sturges' and 'fd' estimators. Provides good\n            all around performance.\n\n        'fd' (Freedman Diaconis Estimator)\n            Robust (resilient to outliers) estimator that takes into\n            account data variability and data size.\n\n        'doane'\n            An improved version of Sturges' estimator that works better\n            with non-normal datasets.\n\n        'scott'\n            Less robust estimator that that takes into account data\n            variability and data size.\n\n        'stone'\n            Estimator based on leave-one-out cross-validation estimate of\n            the integrated squared error. Can be regarded as a generalization\n            of Scott's rule.\n\n        'rice'\n            Estimator does not take variability into account, only data\n            size. Commonly overestimates number of bins required.\n\n        'sturges'\n            R's default method, only accounts for data size. Only\n            optimal for gaussian data and underestimates number of bins\n            for large non-gaussian datasets.\n\n        'sqrt'\n            Square root (of data size) estimator, used by Excel and\n            other programs for its speed and simplicity.\n\n    range : (float, float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored. The first element of the range must be less than or\n        equal to the second. `range` affects the automatic bin\n        computation as well. While bin width is computed to be optimal\n        based on the actual data within `range`, the bin count will fill\n        the entire range including portions containing no data.\n\n    weights : array_like, optional\n        An array of weights, of the same shape as `a`.  Each value in\n        `a` only contributes its associated weight towards the bin count\n        (instead of 1). This is currently not used by any of the bin estimators,\n        but may be in the future.\n\n    Returns\n    -------\n    bin_edges : array of dtype float\n        The edges to pass into `histogram`\n\n    See Also\n    --------\n    histogram\n\n    Notes\n    -----\n    The methods to estimate the optimal number of bins are well founded\n    in literature, and are inspired by the choices R provides for\n    histogram visualisation. Note that having the number of bins\n    proportional to :math:`n^{1/3}` is asymptotically optimal, which is\n    why it appears in most estimators. These are simply plug-in methods\n    that give good starting points for number of bins. In the equations\n    below, :math:`h` is the binwidth and :math:`n_h` is the number of\n    bins. All estimators that compute bin counts are recast to bin width\n    using the `ptp` of the data. The final bin count is obtained from\n    ``np.round(np.ceil(range / h))``.\n\n    'auto' (maximum of the 'sturges' and 'fd' estimators)\n        A compromise to get a good value. For small datasets the Sturges\n        value will usually be chosen, while larger datasets will usually\n        default to FD.  Avoids the overly conservative behaviour of FD\n        and Sturges for small and large datasets respectively.\n        Switchover point is usually :math:`a.size \\approx 1000`.\n\n    'fd' (Freedman Diaconis Estimator)\n        .. math:: h = 2 \\frac{IQR}{n^{1/3}}\n\n        The binwidth is proportional to the interquartile range (IQR)\n        and inversely proportional to cube root of a.size. Can be too\n        conservative for small datasets, but is quite good for large\n        datasets. The IQR is very robust to outliers.\n\n    'scott'\n        .. math:: h = \\sigma \\sqrt[3]{\\frac{24 * \\sqrt{\\pi}}{n}}\n\n        The binwidth is proportional to the standard deviation of the\n        data and inversely proportional to cube root of ``x.size``. Can\n        be too conservative for small datasets, but is quite good for\n        large datasets. The standard deviation is not very robust to\n        outliers. Values are very similar to the Freedman-Diaconis\n        estimator in the absence of outliers.\n\n    'rice'\n        .. math:: n_h = 2n^{1/3}\n\n        The number of bins is only proportional to cube root of\n        ``a.size``. It tends to overestimate the number of bins and it\n        does not take into account data variability.\n\n    'sturges'\n        .. math:: n_h = \\log _{2}n+1\n\n        The number of bins is the base 2 log of ``a.size``.  This\n        estimator assumes normality of data and is too conservative for\n        larger, non-normal datasets. This is the default method in R's\n        ``hist`` method.\n\n    'doane'\n        .. math:: n_h = 1 + \\log_{2}(n) +\n                        \\log_{2}(1 + \\frac{|g_1|}{\\sigma_{g_1}})\n\n            g_1 = mean[(\\frac{x - \\mu}{\\sigma})^3]\n\n            \\sigma_{g_1} = \\sqrt{\\frac{6(n - 2)}{(n + 1)(n + 3)}}\n\n        An improved version of Sturges' formula that produces better\n        estimates for non-normal datasets. This estimator attempts to\n        account for the skew of the data.\n\n    'sqrt'\n        .. math:: n_h = \\sqrt n\n\n        The simplest and fastest estimator. Only takes into account the\n        data size.\n\n    Examples\n    --------\n    >>> arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])\n    >>> np.histogram_bin_edges(arr, bins='auto', range=(0, 1))\n    array([0.  , 0.25, 0.5 , 0.75, 1.  ])\n    >>> np.histogram_bin_edges(arr, bins=2)\n    array([0. , 2.5, 5. ])\n\n    For consistency with histogram, an array of pre-computed bins is\n    passed through unmodified:\n\n    >>> np.histogram_bin_edges(arr, [1, 2])\n    array([1, 2])\n\n    This function allows one set of bins to be computed, and reused across\n    multiple histograms:\n\n    >>> shared_bins = np.histogram_bin_edges(arr, bins='auto')\n    >>> shared_bins\n    array([0., 1., 2., 3., 4., 5.])\n\n    >>> group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])\n    >>> hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)\n    >>> hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)\n\n    >>> hist_0; hist_1\n    array([1, 1, 0, 1, 0])\n    array([2, 0, 1, 1, 2])\n\n    Which gives more easily comparable results than using separate bins for\n    each histogram:\n\n    >>> hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')\n    >>> hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')\n    >>> hist_0; hist_1\n    array([1, 1, 1])\n    array([2, 1, 1, 2])\n    >>> bins_0; bins_1\n    array([0., 1., 2., 3.])\n    array([0.  , 1.25, 2.5 , 3.75, 5.  ])\n\n    ","^0","^9"],["^ ","^7","std","^8","\n    Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the\n    flattened array by default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of these values.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the standard deviation is computed. The\n        default is to compute the standard deviation of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a standard deviation is performed over\n        multiple axes, instead of a single axis or all the axes as before.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it is\n        the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the calculated\n        values) will be cast if necessary.\n    ddof : int, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of elements.\n        By default `ddof` is zero.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `std` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard deviation,\n        otherwise return a reference to the output array.\n\n    See Also\n    --------\n    var, mean, nanmean, nanstd, nanvar\n    ufuncs-output-type\n\n    Notes\n    -----\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.\n\n    The average squared deviation is normally calculated as\n    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,\n    the divisor ``N - ddof`` is used instead. In standard statistical\n    practice, ``ddof=1`` provides an unbiased estimator of the variance\n    of the infinite population. ``ddof=0`` provides a maximum likelihood\n    estimate of the variance for normally distributed variables. The\n    standard deviation computed in this function is the square root of\n    the estimated variance, so even with ``ddof=1``, it will not be an\n    unbiased estimate of the standard deviation per se.\n\n    Note that, for complex numbers, `std` takes the absolute\n    value before squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the *std* is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example below).\n    Specifying a higher-accuracy accumulator using the `dtype` keyword can\n    alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.std(a)\n    1.1180339887498949 # may vary\n    >>> np.std(a, axis=0)\n    array([1.,  1.])\n    >>> np.std(a, axis=1)\n    array([0.5,  0.5])\n\n    In single precision, std() can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.std(a)\n    0.45000005\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.std(a, dtype=np.float64)\n    0.44999999925494177 # may vary\n\n    ","^0","^9"],["^ ","^7","isneginf","^8","\n    Test element-wise for negative infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    out : array_like, optional\n        A boolean array with the same shape and type as `x` to store the\n        result.\n\n    Returns\n    -------\n    out : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `out` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, if first and second arguments have different shapes, or if the\n    first argument has complex values.\n\n    Examples\n    --------\n    >>> np.isneginf(np.NINF)\n    True\n    >>> np.isneginf(np.inf)\n    False\n    >>> np.isneginf(np.PINF)\n    False\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False])\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n\n    ","^0","^9"],["^ ","^7","fix","^8","\n    Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values are returned as floats.\n\n    Parameters\n    ----------\n    x : array_like\n        An array of floats to be rounded\n    y : ndarray, optional\n        Output array\n\n    Returns\n    -------\n    out : ndarray of floats\n        The array of rounded numbers\n\n    See Also\n    --------\n    trunc, floor, ceil\n    around : Round to given number of decimals\n\n    Examples\n    --------\n    >>> np.fix(3.14)\n    3.0\n    >>> np.fix(3)\n    3.0\n    >>> np.fix([2.1, 2.9, -2.1, -2.9])\n    array([ 2.,  2., -2., -2.])\n\n    ","^0","^9"],["^ ","^7","ones","^8","\n    Return a new array of given shape and type, filled with ones.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        The desired data-type for the array, e.g., `numpy.int8`.  Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: C\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n\n    Returns\n    -------\n    out : ndarray\n        Array of ones with the given shape, dtype, and order.\n\n    See Also\n    --------\n    ones_like : Return an array of ones with shape and type of input.\n    empty : Return a new uninitialized array.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n\n    Examples\n    --------\n    >>> np.ones(5)\n    array([1., 1., 1., 1., 1.])\n\n    >>> np.ones((5,), dtype=int)\n    array([1, 1, 1, 1, 1])\n\n    >>> np.ones((2, 1))\n    array([[1.],\n           [1.]])\n\n    >>> s = (2,2)\n    >>> np.ones(s)\n    array([[1.,  1.],\n           [1.,  1.]])\n\n    ","^0","^9"],["^ ","^7","squeeze","^8","\n    Remove single-dimensional entries from the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        .. versionadded:: 1.7.0\n\n        Selects a subset of the single-dimensional entries in the\n        shape. If an axis is selected with shape entry greater than\n        one, an error is raised.\n\n    Returns\n    -------\n    squeezed : ndarray\n        The input array, but with all or a subset of the\n        dimensions of length 1 removed. This is always `a` itself\n        or a view into `a`.\n\n    Raises\n    ------\n    ValueError\n        If `axis` is not None, and an axis being squeezed is not of length 1\n\n    See Also\n    --------\n    expand_dims : The inverse operation, adding singleton dimensions\n    reshape : Insert, remove, and combine dimensions, and resize existing ones\n\n    Examples\n    --------\n    >>> x = np.array([[[0], [1], [2]]])\n    >>> x.shape\n    (1, 3, 1)\n    >>> np.squeeze(x).shape\n    (3,)\n    >>> np.squeeze(x, axis=0).shape\n    (3, 1)\n    >>> np.squeeze(x, axis=1).shape\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot select an axis to squeeze out which has size not equal to one\n    >>> np.squeeze(x, axis=2).shape\n    (1, 3)\n\n    ","^0","^9"],["^ ","^7","format_parser","^8","\n    Class to convert formats, names, titles description to a dtype.\n\n    After constructing the format_parser object, the dtype attribute is\n    the converted data-type:\n    ``dtype = format_parser(formats, names, titles).dtype``\n\n    Attributes\n    ----------\n    dtype : dtype\n        The converted data-type.\n\n    Parameters\n    ----------\n    formats : str or list of str\n        The format description, either specified as a string with\n        comma-separated format descriptions in the form ``'f8, i4, a5'``, or\n        a list of format description strings  in the form\n        ``['f8', 'i4', 'a5']``.\n    names : str or list/tuple of str\n        The field names, either specified as a comma-separated string in the\n        form ``'col1, col2, col3'``, or as a list or tuple of strings in the\n        form ``['col1', 'col2', 'col3']``.\n        An empty list can be used, in that case default field names\n        ('f0', 'f1', ...) are used.\n    titles : sequence\n        Sequence of title strings. An empty list can be used to leave titles\n        out.\n    aligned : bool, optional\n        If True, align the fields by padding as the C-compiler would.\n        Default is False.\n    byteorder : str, optional\n        If specified, all the fields will be changed to the\n        provided byte-order.  Otherwise, the default byte-order is\n        used. For all available string specifiers, see `dtype.newbyteorder`.\n\n    See Also\n    --------\n    dtype, typename, sctype2char\n\n    Examples\n    --------\n    >>> np.format_parser(['<f8', '<i4', '<a5'], ['col1', 'col2', 'col3'],\n    ...                  ['T1', 'T2', 'T3']).dtype\n    dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'), (('T3', 'col3'), 'S5')])\n\n    `names` and/or `titles` can be empty lists. If `titles` is an empty list,\n    titles will simply not appear. If `names` is empty, default field names\n    will be used.\n\n    >>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],\n    ...                  []).dtype\n    dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '<S5')])\n    >>> np.format_parser(['<f8', '<i4', '<a5'], [], []).dtype\n    dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', 'S5')])\n\n    ","^0","^0"],["^ ","^7","add_newdoc","^8","\n    Add documentation to an existing object, typically one defined in C\n\n    The purpose is to allow easier editing of the docstrings without requiring\n    a re-compile. This exists primarily for internal use within numpy itself.\n\n    Parameters\n    ----------\n    place : str\n        The absolute name of the module to import from\n    obj : str\n        The name of the object to add documentation to, typically a class or\n        function name\n    doc : {str, Tuple[str, str], List[Tuple[str, str]]}\n        If a string, the documentation to apply to `obj`\n\n        If a tuple, then the first element is interpreted as an attribute of\n        `obj` and the second as the docstring to apply - ``(method, docstring)``\n\n        If a list, then each element of the list should be a tuple of length\n        two - ``[(method1, docstring1), (method2, docstring2), ...]``\n    warn_on_python : bool\n        If True, the default, emit `UserWarning` if this is used to attach\n        documentation to a pure-python object.\n\n    Notes\n    -----\n    This routine never raises an error if the docstring can't be written, but\n    will raise an error if the object being documented does not exist.\n\n    This routine cannot modify read-only docstrings, as appear\n    in new-style classes or built-in functions. Because this\n    routine never raises an error the caller must check manually\n    that the docstrings were changed.\n\n    Since this function grabs the ``char *`` from a c-level str object and puts\n    it into the ``tp_doc`` slot of the type of `obj`, it violates a number of\n    C-API best-practices, by:\n\n    - modifying a `PyTypeObject` after calling `PyType_Ready`\n    - calling `Py_INCREF` on the str and losing the reference, so the str\n      will never be released\n\n    If possible it should be avoided.\n    ","^0","^9"],["^ ","^8",null,"^0","~:feature"],["^ ","^7","numpy.matrixlib","^8","Sub-package containing the matrix class and related functions.\n\n","^0","^>"],["^ ","^7","float32","^8","Single-precision floating-point number type, compatible with C ``float``.\n    Character code: ``'f'``.\n    Canonical name: ``np.single``.\n    Alias *on this platform*: ``np.float32``: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.","^0","^0"],["^ ","^7","gradient","^8","\n    Return the gradient of an N-dimensional array.\n\n    The gradient is computed using second order accurate central differences\n    in the interior points and either first or second order accurate one-sides\n    (forward or backwards) differences at the boundaries.\n    The returned gradient hence has the same shape as the input array.\n\n    Parameters\n    ----------\n    f : array_like\n        An N-dimensional array containing samples of a scalar function.\n    varargs : list of scalar or array, optional\n        Spacing between f values. Default unitary spacing for all dimensions.\n        Spacing can be specified using:\n\n        1. single scalar to specify a sample distance for all dimensions.\n        2. N scalars to specify a constant sample distance for each dimension.\n           i.e. `dx`, `dy`, `dz`, ...\n        3. N arrays to specify the coordinates of the values along each\n           dimension of F. The length of the array must match the size of\n           the corresponding dimension\n        4. Any combination of N scalars/arrays with the meaning of 2. and 3.\n\n        If `axis` is given, the number of varargs must equal the number of axes.\n        Default: 1.\n\n    edge_order : {1, 2}, optional\n        Gradient is calculated using N-th order accurate differences\n        at the boundaries. Default: 1.\n\n        .. versionadded:: 1.9.1\n\n    axis : None or int or tuple of ints, optional\n        Gradient is calculated only along the given axis or axes\n        The default (axis = None) is to calculate the gradient for all the axes\n        of the input array. axis may be negative, in which case it counts from\n        the last to the first axis.\n\n        .. versionadded:: 1.11.0\n\n    Returns\n    -------\n    gradient : ndarray or list of ndarray\n        A set of ndarrays (or a single ndarray if there is only one dimension)\n        corresponding to the derivatives of f with respect to each dimension.\n        Each derivative has the same shape as f.\n\n    Examples\n    --------\n    >>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)\n    >>> np.gradient(f)\n    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])\n    >>> np.gradient(f, 2)\n    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n    Spacing can be also specified with an array that represents the coordinates\n    of the values F along the dimensions.\n    For instance a uniform spacing:\n\n    >>> x = np.arange(f.size)\n    >>> np.gradient(f, x)\n    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n\n    Or a non uniform one:\n\n    >>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)\n    >>> np.gradient(f, x)\n    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])\n\n    For two dimensional arrays, the return will be two arrays ordered by\n    axis. In this example the first array stands for the gradient in\n    rows and the second one in columns direction:\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))\n    [array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],\n           [1. , 1. , 1. ]])]\n\n    In this example the spacing is also specified:\n    uniform for axis=0 and non uniform for axis=1\n\n    >>> dx = 2.\n    >>> y = [1., 1.5, 3.5]\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)\n    [array([[ 1. ,  1. , -0.5],\n           [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],\n           [2. , 1.7, 0.5]])]\n\n    It is possible to specify how boundaries are treated using `edge_order`\n\n    >>> x = np.array([0, 1, 2, 3, 4])\n    >>> f = x**2\n    >>> np.gradient(f, edge_order=1)\n    array([1.,  2.,  4.,  6.,  7.])\n    >>> np.gradient(f, edge_order=2)\n    array([0., 2., 4., 6., 8.])\n\n    The `axis` keyword can be used to specify a subset of axes of which the\n    gradient is calculated\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)\n    array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]])\n\n    Notes\n    -----\n    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous\n    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we\n    minimize the \"consistency error\" :math:`\\eta_{i}` between the true gradient\n    and its estimate from a linear combination of the neighboring grid-points:\n\n    .. math::\n\n        \\eta_{i} = f_{i}^{\\left(1\\right)} -\n                    \\left[ \\alpha f\\left(x_{i}\\right) +\n                            \\beta f\\left(x_{i} + h_{d}\\right) +\n                            \\gamma f\\left(x_{i}-h_{s}\\right)\n                    \\right]\n\n    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`\n    with their Taylor series expansion, this translates into solving\n    the following the linear system:\n\n    .. math::\n\n        \\left\\{\n            \\begin{array}{r}\n                \\alpha+\\beta+\\gamma=0 \\\\\n                \\beta h_{d}-\\gamma h_{s}=1 \\\\\n                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0\n            \\end{array}\n        \\right.\n\n    The resulting approximation of :math:`f_{i}^{(1)}` is the following:\n\n    .. math::\n\n        \\hat f_{i}^{(1)} =\n            \\frac{\n                h_{s}^{2}f\\left(x_{i} + h_{d}\\right)\n                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)\n                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}\n                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}\n            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}\n                                + h_{s}h_{d}^{2}}{h_{d}\n                                + h_{s}}\\right)\n\n    It is worth noting that if :math:`h_{s}=h_{d}`\n    (i.e., data are evenly spaced)\n    we find the standard second order approximation:\n\n    .. math::\n\n        \\hat f_{i}^{(1)}=\n            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}\n            + \\mathcal{O}\\left(h^{2}\\right)\n\n    With a similar procedure the forward/backward approximations used for\n    boundaries can be derived.\n\n    References\n    ----------\n    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics\n            (Texts in Applied Mathematics). New York: Springer.\n    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations\n            in Geophysical Fluid Dynamics. New York: Springer.\n    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on\n            Arbitrarily Spaced Grids,\n            Mathematics of Computation 51, no. 184 : 699-706.\n            `PDF <http://www.ams.org/journals/mcom/1988-51-184/\n            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.\n    ","^0","^9"],["^ ","^7","obj2sctype","^8","\n    Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\n    Examples\n    --------\n    >>> np.obj2sctype(np.int32)\n    <class 'numpy.int32'>\n    >>> np.obj2sctype(np.array([1., 2.]))\n    <class 'numpy.float64'>\n    >>> np.obj2sctype(np.array([1.j]))\n    <class 'numpy.complex128'>\n\n    >>> np.obj2sctype(dict)\n    <class 'numpy.object_'>\n    >>> np.obj2sctype('string')\n\n    >>> np.obj2sctype(1, default=list)\n    <class 'list'>\n\n    ","^0","^9"],["^ ","^8","\n    Base object for a dictionary for look-up with any alias for an array dtype.\n\n    Instances of `_typedict` can not be used as dictionaries directly,\n    first they have to be populated.\n\n    ","^0","~:typedict"],["^ ","^7","find_common_type","^8","\n    Determine common type following standard coercion rules.\n\n    Parameters\n    ----------\n    array_types : sequence\n        A list of dtypes or dtype convertible objects representing arrays.\n    scalar_types : sequence\n        A list of dtypes or dtype convertible objects representing scalars.\n\n    Returns\n    -------\n    datatype : dtype\n        The common data type, which is the maximum of `array_types` ignoring\n        `scalar_types`, unless the maximum of `scalar_types` is of a\n        different kind (`dtype.kind`). If the kind is not understood, then\n        None is returned.\n\n    See Also\n    --------\n    dtype, common_type, can_cast, mintypecode\n\n    Examples\n    --------\n    >>> np.find_common_type([], [np.int64, np.float32, complex])\n    dtype('complex128')\n    >>> np.find_common_type([np.int64, np.float32], [])\n    dtype('float64')\n\n    The standard casting rules ensure that a scalar cannot up-cast an\n    array unless the scalar is of a fundamentally different kind of data\n    (i.e. under a different hierarchy in the data type hierarchy) then\n    the array:\n\n    >>> np.find_common_type([np.float32], [np.int64, np.float64])\n    dtype('float32')\n\n    Complex is of a different type, so it up-casts the float in the\n    `array_types` argument:\n\n    >>> np.find_common_type([np.float32], [complex])\n    dtype('complex128')\n\n    Type specifier strings are convertible to dtypes and can therefore\n    be used instead of dtypes:\n\n    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\n    dtype('complex128')\n\n    ","^0","^9"],["^ ","^7","intp","^8","Signed integer type, compatible with Python `int` anc C ``long``.\n    Character code: ``'l'``.\n    Canonical name: ``np.int_``.\n    Alias *on this platform*: ``np.int64``: 64-bit signed integer (-9223372036854775808 to 9223372036854775807).\n    Alias *on this platform*: ``np.intp``: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.","^0","^0"],["^ ","^7","poly","^8","\n    Find the coefficients of a polynomial with the given sequence of roots.\n\n    Returns the coefficients of the polynomial whose leading coefficient\n    is one for the given sequence of zeros (multiple roots must be included\n    in the sequence as many times as their multiplicity; see Examples).\n    A square matrix (or array, which will be treated as a matrix) can also\n    be given, in which case the coefficients of the characteristic polynomial\n    of the matrix are returned.\n\n    Parameters\n    ----------\n    seq_of_zeros : array_like, shape (N,) or (N, N)\n        A sequence of polynomial roots, or a square array or matrix object.\n\n    Returns\n    -------\n    c : ndarray\n        1D array of polynomial coefficients from highest to lowest degree:\n\n        ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``\n        where c[0] always equals 1.\n\n    Raises\n    ------\n    ValueError\n        If input is the wrong shape (the input must be a 1-D or square\n        2-D array).\n\n    See Also\n    --------\n    polyval : Compute polynomial values.\n    roots : Return the roots of a polynomial.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    Specifying the roots of a polynomial still leaves one degree of\n    freedom, typically represented by an undetermined leading\n    coefficient. [1]_ In the case of this function, that coefficient -\n    the first one in the returned array - is always taken as one. (If\n    for some reason you have one other point, the only automatic way\n    presently to leverage that information is to use ``polyfit``.)\n\n    The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`\n    matrix **A** is given by\n\n        :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,\n\n    where **I** is the `n`-by-`n` identity matrix. [2]_\n\n    References\n    ----------\n    .. [1] M. Sullivan and M. Sullivan, III, \"Algebra and Trignometry,\n       Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n    .. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n       Academic Press, pg. 182, 1980.\n\n    Examples\n    --------\n    Given a sequence of a polynomial's zeros:\n\n    >>> np.poly((0, 0, 0)) # Multiple root example\n    array([1., 0., 0., 0.])\n\n    The line above represents z**3 + 0*z**2 + 0*z + 0.\n\n    >>> np.poly((-1./2, 0, 1./2))\n    array([ 1.  ,  0.  , -0.25,  0.  ])\n\n    The line above represents z**3 - z/4\n\n    >>> np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))\n    array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random\n\n    Given a square array object:\n\n    >>> P = np.array([[0, 1./3], [-1./2, 0]])\n    >>> np.poly(P)\n    array([1.        , 0.        , 0.16666667])\n\n    Note how in all cases the leading coefficient is always 1.\n\n    ","^0","^9"],["^ ","^7","maximum_sctype","^8","\n    Return the scalar type of highest precision of the same kind as the input.\n\n    Parameters\n    ----------\n    t : dtype or dtype specifier\n        The input data type. This can be a `dtype` object or an object that\n        is convertible to a `dtype`.\n\n    Returns\n    -------\n    out : dtype\n        The highest precision data type of the same kind (`dtype.kind`) as `t`.\n\n    See Also\n    --------\n    obj2sctype, mintypecode, sctype2char\n    dtype\n\n    Examples\n    --------\n    >>> np.maximum_sctype(int)\n    <class 'numpy.int64'>\n    >>> np.maximum_sctype(np.uint8)\n    <class 'numpy.uint64'>\n    >>> np.maximum_sctype(complex)\n    <class 'numpy.complex256'> # may vary\n\n    >>> np.maximum_sctype(str)\n    <class 'numpy.str_'>\n\n    >>> np.maximum_sctype('i2')\n    <class 'numpy.int64'>\n    >>> np.maximum_sctype('f4')\n    <class 'numpy.float128'> # may vary\n\n    ","^0","^9"],["^ ","^7","bmat","^8","\n    Build a matrix object from a string, nested sequence, or array.\n\n    Parameters\n    ----------\n    obj : str or array_like\n        Input data. If a string, variables in the current scope may be\n        referenced by name.\n    ldict : dict, optional\n        A dictionary that replaces local operands in current frame.\n        Ignored if `obj` is not a string or `gdict` is None.\n    gdict : dict, optional\n        A dictionary that replaces global operands in current frame.\n        Ignored if `obj` is not a string.\n\n    Returns\n    -------\n    out : matrix\n        Returns a matrix object, which is a specialized 2-D array.\n\n    See Also\n    --------\n    block :\n        A generalization of this function for N-d arrays, that returns normal\n        ndarrays.\n\n    Examples\n    --------\n    >>> A = np.mat('1 1; 1 1')\n    >>> B = np.mat('2 2; 2 2')\n    >>> C = np.mat('3 4; 5 6')\n    >>> D = np.mat('7 8; 9 0')\n\n    All the following expressions construct the same block matrix:\n\n    >>> np.bmat([[A, B], [C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat('A,B; C,D')\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n\n    ","^0","^9"],["^ ","^7","put_along_axis","^8","\n    Put values into the destination array by matching 1d index and data slices.\n\n    This iterates over matching 1d slices oriented along the specified axis in\n    the index and data arrays, and uses the former to place values into the\n    latter. These slices can be different lengths.\n\n    Functions returning an index along an axis, like `argsort` and\n    `argpartition`, produce suitable indices for this function.\n\n    .. versionadded:: 1.15.0\n\n    Parameters\n    ----------\n    arr: ndarray (Ni..., M, Nk...)\n        Destination array.\n    indices: ndarray (Ni..., J, Nk...)\n        Indices to change along each 1d slice of `arr`. This must match the\n        dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast\n        against `arr`.\n    values: array_like (Ni..., J, Nk...)\n        values to insert at those indices. Its shape and dimension are\n        broadcast to match that of `indices`.\n    axis: int\n        The axis to take 1d slices along. If axis is None, the destination\n        array is treated as if a flattened 1d view had been created of it.\n\n    Notes\n    -----\n    This is equivalent to (but faster than) the following use of `ndindex` and\n    `s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::\n\n        Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]\n        J = indices.shape[axis]  # Need not equal M\n\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                a_1d       = a      [ii + s_[:,] + kk]\n                indices_1d = indices[ii + s_[:,] + kk]\n                values_1d  = values [ii + s_[:,] + kk]\n                for j in range(J):\n                    a_1d[indices_1d[j]] = values_1d[j]\n\n    Equivalently, eliminating the inner loop, the last two lines would be::\n\n                a_1d[indices_1d] = values_1d\n\n    See Also\n    --------\n    take_along_axis :\n        Take values from the input array by matching 1d index and data slices\n\n    Examples\n    --------\n\n    For this sample array\n\n    >>> a = np.array([[10, 30, 20], [60, 40, 50]])\n\n    We can replace the maximum values with:\n\n    >>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n    >>> ai\n    array([[1],\n           [0]])\n    >>> np.put_along_axis(a, ai, 99, axis=1)\n    >>> a\n    array([[10, 99, 20],\n           [99, 40, 50]])\n\n    ","^0","^9"],["^ ","^7","logical_or","^8","logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 OR x2 element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Logical OR is applied to the elements of `x1` and `x2`.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    Boolean result of the logical OR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_and, logical_not, logical_xor\nbitwise_or\n\nExamples\n--------\n>>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_or(x < 1, x > 3)\narray([ True, False, False, False,  True])","^0","^;"],["^ ","^7","void","^8",null,"^0","^0"],["^ ","^8","","^0","^:"],["^ ","^7","positive","^8","positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNumerical positive, element-wise.\n\n.. versionadded:: 1.13.0\n\nParameters\n----------\nx : array_like or scalar\n    Input array.\n\nReturns\n-------\ny : ndarray or scalar\n    Returned array or scalar: `y = +x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nEquivalent to `x.copy()`, but only defined for types that support\narithmetic.","^0","^;"],["^ ","^8","","^0","^:"],["^ ","^7","nditer","^8","Efficient multi-dimensional iterator object to iterate over arrays.\n    To get started using this object, see the\n    :ref:`introductory guide to array iteration <arrays.nditer>`.\n\n    Parameters\n    ----------\n    op : ndarray or sequence of array_like\n        The array(s) to iterate over.\n\n    flags : sequence of str, optional\n          Flags to control the behavior of the iterator.\n\n          * ``buffered`` enables buffering when required.\n          * ``c_index`` causes a C-order index to be tracked.\n          * ``f_index`` causes a Fortran-order index to be tracked.\n          * ``multi_index`` causes a multi-index, or a tuple of indices\n            with one per iteration dimension, to be tracked.\n          * ``common_dtype`` causes all the operands to be converted to\n            a common data type, with copying or buffering as necessary.\n          * ``copy_if_overlap`` causes the iterator to determine if read\n            operands have overlap with write operands, and make temporary\n            copies as necessary to avoid overlap. False positives (needless\n            copying) are possible in some cases.\n          * ``delay_bufalloc`` delays allocation of the buffers until\n            a reset() call is made. Allows ``allocate`` operands to\n            be initialized before their values are copied into the buffers.\n          * ``external_loop`` causes the ``values`` given to be\n            one-dimensional arrays with multiple values instead of\n            zero-dimensional arrays.\n          * ``grow_inner`` allows the ``value`` array sizes to be made\n            larger than the buffer size when both ``buffered`` and\n            ``external_loop`` is used.\n          * ``ranged`` allows the iterator to be restricted to a sub-range\n            of the iterindex values.\n          * ``refs_ok`` enables iteration of reference types, such as\n            object arrays.\n          * ``reduce_ok`` enables iteration of ``readwrite`` operands\n            which are broadcasted, also known as reduction operands.\n          * ``zerosize_ok`` allows `itersize` to be zero.\n    op_flags : list of list of str, optional\n          This is a list of flags for each operand. At minimum, one of\n          ``readonly``, ``readwrite``, or ``writeonly`` must be specified.\n\n          * ``readonly`` indicates the operand will only be read from.\n          * ``readwrite`` indicates the operand will be read from and written to.\n          * ``writeonly`` indicates the operand will only be written to.\n          * ``no_broadcast`` prevents the operand from being broadcasted.\n          * ``contig`` forces the operand data to be contiguous.\n          * ``aligned`` forces the operand data to be aligned.\n          * ``nbo`` forces the operand data to be in native byte order.\n          * ``copy`` allows a temporary read-only copy if required.\n          * ``updateifcopy`` allows a temporary read-write copy if required.\n          * ``allocate`` causes the array to be allocated if it is None\n            in the ``op`` parameter.\n          * ``no_subtype`` prevents an ``allocate`` operand from using a subtype.\n          * ``arraymask`` indicates that this operand is the mask to use\n            for selecting elements when writing to operands with the\n            'writemasked' flag set. The iterator does not enforce this,\n            but when writing from a buffer back to the array, it only\n            copies those elements indicated by this mask.\n          * ``writemasked`` indicates that only elements where the chosen\n            ``arraymask`` operand is True will be written to.\n          * ``overlap_assume_elementwise`` can be used to mark operands that are\n            accessed only in the iterator order, to allow less conservative\n            copying when ``copy_if_overlap`` is present.\n    op_dtypes : dtype or tuple of dtype(s), optional\n        The required data type(s) of the operands. If copying or buffering\n        is enabled, the data will be converted to/from their original types.\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the iteration order. 'C' means C order, 'F' means\n        Fortran order, 'A' means 'F' order if all the arrays are Fortran\n        contiguous, 'C' order otherwise, and 'K' means as close to the\n        order the array elements appear in memory as possible. This also\n        affects the element memory order of ``allocate`` operands, as they\n        are allocated to be compatible with iteration order.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur when making a copy\n        or buffering.  Setting this to 'unsafe' is not recommended,\n        as it can adversely affect accumulations.\n\n        * 'no' means the data types should not be cast at all.\n        * 'equiv' means only byte-order changes are allowed.\n        * 'safe' means only casts which can preserve values are allowed.\n        * 'same_kind' means only safe casts or casts within a kind,\n          like float64 to float32, are allowed.\n        * 'unsafe' means any data conversions may be done.\n    op_axes : list of list of ints, optional\n        If provided, is a list of ints or None for each operands.\n        The list of axes for an operand is a mapping from the dimensions\n        of the iterator to the dimensions of the operand. A value of\n        -1 can be placed for entries, causing that dimension to be\n        treated as `newaxis`.\n    itershape : tuple of ints, optional\n        The desired shape of the iterator. This allows ``allocate`` operands\n        with a dimension mapped by op_axes not corresponding to a dimension\n        of a different operand to get a value not equal to 1 for that\n        dimension.\n    buffersize : int, optional\n        When buffering is enabled, controls the size of the temporary\n        buffers. Set to 0 for the default value.\n\n    Attributes\n    ----------\n    dtypes : tuple of dtype(s)\n        The data types of the values provided in `value`. This may be\n        different from the operand data types if buffering is enabled.\n        Valid only before the iterator is closed.\n    finished : bool\n        Whether the iteration over the operands is finished or not.\n    has_delayed_bufalloc : bool\n        If True, the iterator was created with the ``delay_bufalloc`` flag,\n        and no reset() function was called on it yet.\n    has_index : bool\n        If True, the iterator was created with either the ``c_index`` or\n        the ``f_index`` flag, and the property `index` can be used to\n        retrieve it.\n    has_multi_index : bool\n        If True, the iterator was created with the ``multi_index`` flag,\n        and the property `multi_index` can be used to retrieve it.\n    index\n        When the ``c_index`` or ``f_index`` flag was used, this property\n        provides access to the index. Raises a ValueError if accessed\n        and ``has_index`` is False.\n    iterationneedsapi : bool\n        Whether iteration requires access to the Python API, for example\n        if one of the operands is an object array.\n    iterindex : int\n        An index which matches the order of iteration.\n    itersize : int\n        Size of the iterator.\n    itviews\n        Structured view(s) of `operands` in memory, matching the reordered\n        and optimized iterator access pattern. Valid only before the iterator\n        is closed.\n    multi_index\n        When the ``multi_index`` flag was used, this property\n        provides access to the index. Raises a ValueError if accessed\n        accessed and ``has_multi_index`` is False.\n    ndim : int\n        The dimensions of the iterator.\n    nop : int\n        The number of iterator operands.\n    operands : tuple of operand(s)\n        The array(s) to be iterated over. Valid only before the iterator is\n        closed.\n    shape : tuple of ints\n        Shape tuple, the shape of the iterator.\n    value\n        Value of ``operands`` at current iteration. Normally, this is a\n        tuple of array scalars, but if the flag ``external_loop`` is used,\n        it is a tuple of one dimensional arrays.\n\n    Notes\n    -----\n    `nditer` supersedes `flatiter`.  The iterator implementation behind\n    `nditer` is also exposed by the NumPy C API.\n\n    The Python exposure supplies two iteration interfaces, one which follows\n    the Python iterator protocol, and another which mirrors the C-style\n    do-while pattern.  The native Python approach is better in most cases, but\n    if you need the coordinates or index of an iterator, use the C-style pattern.\n\n    Examples\n    --------\n    Here is how we might write an ``iter_add`` function, using the\n    Python iterator protocol:\n\n    >>> def iter_add_py(x, y, out=None):\n    ...     addop = np.add\n    ...     it = np.nditer([x, y, out], [],\n    ...                 [['readonly'], ['readonly'], ['writeonly','allocate']])\n    ...     with it:\n    ...         for (a, b, c) in it:\n    ...             addop(a, b, out=c)\n    ...     return it.operands[2]\n\n    Here is the same function, but following the C-style pattern:\n\n    >>> def iter_add(x, y, out=None):\n    ...    addop = np.add\n    ...    it = np.nditer([x, y, out], [],\n    ...                [['readonly'], ['readonly'], ['writeonly','allocate']])\n    ...    with it:\n    ...        while not it.finished:\n    ...            addop(it[0], it[1], out=it[2])\n    ...            it.iternext()\n    ...        return it.operands[2]\n\n    Here is an example outer product function:\n\n    >>> def outer_it(x, y, out=None):\n    ...     mulop = np.multiply\n    ...     it = np.nditer([x, y, out], ['external_loop'],\n    ...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n    ...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n    ...                      [-1] * x.ndim + list(range(y.ndim)),\n    ...                      None])\n    ...     with it:\n    ...         for (a, b, c) in it:\n    ...             mulop(a, b, out=c)\n    ...         return it.operands[2]\n\n    >>> a = np.arange(2)+1\n    >>> b = np.arange(3)+1\n    >>> outer_it(a,b)\n    array([[1, 2, 3],\n           [2, 4, 6]])\n\n    Here is an example function which operates like a \"lambda\" ufunc:\n\n    >>> def luf(lamdaexpr, *args, **kwargs):\n    ...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''\n    ...    nargs = len(args)\n    ...    op = (kwargs.get('out',None),) + args\n    ...    it = np.nditer(op, ['buffered','external_loop'],\n    ...            [['writeonly','allocate','no_broadcast']] +\n    ...                            [['readonly','nbo','aligned']]*nargs,\n    ...            order=kwargs.get('order','K'),\n    ...            casting=kwargs.get('casting','safe'),\n    ...            buffersize=kwargs.get('buffersize',0))\n    ...    while not it.finished:\n    ...        it[0] = lamdaexpr(*it[1:])\n    ...        it.iternext()\n    ...        return it.operands[0]\n\n    >>> a = np.arange(5)\n    >>> b = np.ones(5)\n    >>> luf(lambda i,j:i*i + j/2, a, b)\n    array([  0.5,   1.5,   4.5,   9.5,  16.5])\n\n    If operand flags `\"writeonly\"` or `\"readwrite\"` are used the\n    operands may be views into the original data with the\n    `WRITEBACKIFCOPY` flag. In this case `nditer` must be used as a\n    context manager or the `nditer.close` method must be called before\n    using the result. The temporary data will be written back to the\n    original data when the `__exit__` function is called but not before:\n\n    >>> a = np.arange(6, dtype='i4')[::-2]\n    >>> with np.nditer(a, [],\n    ...        [['writeonly', 'updateifcopy']],\n    ...        casting='unsafe',\n    ...        op_dtypes=[np.dtype('f4')]) as i:\n    ...    x = i.operands[0]\n    ...    x[:] = [-1, -2, -3]\n    ...    # a still unchanged here\n    >>> a, x\n    (array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))\n\n    It is important to note that once the iterator is exited, dangling\n    references (like `x` in the example) may or may not share data with\n    the original data `a`. If writeback semantics were active, i.e. if\n    `x.base.flags.writebackifcopy` is `True`, then exiting the iterator\n    will sever the connection between `x` and `a`, writing to `x` will\n    no longer write to `a`. If writeback semantics are not active, then\n    `x.data` will still point at some part of `a.data`, and writing to\n    one will affect the other.\n\n    Context management and the `close` method appeared in version 1.15.0.","^0","^0"],["^ ","^7","nansum","^8","\n    Return the sum of array elements over a given axis treating Not a\n    Numbers (NaNs) as zero.\n\n    In NumPy versions <= 1.9.0 Nan is returned for slices that are all-NaN or\n    empty. In later versions zero is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose sum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the sum is computed. The default is to compute the\n        sum of the flattened array.\n    dtype : data-type, optional\n        The type of the returned array and of the accumulator in which the\n        elements are summed.  By default, the dtype of `a` is used.  An\n        exception is when `a` has an integer type with less precision than\n        the platform (u)intp. In that case, the default will be either\n        (u)int32 or (u)int64 depending on whether the platform is 32 or 64\n        bits. For inexact inputs, dtype must be inexact.\n\n        .. versionadded:: 1.8.0\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``. If provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.  See\n        `ufuncs-output-type` for more details. The casting of NaN to integer\n        can yield unexpected results.\n\n        .. versionadded:: 1.8.0\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `mean` or `sum` methods\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n        .. versionadded:: 1.8.0\n\n    Returns\n    -------\n    nansum : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which it is returned. The result has the same\n        size as `a`, and the same shape as `a` if `axis` is not None\n        or `a` is a 1-d array.\n\n    See Also\n    --------\n    numpy.sum : Sum across array propagating NaNs.\n    isnan : Show which elements are NaN.\n    isfinite: Show which elements are not NaN or +/-inf.\n\n    Notes\n    -----\n    If both positive and negative infinity are present, the sum will be Not\n    A Number (NaN).\n\n    Examples\n    --------\n    >>> np.nansum(1)\n    1\n    >>> np.nansum([1])\n    1\n    >>> np.nansum([1, np.nan])\n    1.0\n    >>> a = np.array([[1, 1], [1, np.nan]])\n    >>> np.nansum(a)\n    3.0\n    >>> np.nansum(a, axis=0)\n    array([2.,  1.])\n    >>> np.nansum([1, np.nan, np.inf])\n    inf\n    >>> np.nansum([1, np.nan, np.NINF])\n    -inf\n    >>> from numpy.testing import suppress_warnings\n    >>> with suppress_warnings() as sup:\n    ...     sup.filter(RuntimeWarning)\n    ...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present\n    nan\n\n    ","^0","^9"],["^ ","^7","nanprod","^8","\n    Return the product of array elements over a given axis treating Not a\n    Numbers (NaNs) as ones.\n\n    One is returned for slices that are all-NaN or empty.\n\n    .. versionadded:: 1.10.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose product is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the product is computed. The default is to compute\n        the product of the flattened array.\n    dtype : data-type, optional\n        The type of the returned array and of the accumulator in which the\n        elements are summed.  By default, the dtype of `a` is used.  An\n        exception is when `a` has an integer type with less precision than\n        the platform (u)intp. In that case, the default will be either\n        (u)int32 or (u)int64 depending on whether the platform is 32 or 64\n        bits. For inexact inputs, dtype must be inexact.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``. If provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        `ufuncs-output-type` for more details. The casting of NaN to integer\n        can yield unexpected results.\n    keepdims : bool, optional\n        If True, the axes which are reduced are left in the result as\n        dimensions with size one. With this option, the result will\n        broadcast correctly against the original `arr`.\n\n    Returns\n    -------\n    nanprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case it is returned.\n\n    See Also\n    --------\n    numpy.prod : Product across array propagating NaNs.\n    isnan : Show which elements are NaN.\n\n    Examples\n    --------\n    >>> np.nanprod(1)\n    1\n    >>> np.nanprod([1])\n    1\n    >>> np.nanprod([1, np.nan])\n    1.0\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanprod(a)\n    6.0\n    >>> np.nanprod(a, axis=0)\n    array([3., 2.])\n\n    ","^0","^9"],["^ ","^7","setxor1d","^8","\n    Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    setxor1d : ndarray\n        Sorted 1D array of unique values that are in only one of the input\n        arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4])\n    >>> b = np.array([2, 3, 5, 7, 5])\n    >>> np.setxor1d(a,b)\n    array([1, 4, 5, 7])\n\n    ","^0","^9"],["^ ","^7","copy","^8","\n    Return an array copy of the given object.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the memory layout of the copy. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible. (Note that this function and :meth:`ndarray.copy` are very\n        similar, but have different default values for their order=\n        arguments.)\n\n    Returns\n    -------\n    arr : ndarray\n        Array interpretation of `a`.\n\n    Notes\n    -----\n    This is equivalent to:\n\n    >>> np.array(a, copy=True)  #doctest: +SKIP\n\n    Examples\n    --------\n    Create an array x, with a reference y and a copy z:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = x\n    >>> z = np.copy(x)\n\n    Note that, when we modify x, y changes, but not z:\n\n    >>> x[0] = 10\n    >>> x[0] == y[0]\n    True\n    >>> x[0] == z[0]\n    False\n\n    ","^0","^9"],["^ ","^7","in1d","^8","\n    Test whether each element of a 1-D array is also present in a second array.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    We recommend using :func:`isin` instead of `in1d` for new code.\n\n    Parameters\n    ----------\n    ar1 : (M,) array_like\n        Input array.\n    ar2 : array_like\n        The values against which to test each value of `ar1`.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n    invert : bool, optional\n        If True, the values in the returned array are inverted (that is,\n        False where an element of `ar1` is in `ar2` and True otherwise).\n        Default is False. ``np.in1d(a, b, invert=True)`` is equivalent\n        to (but is faster than) ``np.invert(in1d(a, b))``.\n\n        .. versionadded:: 1.8.0\n\n    Returns\n    -------\n    in1d : (M,) ndarray, bool\n        The values `ar1[in1d]` are in `ar2`.\n\n    See Also\n    --------\n    isin                  : Version of this function that preserves the\n                            shape of ar1.\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n    `in1d` can be considered as an element-wise function version of the\n    python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly\n    equivalent to ``np.array([item in b for item in a])``.\n    However, this idea fails if `ar2` is a set, or similar (non-sequence)\n    container:  As ``ar2`` is converted to an array, in those cases\n    ``asarray(ar2)`` is an object array rather than the expected array of\n    contained values.\n\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> test = np.array([0, 1, 2, 5, 0])\n    >>> states = [0, 2]\n    >>> mask = np.in1d(test, states)\n    >>> mask\n    array([ True, False,  True, False,  True])\n    >>> test[mask]\n    array([0, 2, 0])\n    >>> mask = np.in1d(test, states, invert=True)\n    >>> mask\n    array([False,  True, False,  True, False])\n    >>> test[mask]\n    array([1, 5])\n    ","^0","^9"],["^ ","^7","complex_","^8","Complex number type composed of two double-precision floating-point\n    numbers, compatible with Python `complex`.\n    Character code: ``'D'``.\n    Canonical name: ``np.cdouble``.\n    Alias: ``np.cfloat``.\n    Alias: ``np.complex_``.\n    Alias *on this platform*: ``np.complex128``: Complex number type composed of 2 64-bit-precision floating-point numbers.","^0","^0"],["^ ","^8","\n    Translates slice objects to concatenation along the second axis.\n\n    This is short-hand for ``np.r_['-1,2,0', index expression]``, which is\n    useful because of its common occurrence. In particular, arrays will be\n    stacked along their last axis after being upgraded to at least 2-D with\n    1's post-pended to the shape (column vectors made out of 1-D arrays).\n    \n    See Also\n    --------\n    column_stack : Stack 1-D arrays as columns into a 2-D array.\n    r_ : For more detailed documentation.\n\n    Examples\n    --------\n    >>> np.c_[np.array([1,2,3]), np.array([4,5,6])]\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]\n    array([[1, 2, 3, ..., 4, 5, 6]])\n\n    ","^0","~:c-class"],["^ ","^8","\n    `nd_grid` instance which returns a dense multi-dimensional \"meshgrid\".\n\n    An instance of `numpy.lib.index_tricks.nd_grid` which returns an dense\n    (or fleshed out) mesh-grid when indexed, so that each returned argument\n    has the same shape.  The dimensions and number of the output arrays are\n    equal to the number of indexing dimensions.  If the step length is not a\n    complex number, then the stop is not inclusive.\n\n    However, if the step length is a **complex number** (e.g. 5j), then\n    the integer part of its magnitude is interpreted as specifying the\n    number of points to create between the start and stop values, where\n    the stop value **is inclusive**.\n\n    Returns\n    ----------\n    mesh-grid `ndarrays` all of the same dimensions\n\n    See Also\n    --------\n    numpy.lib.index_tricks.nd_grid : class of `ogrid` and `mgrid` objects\n    ogrid : like mgrid but returns open (not fleshed out) mesh grids\n    r_ : array concatenator\n\n    Examples\n    --------\n    >>> np.mgrid[0:5,0:5]\n    array([[[0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 1],\n            [2, 2, 2, 2, 2],\n            [3, 3, 3, 3, 3],\n            [4, 4, 4, 4, 4]],\n           [[0, 1, 2, 3, 4],\n            [0, 1, 2, 3, 4],\n            [0, 1, 2, 3, 4],\n            [0, 1, 2, 3, 4],\n            [0, 1, 2, 3, 4]]])\n    >>> np.mgrid[-1:1:5j]\n    array([-1. , -0.5,  0. ,  0.5,  1. ])\n\n    ","^0","~:m-grid-class"],["^ ","^7","trapz","^8","\n    Integrate along the given axis using the composite trapezoidal rule.\n\n    Integrate `y` (`x`) along given axis.\n\n    Parameters\n    ----------\n    y : array_like\n        Input array to integrate.\n    x : array_like, optional\n        The sample points corresponding to the `y` values. If `x` is None,\n        the sample points are assumed to be evenly spaced `dx` apart. The\n        default is None.\n    dx : scalar, optional\n        The spacing between sample points when `x` is None. The default is 1.\n    axis : int, optional\n        The axis along which to integrate.\n\n    Returns\n    -------\n    trapz : float\n        Definite integral as approximated by trapezoidal rule.\n\n    See Also\n    --------\n    sum, cumsum\n\n    Notes\n    -----\n    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points\n    will be taken from `y` array, by default x-axis distances between\n    points will be 1.0, alternatively they can be provided with `x` array\n    or with `dx` scalar.  Return value will be equal to combined area under\n    the red lines.\n\n\n    References\n    ----------\n    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule\n\n    .. [2] Illustration image:\n           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n    Examples\n    --------\n    >>> np.trapz([1,2,3])\n    4.0\n    >>> np.trapz([1,2,3], x=[4,6,8])\n    8.0\n    >>> np.trapz([1,2,3], dx=2)\n    8.0\n    >>> a = np.arange(6).reshape(2, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.trapz(a, axis=0)\n    array([1.5, 2.5, 3.5])\n    >>> np.trapz(a, axis=1)\n    array([2.,  8.])\n\n    ","^0","^9"],["^ ","^7","float64","^8","Double-precision floating-point number type, compatible with Python `float`\n    and C ``double``.\n    Character code: ``'d'``.\n    Canonical name: ``np.double``.\n    Alias: ``np.float_``.\n    Alias *on this platform*: ``np.float64``: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.","^0","^0"],["^ ","^7","histogramdd","^8","\n    Compute the multidimensional histogram of some data.\n\n    Parameters\n    ----------\n    sample : (N, D) array, or (D, N) array_like\n        The data to be histogrammed.\n\n        Note the unusual interpretation of sample when an array_like:\n\n        * When an array, each row is a coordinate in a D-dimensional space -\n          such as ``histogramgramdd(np.array([p1, p2, p3]))``.\n        * When an array_like, each element is the list of values for single\n          coordinate - such as ``histogramgramdd((X, Y, Z))``.\n\n        The first form should be preferred.\n\n    bins : sequence or int, optional\n        The bin specification:\n\n        * A sequence of arrays describing the monotonically increasing bin\n          edges along each dimension.\n        * The number of bins for each dimension (nx, ny, ... =bins)\n        * The number of bins for all dimensions (nx=ny=...=bins).\n\n    range : sequence, optional\n        A sequence of length D, each an optional (lower, upper) tuple giving\n        the outer bin edges to be used if the edges are not given explicitly in\n        `bins`.\n        An entry of None in the sequence results in the minimum and maximum\n        values being used for the corresponding dimension.\n        The default, None, is equivalent to passing a tuple of D None values.\n    density : bool, optional\n        If False, the default, returns the number of samples in each bin.\n        If True, returns the probability *density* function at the bin,\n        ``bin_count / sample_count / bin_volume``.\n    normed : bool, optional\n        An alias for the density argument that behaves identically. To avoid\n        confusion with the broken normed argument to `histogram`, `density`\n        should be preferred.\n    weights : (N,) array_like, optional\n        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n        Weights are normalized to 1 if normed is True. If normed is False,\n        the values of the returned histogram are equal to the sum of the\n        weights belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray\n        The multidimensional histogram of sample x. See normed and weights\n        for the different possible semantics.\n    edges : list\n        A list of D arrays describing the bin edges for each dimension.\n\n    See Also\n    --------\n    histogram: 1-D histogram\n    histogram2d: 2-D histogram\n\n    Examples\n    --------\n    >>> r = np.random.randn(100,3)\n    >>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n    >>> H.shape, edges[0].size, edges[1].size, edges[2].size\n    ((5, 8, 4), 6, 9, 5)\n\n    ","^0","^9"],["^ ","^7","average","^8","\n    Compute the weighted average along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing data to be averaged. If `a` is not an array, a\n        conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to average `a`.  The default,\n        axis=None, will average over all of the elements of the input array.\n        If axis is negative it counts from the last to the first axis.\n\n        .. versionadded:: 1.7.0\n\n        If axis is a tuple of ints, averaging is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.  The 1-D calculation is::\n\n            avg = sum(a * weights) / sum(weights)\n\n        The only constraint on `weights` is that `sum(weights)` must not be 0.\n    returned : bool, optional\n        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken.\n\n    Returns\n    -------\n    retval, [sum_of_weights] : array_type or double\n        Return the average along the specified axis. When `returned` is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. `sum_of_weights` is of the\n        same type as `retval`. The result dtype follows a genereal pattern.\n        If `weights` is None, the result dtype will be that of `a` , or ``float64``\n        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-\n        integral, the result type will be the type of lowest precision capable of\n        representing values of both `a` and `weights`. If `a` happens to be\n        integral, the previous rules still applies but the result dtype will\n        at least be ``float64``.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When the length of 1D `weights` is not the same as the shape of `a`\n        along axis.\n\n    See Also\n    --------\n    mean\n\n    ma.average : average for masked arrays -- useful if your data contains\n                 \"missing\" values\n    numpy.result_type : Returns the type that results from applying the\n                        numpy type promotion rules to the arguments.\n\n    Examples\n    --------\n    >>> data = np.arange(1, 5)\n    >>> data\n    array([1, 2, 3, 4])\n    >>> np.average(data)\n    2.5\n    >>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))\n    4.0\n\n    >>> data = np.arange(6).reshape((3,2))\n    >>> data\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.average(data, axis=1, weights=[1./4, 3./4])\n    array([0.75, 2.75, 4.75])\n    >>> np.average(data, weights=[1./4, 3./4])\n    Traceback (most recent call last):\n        ...\n    TypeError: Axis must be specified when shapes of a and weights differ.\n\n    >>> a = np.ones(5, dtype=np.float128)\n    >>> w = np.ones(5, dtype=np.complex64)\n    >>> avg = np.average(a, weights=w)\n    >>> print(avg.dtype)\n    complex256\n    ","^0","^9"],["^ ","^7","iscomplexobj","^8","\n    Check for a complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. Even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    iscomplexobj : bool\n        The return value, True if `x` is of a complex type or has at least\n        one complex element.\n\n    See Also\n    --------\n    isrealobj, iscomplex\n\n    Examples\n    --------\n    >>> np.iscomplexobj(1)\n    False\n    >>> np.iscomplexobj(1+0j)\n    True\n    >>> np.iscomplexobj([3, 1+0j, True])\n    True\n\n    ","^0","^9"],["^ ","^7","logaddexp","^8","logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nLogarithm of the sum of exponentiations of the inputs.\n\nCalculates ``log(exp(x1) + exp(x2))``. This function is useful in\nstatistics where the calculated probabilities of events may be so small\nas to exceed the range of normal floating point numbers.  In such cases\nthe logarithm of the calculated probability is stored. This function\nallows adding probabilities stored in such a fashion.\n\nParameters\n----------\nx1, x2 : array_like\n    Input values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nresult : ndarray\n    Logarithm of ``exp(x1) + exp(x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nExamples\n--------\n>>> prob1 = np.log(1e-50)\n>>> prob2 = np.log(2.5e-50)\n>>> prob12 = np.logaddexp(prob1, prob2)\n>>> prob12\n-113.87649168120691\n>>> np.exp(prob12)\n3.5000000000000057e-50","^0","^;"],["^ ","^7","multiply","^8","multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nMultiply arguments element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays to be multiplied. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The product of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nEquivalent to `x1` * `x2` in terms of array broadcasting.\n\nExamples\n--------\n>>> np.multiply(2.0, 4.0)\n8.0\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])","^0","^;"],["^ ","^7","uint","^8","Unsigned integer type, compatible with C ``unsigned long``.\n    Character code: ``'L'``.\n    Canonical name: ``np.uint``.\n    Alias *on this platform*: ``np.uint64``: 64-bit unsigned integer (0 to 18446744073709551615).\n    Alias *on this platform*: ``np.uintp``: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.","^0","^0"],["^ ","^7","nanpercentile","^8","\n    Compute the qth percentile of the data along the specified axis,\n    while ignoring nan values.\n\n    Returns the qth percentile(s) of the array elements.\n\n    .. versionadded:: 1.9.0\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array, containing\n        nan values to be ignored.\n    q : array_like of float\n        Percentile or sequence of percentiles to compute, which must be between\n        0 and 100 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the percentiles are computed. The\n        default is to compute the percentile(s) along a flattened\n        version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to\n        use when the desired percentile lies between two data points\n        ``i < j``:\n\n        * 'linear': ``i + (j - i) * fraction``, where ``fraction``\n          is the fractional part of the index surrounded by ``i``\n          and ``j``.\n        * 'lower': ``i``.\n        * 'higher': ``j``.\n        * 'nearest': ``i`` or ``j``, whichever is nearest.\n        * 'midpoint': ``(i + j) / 2``.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n        If this is anything but the default value it will be passed\n        through (in the special case of an empty array) to the\n        `mean` function of the underlying array.  If the array is\n        a sub-class and `mean` does not have the kwarg `keepdims` this\n        will raise a RuntimeError.\n\n    Returns\n    -------\n    percentile : scalar or ndarray\n        If `q` is a single percentile and `axis=None`, then the result\n        is a scalar. If multiple percentiles are given, first axis of\n        the result corresponds to the percentiles. The other axes are\n        the axes that remain after the reduction of `a`. If the input\n        contains integers or floats smaller than ``float64``, the output\n        data-type is ``float64``. Otherwise, the output data-type is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    nanmean\n    nanmedian : equivalent to ``nanpercentile(..., 50)``\n    percentile, median, mean\n    nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].\n\n    Notes\n    -----\n    Given a vector ``V`` of length ``N``, the ``q``-th percentile of\n    ``V`` is the value ``q/100`` of the way from the minimum to the\n    maximum in a sorted copy of ``V``. The values and distances of\n    the two nearest neighbors as well as the `interpolation` parameter\n    will determine the percentile if the normalized ranking does not\n    match the location of ``q`` exactly. This function is the same as\n    the median if ``q=50``, the same as the minimum if ``q=0`` and the\n    same as the maximum if ``q=100``.\n\n    Examples\n    --------\n    >>> a = np.array([[10., 7., 4.], [3., 2., 1.]])\n    >>> a[0][1] = np.nan\n    >>> a\n    array([[10.,  nan,   4.],\n          [ 3.,   2.,   1.]])\n    >>> np.percentile(a, 50)\n    nan\n    >>> np.nanpercentile(a, 50)\n    3.0\n    >>> np.nanpercentile(a, 50, axis=0)\n    array([6.5, 2. , 2.5])\n    >>> np.nanpercentile(a, 50, axis=1, keepdims=True)\n    array([[7.],\n           [2.]])\n    >>> m = np.nanpercentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.nanpercentile(a, 50, axis=0, out=out)\n    array([6.5, 2. , 2.5])\n    >>> m\n    array([6.5,  2. ,  2.5])\n\n    >>> b = a.copy()\n    >>> np.nanpercentile(b, 50, axis=1, overwrite_input=True)\n    array([7., 2.])\n    >>> assert not np.all(a==b)\n\n    ","^0","^9"],["^ ","^7","intc","^8","Signed integer type, compatible with C ``int``.\n    Character code: ``'i'``.\n    Canonical name: ``np.intc``.\n    Alias *on this platform*: ``np.int32``: 32-bit signed integer (-2147483648 to 2147483647).","^0","^0"],["^ ","^7","int32","^8","Signed integer type, compatible with C ``int``.\n    Character code: ``'i'``.\n    Canonical name: ``np.intc``.\n    Alias *on this platform*: ``np.int32``: 32-bit signed integer (-2147483648 to 2147483647).","^0","^0"],["^ ","^7","place","^8","\n    Change elements of an array based on conditional and input values.\n\n    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that\n    `place` uses the first N elements of `vals`, where N is the number of\n    True values in `mask`, while `copyto` uses the elements where `mask`\n    is True.\n\n    Note that `extract` does the exact opposite of `place`.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Array to put data into.\n    mask : array_like\n        Boolean mask array. Must have the same size as `a`.\n    vals : 1-D sequence\n        Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N, it will be repeated, and if elements of `a` are to be masked,\n        this sequence must be non-empty.\n\n    See Also\n    --------\n    copyto, put, take, extract\n\n    Examples\n    --------\n    >>> arr = np.arange(6).reshape(2, 3)\n    >>> np.place(arr, arr>2, [44, 55])\n    >>> arr\n    array([[ 0,  1,  2],\n           [44, 55, 44]])\n\n    ","^0","^9"],["^ ","^7","shape","^8","\n    Return the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    shape : tuple of ints\n        The elements of the shape tuple give the lengths of the\n        corresponding array dimensions.\n\n    See Also\n    --------\n    alen\n    ndarray.shape : Equivalent array method.\n\n    Examples\n    --------\n    >>> np.shape(np.eye(3))\n    (3, 3)\n    >>> np.shape([[1, 2]])\n    (1, 2)\n    >>> np.shape([0])\n    (1,)\n    >>> np.shape(0)\n    ()\n\n    >>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n    >>> np.shape(a)\n    (2,)\n    >>> a.shape\n    (2,)\n\n    ","^0","^9"],["^ ","^7","numpy.matrixlib","^8","Sub-package containing the matrix class and related functions.\n\n","^0","^>"],["^ ","^7","lcm","^8","lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the lowest common multiple of ``|x1|`` and ``|x2|``\n\nParameters\n----------\nx1, x2 : array_like, int\n    Arrays of values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\n\nReturns\n-------\ny : ndarray or scalar\n    The lowest common multiple of the absolute value of the inputs\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngcd : The greatest common divisor\n\nExamples\n--------\n>>> np.lcm(12, 20)\n60\n>>> np.lcm.reduce([3, 12, 20])\n60\n>>> np.lcm.reduce([40, 12, 20])\n120\n>>> np.lcm(np.arange(6), 20)\narray([ 0, 20, 20, 60, 20, 20])","^0","^;"],["^ ","^7","copysign","^8","copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nChange the sign of x1 to that of x2, element-wise.\n\nIf `x2` is a scalar, its sign will be copied to all elements of `x1`.\n\nParameters\n----------\nx1 : array_like\n    Values to change the sign of.\nx2 : array_like\n    The sign of `x2` is copied to `x1`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The values of `x1` with the sign of `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nExamples\n--------\n>>> np.copysign(1.3, -1)\n-1.3\n>>> 1/np.copysign(0, 1)\ninf\n>>> 1/np.copysign(0, -1)\n-inf\n\n>>> np.copysign([-1, 0, 1], -1.1)\narray([-1., -0., -1.])\n>>> np.copysign([-1, 0, 1], np.arange(3)-1)\narray([-1.,  0.,  1.])","^0","^;"],["^ ","^7","uint16","^8","Unsigned integer type, compatible with C ``unsigned short``.\n    Character code: ``'H'``.\n    Canonical name: ``np.ushort``.\n    Alias *on this platform*: ``np.uint16``: 16-bit unsigned integer (0 to 65535).","^0","^0"],["^ ","^7","delete","^8","\n    Return a new array with sub-arrays along an axis deleted. For a one\n    dimensional array, this returns those entries not returned by\n    `arr[obj]`.\n\n    Parameters\n    ----------\n    arr : array_like\n      Input array.\n    obj : slice, int or array of ints\n      Indicate indices of sub-arrays to remove along the specified axis.\n    axis : int, optional\n      The axis along which to delete the subarray defined by `obj`.\n      If `axis` is None, `obj` is applied to the flattened array.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with the elements specified by `obj` removed. Note\n        that `delete` does not occur in-place. If `axis` is None, `out` is\n        a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    append : Append elements at the end of an array.\n\n    Notes\n    -----\n    Often it is preferable to use a boolean mask. For example:\n\n    >>> arr = np.arange(12) + 1\n    >>> mask = np.ones(len(arr), dtype=bool)\n    >>> mask[[0,2,4]] = False\n    >>> result = arr[mask,...]\n\n    Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further\n    use of `mask`.\n\n    Examples\n    --------\n    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n    >>> arr\n    array([[ 1,  2,  3,  4],\n           [ 5,  6,  7,  8],\n           [ 9, 10, 11, 12]])\n    >>> np.delete(arr, 1, 0)\n    array([[ 1,  2,  3,  4],\n           [ 9, 10, 11, 12]])\n\n    >>> np.delete(arr, np.s_[::2], 1)\n    array([[ 2,  4],\n           [ 6,  8],\n           [10, 12]])\n    >>> np.delete(arr, [1,3,5], None)\n    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n\n    ","^0","^9"],["^ ","^7","is_busday","^8","\n    is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)\n\n    Calculates which of the given dates are valid days, and which are not.\n\n    .. versionadded:: 1.7.0\n\n    Parameters\n    ----------\n    dates : array_like of datetime64[D]\n        The array of dates to process.\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates.  They may be\n        specified in any order, and NaT (not-a-time) dates are ignored.\n        This list is saved in a normalized form that is suited for\n        fast calculations of valid days.\n    busdaycal : busdaycalendar, optional\n        A `busdaycalendar` object which specifies the valid days. If this\n        parameter is provided, neither weekmask nor holidays may be\n        provided.\n    out : array of bool, optional\n        If provided, this array is filled with the result.\n\n    Returns\n    -------\n    out : array of bool\n        An array with the same shape as ``dates``, containing True for\n        each valid day, and False for each invalid day.\n\n    See Also\n    --------\n    busdaycalendar: An object that specifies a custom set of valid days.\n    busday_offset : Applies an offset counted in valid days.\n    busday_count : Counts how many valid days are in a half-open date range.\n\n    Examples\n    --------\n    >>> # The weekdays are Friday, Saturday, and Monday\n    ... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n    ...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n    array([False, False,  True])\n    ","^0","^9"],["^ ","^7","savez_compressed","^8","\n    Save several arrays into a single file in compressed ``.npz`` format.\n\n    If keyword arguments are given, then filenames are taken from the keywords.\n    If arguments are passed in with no keywords, then stored filenames are\n    arr_0, arr_1, etc.\n\n    Parameters\n    ----------\n    file : str or file\n        Either the filename (string) or an open file (file-like object)\n        where the data will be saved. If file is a string or a Path, the\n        ``.npz`` extension will be appended to the filename if it is not\n        already there.\n    args : Arguments, optional\n        Arrays to save to the file. Since it is not possible for Python to\n        know the names of the arrays outside `savez`, the arrays will be saved\n        with names \"arr_0\", \"arr_1\", and so on. These arguments can be any\n        expression.\n    kwds : Keyword arguments, optional\n        Arrays to save to the file. Arrays will be saved in the file with the\n        keyword names.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    numpy.save : Save a single array to a binary file in NumPy format.\n    numpy.savetxt : Save an array to a file as plain text.\n    numpy.savez : Save several arrays into an uncompressed ``.npz`` file format\n    numpy.load : Load the files created by savez_compressed.\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is compressed with\n    ``zipfile.ZIP_DEFLATED`` and each file in the archive contains one variable\n    in ``.npy`` format. For a description of the ``.npy`` format, see \n    :py:mod:`numpy.lib.format`.\n\n\n    When opening the saved ``.npz`` file with `load` a `NpzFile` object is\n    returned. This is a dictionary-like object which can be queried for\n    its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Examples\n    --------\n    >>> test_array = np.random.rand(3, 2)\n    >>> test_vector = np.random.rand(4)\n    >>> np.savez_compressed('/tmp/123', a=test_array, b=test_vector)\n    >>> loaded = np.load('/tmp/123.npz')\n    >>> print(np.array_equal(test_array, loaded['a']))\n    True\n    >>> print(np.array_equal(test_vector, loaded['b']))\n    True\n\n    ","^0","^9"],["^ ","^7","ediff1d","^8","\n    The differences between consecutive elements of an array.\n\n    Parameters\n    ----------\n    ary : array_like\n        If necessary, will be flattened before the differences are taken.\n    to_end : array_like, optional\n        Number(s) to append at the end of the returned differences.\n    to_begin : array_like, optional\n        Number(s) to prepend at the beginning of the returned differences.\n\n    Returns\n    -------\n    ediff1d : ndarray\n        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.\n\n    See Also\n    --------\n    diff, gradient\n\n    Notes\n    -----\n    When applied to masked arrays, this function drops the mask information\n    if the `to_begin` and/or `to_end` parameters are used.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.ediff1d(x)\n    array([ 1,  2,  3, -7])\n\n    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\n    array([-99,   1,   2, ...,  -7,  88,  99])\n\n    The returned array is always 1D.\n\n    >>> y = [[1, 2, 4], [1, 6, 24]]\n    >>> np.ediff1d(y)\n    array([ 1,  2, -3,  5, 18])\n\n    ","^0","^9"],["^ ","^7","fromfile","^8","fromfile(file, dtype=float, count=-1, sep='', offset=0)\n\n    Construct an array from data in a text or binary file.\n\n    A highly efficient way of reading binary data with a known data-type,\n    as well as parsing simply formatted text files.  Data written using the\n    `tofile` method can be read using this function.\n\n    Parameters\n    ----------\n    file : file or str or Path\n        Open file object or filename.\n\n        .. versionchanged:: 1.17.0\n            `pathlib.Path` objects are now accepted.\n\n    dtype : data-type\n        Data type of the returned array.\n        For binary files, it is used to determine the size and byte-order\n        of the items in the file.\n        Most builtin numeric types are supported and extension types may be supported.\n\n        .. versionadded:: 1.18.0\n            Complex dtypes.\n\n    count : int\n        Number of items to read. ``-1`` means all items (i.e., the complete\n        file).\n    sep : str\n        Separator between items if file is a text file.\n        Empty (\"\") separator means the file should be treated as binary.\n        Spaces (\" \") in the separator match zero or more whitespace characters.\n        A separator consisting only of spaces must match at least one\n        whitespace.\n    offset : int\n        The offset (in bytes) from the file's current position. Defaults to 0.\n        Only permitted for binary files.\n\n        .. versionadded:: 1.17.0\n\n    See also\n    --------\n    load, save\n    ndarray.tofile\n    loadtxt : More flexible way of loading data from a text file.\n\n    Notes\n    -----\n    Do not rely on the combination of `tofile` and `fromfile` for\n    data storage, as the binary files generated are not platform\n    independent.  In particular, no byte-order or data-type information is\n    saved.  Data can be stored in the platform independent ``.npy`` format\n    using `save` and `load` instead.\n\n    Examples\n    --------\n    Construct an ndarray:\n\n    >>> dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),\n    ...                ('temp', float)])\n    >>> x = np.zeros((1,), dtype=dt)\n    >>> x['time']['min'] = 10; x['temp'] = 98.25\n    >>> x\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])\n\n    Save the raw data to disk:\n\n    >>> import tempfile\n    >>> fname = tempfile.mkstemp()[1]\n    >>> x.tofile(fname)\n\n    Read the raw data from disk:\n\n    >>> np.fromfile(fname, dtype=dt)\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])\n\n    The recommended way to store and load data:\n\n    >>> np.save(fname, x)\n    >>> np.load(fname + '.npy')\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])","^0","^?"],["^ ","^7","put","^8","\n    Replaces specified elements of an array with given values.\n\n    The indexing works on the flattened target array. `put` is roughly\n    equivalent to:\n\n    ::\n\n        a.flat[ind] = v\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    ind : array_like\n        Target indices, interpreted as integers.\n    v : array_like\n        Values to place in `a` at target indices. If `v` is shorter than\n        `ind` it will be repeated as necessary.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers. In 'raise' mode,\n        if an exception occurs the target array may still be modified.\n\n    See Also\n    --------\n    putmask, place\n    put_along_axis : Put elements by matching the array and the index arrays\n\n    Examples\n    --------\n    >>> a = np.arange(5)\n    >>> np.put(a, [0, 2], [-44, -55])\n    >>> a\n    array([-44,   1, -55,   3,   4])\n\n    >>> a = np.arange(5)\n    >>> np.put(a, 22, -5, mode='clip')\n    >>> a\n    array([ 0,  1,  2,  3, -5])\n\n    ","^0","^9"],["^ ","^7","not_equal","^8","not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 != x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays.  If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nequal, greater, greater_equal, less, less_equal\n\nExamples\n--------\n>>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])","^0","^;"],["^ ","^7","corrcoef","^8","\n    Return Pearson product-moment correlation coefficients.\n\n    Please refer to the documentation for `cov` for more detail.  The\n    relationship between the correlation coefficient matrix, `R`, and the\n    covariance matrix, `C`, is\n\n    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }\n\n    The values of `R` are between -1 and 1, inclusive.\n\n    Parameters\n    ----------\n    x : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `x` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        shape as `x`.\n    rowvar : bool, optional\n        If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.10.0\n    ddof : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.10.0\n\n    Returns\n    -------\n    R : ndarray\n        The correlation coefficient matrix of the variables.\n\n    See Also\n    --------\n    cov : Covariance matrix\n\n    Notes\n    -----\n    Due to floating point rounding the resulting array may not be Hermitian,\n    the diagonal elements may not be 1, and the elements may not satisfy the\n    inequality abs(a) <= 1. The real and imaginary parts are clipped to the\n    interval [-1,  1] in an attempt to improve on that situation but is not\n    much help in the complex case.\n\n    This function accepts but discards arguments `bias` and `ddof`.  This is\n    for backwards compatibility with previous versions of this function.  These\n    arguments had no effect on the return values of the function and can be\n    safely ignored in this and previous versions of numpy.\n\n    ","^0","^9"],["^ ","^7","msort","^8","\n    Return a copy of an array sorted along the first axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    sort\n\n    Notes\n    -----\n    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.\n\n    ","^0","^9"],["^ ","^7","csingle","^8","Complex number type composed of two single-precision floating-point\n    numbers.\n    Character code: ``'F'``.\n    Canonical name: ``np.csingle``.\n    Alias: ``np.singlecomplex``.\n    Alias *on this platform*: ``np.complex64``: Complex number type composed of 2 32-bit-precision floating-point numbers.","^0","^0"],["^ ","^7","bitwise_or","^8","bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``|``.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_or\nbitwise_and\nbitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 has the binaray representation ``00001101``. Likewise,\n16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is\nthen ``000111011``, or 29:\n\n>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'\n\n>>> np.bitwise_or(32, 2)\n34\n>>> np.bitwise_or([33, 4], 1)\narray([33,  5])\n>>> np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n\n>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n>>> np.bitwise_or([True, True], [False, True])\narray([ True,  True])","^0","^;"],["^ ","^7","rad2deg","^8","rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from radians to degrees.\n\nParameters\n----------\nx : array_like\n    Angle in radians.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding angle in degrees.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\ndeg2rad : Convert angles from degrees to radians.\nunwrap : Remove large jumps in angle by wrapping.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nrad2deg(x) is ``180 * x / pi``.\n\nExamples\n--------\n>>> np.rad2deg(np.pi/2)\n90.0","^0","^;"],["^ ","^7","deprecate_with_doc","^8",null,"^0","^9"],["^ ","^7","real_if_close","^8","\n    If complex input returns a real array if complex parts are close to zero.\n\n    \"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n    `a`).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    tol : float\n        Tolerance in machine epsilons for the complex part of the elements\n        in the array.\n\n    Returns\n    -------\n    out : ndarray\n        If `a` is real, the type of `a` is used for the output.  If `a`\n        has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, imag, angle\n\n    Notes\n    -----\n    Machine epsilon varies from machine to machine and between data types\n    but Python floats on most platforms have a machine epsilon equal to\n    2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print\n    out the machine epsilon for floats.\n\n    Examples\n    --------\n    >>> np.finfo(float).eps\n    2.2204460492503131e-16 # may vary\n\n    >>> np.real_if_close([2.1 + 4e-14j], tol=1000)\n    array([2.1])\n    >>> np.real_if_close([2.1 + 4e-13j], tol=1000)\n    array([2.1+4.e-13j])\n\n    ","^0","^9"],["^ ","^7","fromregex","^8","\n    Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : str or file\n        Filename or file object to read.\n    regexp : str or regexp\n        Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype.\n    dtype : dtype or list of dtypes\n        Dtype for the structured array.\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply to input streams.\n\n        .. versionadded:: 1.14.0\n\n    Returns\n    -------\n    output : ndarray\n        The output array, containing the part of the content of `file` that\n        was matched by `regexp`. `output` is always a structured array.\n\n    Raises\n    ------\n    TypeError\n        When `dtype` is not a valid dtype for a structured array.\n\n    See Also\n    --------\n    fromstring, loadtxt\n\n    Notes\n    -----\n    Dtypes for structured arrays can be specified in several forms, but all\n    forms specify at least the data type and field name. For details see\n    `doc.structured_arrays`.\n\n    Examples\n    --------\n    >>> f = open('test.dat', 'w')\n    >>> _ = f.write(\"1312 foo\\n1534  bar\\n444   qux\")\n    >>> f.close()\n\n    >>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n    >>> output = np.fromregex('test.dat', regexp,\n    ...                       [('num', np.int64), ('key', 'S3')])\n    >>> output\n    array([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],\n          dtype=[('num', '<i8'), ('key', 'S3')])\n    >>> output['num']\n    array([1312, 1534,  444])\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","clip","^8","\n    Clip (limit) the values in an array.\n\n    Given an interval, values outside the interval are clipped to\n    the interval edges.  For example, if an interval of ``[0, 1]``\n    is specified, values smaller than 0 become 0, and values larger\n    than 1 become 1.\n\n    Equivalent to but faster than ``np.maximum(a_min, np.minimum(a, a_max))``.\n    No check is performed to ensure ``a_min < a_max``.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing elements to clip.\n    a_min : scalar or array_like or None\n        Minimum value. If None, clipping is not performed on lower\n        interval edge. Not more than one of `a_min` and `a_max` may be\n        None.\n    a_max : scalar or array_like or None\n        Maximum value. If None, clipping is not performed on upper\n        interval edge. Not more than one of `a_min` and `a_max` may be\n        None. If `a_min` or `a_max` are array_like, then the three\n        arrays will be broadcasted to match their shapes.\n    out : ndarray, optional\n        The results will be placed in this array. It may be the input\n        array for in-place clipping.  `out` must be of the right shape\n        to hold the output.  Its type is preserved.\n    **kwargs\n        For other keyword-only arguments, see the\n        :ref:`ufunc docs <ufuncs.kwargs>`.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    clipped_array : ndarray\n        An array with the elements of `a`, but where values\n        < `a_min` are replaced with `a_min`, and those > `a_max`\n        with `a_max`.\n\n    See Also\n    --------\n    ufuncs-output-type\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> np.clip(a, 1, 8)\n    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.clip(a, 3, 6, out=a)\n    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n    >>> a = np.arange(10)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\n    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n    ","^0","^9"],["^ ","^7","longdouble","^8","Extended-precision floating-point number type, compatible with C\n    ``long double`` but not necessarily with IEEE 754 quadruple-precision.\n    Character code: ``'g'``.\n    Canonical name: ``np.longdouble``.\n    Alias: ``np.longfloat``.\n    Alias *on this platform*: ``np.float128``: 128-bit extended-precision floating-point number type.","^0","^0"],["^ ","^7","record","^8","A data-type scalar that allows field access as attribute lookup.\n    ","^0","^0"],["^ ","^7","argmax","^8","\n    Returns the indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n    take_along_axis : Apply ``np.expand_dims(index_array, axis)`` \n                      from argmax to an array as if by calling max.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> a = np.arange(6).reshape(2,3) + 10\n    >>> a\n    array([[10, 11, 12],\n           [13, 14, 15]])\n    >>> np.argmax(a)\n    5\n    >>> np.argmax(a, axis=0)\n    array([1, 1, 1])\n    >>> np.argmax(a, axis=1)\n    array([2, 2])\n\n    Indexes of the maximal elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)\n    >>> ind\n    (1, 2)\n    >>> a[ind]\n    15\n\n    >>> b = np.arange(6)\n    >>> b[1] = 5\n    >>> b\n    array([0, 5, 2, 3, 4, 5])\n    >>> np.argmax(b)  # Only the first occurrence is returned.\n    1\n\n    >>> x = np.array([[4,2,3], [1,0,3]])\n    >>> index_array = np.argmax(x, axis=-1)\n    >>> # Same as np.max(x, axis=-1, keepdims=True)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\n    array([[4],\n           [3]])\n    >>> # Same as np.max(x, axis=-1)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\n    array([4, 3])\n\n    ","^0","^9"],["^ ","^7","frexp","^8","frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDecompose the elements of x into mantissa and twos exponent.\n\nReturns (`mantissa`, `exponent`), where `x = mantissa * 2**exponent``.\nThe mantissa is lies in the open interval(-1, 1), while the twos\nexponent is a signed integer.\n\nParameters\n----------\nx : array_like\n    Array of numbers to be decomposed.\nout1 : ndarray, optional\n    Output array for the mantissa. Must have the same shape as `x`.\nout2 : ndarray, optional\n    Output array for the exponent. Must have the same shape as `x`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nmantissa : ndarray\n    Floating values between -1 and 1.\n    This is a scalar if `x` is a scalar.\nexponent : ndarray\n    Integer exponents of 2.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nldexp : Compute ``y = x1 * 2**x2``, the inverse of `frexp`.\n\nNotes\n-----\nComplex dtypes are not supported, they will raise a TypeError.\n\nExamples\n--------\n>>> x = np.arange(9)\n>>> y1, y2 = np.frexp(x)\n>>> y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n>>> y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n>>> y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])","^0","^;"],["^ ","^7","asmatrix","^8","\n    Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n    dtype : data-type\n       Data-type of the output matrix.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n\n    ","^0","^9"],["^ ","^7","matmul","^8","matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nMatrix product of two arrays.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays, scalars not allowed.\nout : ndarray, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that matches the signature `(n,k),(k,m)->(n,m)`. If not\n    provided or None, a freshly-allocated array is returned.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\n    .. versionadded:: 1.16\n       Now handles ufunc kwargs\n\nReturns\n-------\ny : ndarray\n    The matrix product of the inputs.\n    This is a scalar only when both x1, x2 are 1-d vectors.\n\nRaises\n------\nValueError\n    If the last dimension of `a` is not the same size as\n    the second-to-last dimension of `b`.\n\n    If a scalar value is passed in.\n\nSee Also\n--------\nvdot : Complex-conjugating dot product.\ntensordot : Sum products over arbitrary axes.\neinsum : Einstein summation convention.\ndot : alternative matrix product with different broadcasting rules.\n\nNotes\n-----\n\nThe behavior depends on the arguments in the following way.\n\n- If both arguments are 2-D they are multiplied like conventional\n  matrices.\n- If either argument is N-D, N > 2, it is treated as a stack of\n  matrices residing in the last two indexes and broadcast accordingly.\n- If the first argument is 1-D, it is promoted to a matrix by\n  prepending a 1 to its dimensions. After matrix multiplication\n  the prepended 1 is removed.\n- If the second argument is 1-D, it is promoted to a matrix by\n  appending a 1 to its dimensions. After matrix multiplication\n  the appended 1 is removed.\n\n``matmul`` differs from ``dot`` in two important ways:\n\n- Multiplication by scalars is not allowed, use ``*`` instead.\n- Stacks of matrices are broadcast together as if the matrices\n  were elements, respecting the signature ``(n,k),(k,m)->(n,m)``:\n\n  >>> a = np.ones([9, 5, 7, 4])\n  >>> c = np.ones([9, 5, 4, 3])\n  >>> np.dot(a, c).shape\n  (9, 5, 7, 9, 5, 3)\n  >>> np.matmul(a, c).shape\n  (9, 5, 7, 3)\n  >>> # n is 7, k is 4, m is 3\n\nThe matmul function implements the semantics of the `@` operator introduced\nin Python 3.5 following PEP465.\n\nExamples\n--------\nFor 2-D arrays it is the matrix product:\n\n>>> a = np.array([[1, 0],\n...               [0, 1]])\n>>> b = np.array([[4, 1],\n...               [2, 2]])\n>>> np.matmul(a, b)\narray([[4, 1],\n       [2, 2]])\n\nFor 2-D mixed with 1-D, the result is the usual.\n\n>>> a = np.array([[1, 0],\n...               [0, 1]])\n>>> b = np.array([1, 2])\n>>> np.matmul(a, b)\narray([1, 2])\n>>> np.matmul(b, a)\narray([1, 2])\n\n\nBroadcasting is conventional for stacks of arrays\n\n>>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))\n>>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))\n>>> np.matmul(a,b).shape\n(2, 2, 2)\n>>> np.matmul(a, b)[0, 1, 1]\n98\n>>> sum(a[0, 1, :] * b[0 , :, 1])\n98\n\nVector, vector returns the scalar inner product, but neither argument\nis complex-conjugated:\n\n>>> np.matmul([2j, 3j], [2j, 3j])\n(-13+0j)\n\nScalar multiplication raises an error.\n\n>>> np.matmul([1,2], 3)\nTraceback (most recent call last):\n...\nValueError: matmul: Input operand 1 does not have enough dimensions ...\n\n.. versionadded:: 1.10.0","^0","^;"],["^ ","^7","numpy.lib.scimath","^8","\nWrapper functions to more user-friendly calling of certain math functions\nwhose output data-type is different than the input data-type in certain\ndomains of the input.\n\nFor example, for functions like `log` with branch cuts, the versions in this\nmodule provide the mathematically valid answers in the complex plane::\n\n  >>> import math\n  >>> from numpy.lib import scimath\n  >>> scimath.log(-math.exp(1)) == (1+1j*math.pi)\n  True\n\nSimilarly, `sqrt`, other base logarithms, `power` and trig functions are\ncorrectly handled.  See their respective docstrings for specific examples.\n\n","^0","^>"],["^ ","^7","mean","^8","\n    Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the means are computed. The default is to\n        compute the mean of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a mean is performed over multiple axes,\n        instead of a single axis or all the axes as before.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See `ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `mean` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned.\n\n    See Also\n    --------\n    average : Weighted average\n    std, var, nanmean, nanstd, nanvar\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the elements along the axis divided\n    by the number of elements.\n\n    Note that for floating-point input, the mean is computed using the\n    same precision the input has.  Depending on the input data, this can\n    cause the results to be inaccurate, especially for `float32` (see\n    example below).  Specifying a higher-precision accumulator using the\n    `dtype` keyword can alleviate this issue.\n\n    By default, `float16` results are computed using `float32` intermediates\n    for extra precision.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.mean(a)\n    2.5\n    >>> np.mean(a, axis=0)\n    array([2., 3.])\n    >>> np.mean(a, axis=1)\n    array([1.5, 3.5])\n\n    In single precision, `mean` can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.mean(a)\n    0.54999924\n\n    Computing the mean in float64 is more accurate:\n\n    >>> np.mean(a, dtype=np.float64)\n    0.55000000074505806 # may vary\n\n    ","^0","^9"],["^ ","^7","uint32","^8","Unsigned integer type, compatible with C ``unsigned int``.\n    Character code: ``'I'``.\n    Canonical name: ``np.uintc``.\n    Alias *on this platform*: ``np.uint32``: 32-bit unsigned integer (0 to 4294967295).","^0","^0"],["^ ","^7","alltrue","^8","\n    Check if all elements of input array are true.\n\n    See Also\n    --------\n    numpy.all : Equivalent function; see for details.\n    ","^0","^9"],["^ ","^7","get_array_wrap","^8","Find the wrapper for the array with the highest priority.\n\n    In case of ties, leftmost wins. If no wrapper is found, return None\n    ","^0","^9"],["^ ","^7","loadtxt","^8","\n    Load data from a text file.\n\n    Each row in the text file must have the same number of values.\n\n    Parameters\n    ----------\n    fname : file, str, or pathlib.Path\n        File, filename, or generator to read.  If the filename extension is\n        ``.gz`` or ``.bz2``, the file is first decompressed. Note that\n        generators should return byte strings.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        structured data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str or sequence of str, optional\n        The characters or list of characters used to indicate the start of a\n        comment. None implies no comments. For backwards compatibility, byte\n        strings will be decoded as 'latin1'. The default is '#'.\n    delimiter : str, optional\n        The string used to separate values. For backwards compatibility, byte\n        strings will be decoded as 'latin1'. The default is whitespace.\n    converters : dict, optional\n        A dictionary mapping column number to a function that will parse the\n        column string into the desired value.  E.g., if column 0 is a date\n        string: ``converters = {0: datestr2num}``.  Converters can also be\n        used to provide a default value for missing data (but see also\n        `genfromtxt`): ``converters = {3: lambda s: float(s.strip() or 0)}``.\n        Default: None.\n    skiprows : int, optional\n        Skip the first `skiprows` lines, including comments; default: 0.\n    usecols : int or sequence, optional\n        Which columns to read, with 0 being the first. For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n\n        .. versionchanged:: 1.11.0\n            When a single column has to be read it is possible to use\n            an integer instead of a tuple. E.g ``usecols = 3`` reads the\n            fourth column the same way as ``usecols = (3,)`` would.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a structured\n        data-type, arrays are returned for each field.  Default is False.\n    ndmin : int, optional\n        The returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed.\n        Legal values: 0 (default), 1 or 2.\n\n        .. versionadded:: 1.6.0\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply to input streams.\n        The special value 'bytes' enables backward compatibility workarounds\n        that ensures you receive byte arrays as results if possible and passes\n        'latin1' encoded strings to converters. Override this value to receive\n        unicode arrays and pass strings as input to converters.  If set to None\n        the system default is used. The default value is 'bytes'.\n\n        .. versionadded:: 1.14.0\n    max_rows : int, optional\n        Read `max_rows` lines of content after `skiprows` lines. The default\n        is to read all the lines.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    `genfromtxt` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    .. versionadded:: 1.10.0\n\n    The strings produced by the Python float.hex method can be used as\n    input for floats.\n\n    Examples\n    --------\n    >>> from io import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(u\"0 1\\n2 3\")\n    >>> np.loadtxt(c)\n    array([[0., 1.],\n           [2., 3.]])\n\n    >>> d = StringIO(u\"M 21 72\\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([(b'M', 21, 72.), (b'F', 35, 58.)],\n          dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(u\"1,0,2\\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([1., 3.])\n    >>> y\n    array([2., 4.])\n\n    ","^0","^9"],["^ ","^7","var","^8","\n    Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the variance is computed.  The default is to\n        compute the variance of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a variance is performed over multiple axes,\n        instead of a single axis or all the axes as before.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : int, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `var` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If ``out=None``, returns a new array containing the variance;\n        otherwise, a reference to the output array is returned.\n\n    See Also\n    --------\n    std, mean, nanmean, nanstd, nanvar\n    ufuncs-output-type\n\n    Notes\n    -----\n    The variance is the average of the squared deviations from the mean,\n    i.e.,  ``var = mean(abs(x - x.mean())**2)``.\n\n    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.\n    If, however, `ddof` is specified, the divisor ``N - ddof`` is used\n    instead.  In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of the variance of a hypothetical infinite population.\n    ``ddof=0`` provides a maximum likelihood estimate of the variance for\n    normally distributed variables.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.var(a)\n    1.25\n    >>> np.var(a, axis=0)\n    array([1.,  1.])\n    >>> np.var(a, axis=1)\n    array([0.25,  0.25])\n\n    In single precision, var() can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.var(a)\n    0.20250003\n\n    Computing the variance in float64 is more accurate:\n\n    >>> np.var(a, dtype=np.float64)\n    0.20249999932944759 # may vary\n    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n    0.2025\n\n    ","^0","^9"],["^ ","^7","take_along_axis","^8","\n    Take values from the input array by matching 1d index and data slices.\n\n    This iterates over matching 1d slices oriented along the specified axis in\n    the index and data arrays, and uses the former to look up values in the\n    latter. These slices can be different lengths.\n\n    Functions returning an index along an axis, like `argsort` and\n    `argpartition`, produce suitable indices for this function.\n\n    .. versionadded:: 1.15.0\n\n    Parameters\n    ----------\n    arr: ndarray (Ni..., M, Nk...)\n        Source array\n    indices: ndarray (Ni..., J, Nk...)\n        Indices to take along each 1d slice of `arr`. This must match the\n        dimension of arr, but dimensions Ni and Nj only need to broadcast\n        against `arr`.\n    axis: int\n        The axis to take 1d slices along. If axis is None, the input array is\n        treated as if it had first been flattened to 1d, for consistency with\n        `sort` and `argsort`.\n\n    Returns\n    -------\n    out: ndarray (Ni..., J, Nk...)\n        The indexed result.\n\n    Notes\n    -----\n    This is equivalent to (but faster than) the following use of `ndindex` and\n    `s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::\n\n        Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]\n        J = indices.shape[axis]  # Need not equal M\n        out = np.empty(Ni + (J,) + Nk)\n\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                a_1d       = a      [ii + s_[:,] + kk]\n                indices_1d = indices[ii + s_[:,] + kk]\n                out_1d     = out    [ii + s_[:,] + kk]\n                for j in range(J):\n                    out_1d[j] = a_1d[indices_1d[j]]\n\n    Equivalently, eliminating the inner loop, the last two lines would be::\n\n                out_1d[:] = a_1d[indices_1d]\n\n    See Also\n    --------\n    take : Take along an axis, using the same indices for every 1d slice\n    put_along_axis :\n        Put values into the destination array by matching 1d index and data slices\n\n    Examples\n    --------\n\n    For this sample array\n\n    >>> a = np.array([[10, 30, 20], [60, 40, 50]])\n\n    We can sort either by using sort directly, or argsort and this function\n\n    >>> np.sort(a, axis=1)\n    array([[10, 20, 30],\n           [40, 50, 60]])\n    >>> ai = np.argsort(a, axis=1); ai\n    array([[0, 2, 1],\n           [1, 2, 0]])\n    >>> np.take_along_axis(a, ai, axis=1)\n    array([[10, 20, 30],\n           [40, 50, 60]])\n\n    The same works for max and min, if you expand the dimensions:\n\n    >>> np.expand_dims(np.max(a, axis=1), axis=1)\n    array([[30],\n           [60]])\n    >>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n    >>> ai\n    array([[1],\n           [0]])\n    >>> np.take_along_axis(a, ai, axis=1)\n    array([[30],\n           [60]])\n\n    If we want to get the max and min at the same time, we can stack the\n    indices first\n\n    >>> ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)\n    >>> ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)\n    >>> ai = np.concatenate([ai_min, ai_max], axis=1)\n    >>> ai\n    array([[0, 1],\n           [1, 0]])\n    >>> np.take_along_axis(a, ai, axis=1)\n    array([[10, 30],\n           [40, 60]])\n    ","^0","^9"],["^ ","^7","prod","^8","\n    Return the product of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a product is performed.  The default,\n        axis=None, will calculate the product of all the elements in the\n        input array. If axis is negative it counts from the last to the\n        first axis.\n\n        .. versionadded:: 1.7.0\n\n        If axis is a tuple of ints, a product is performed on all of the\n        axes specified in the tuple instead of a single axis or all the\n        axes as before.\n    dtype : dtype, optional\n        The type of the returned array, as well as of the accumulator in\n        which the elements are multiplied.  The dtype of `a` is used by\n        default unless `a` has an integer dtype of less precision than the\n        default platform integer.  In that case, if `a` is signed then the\n        platform integer is used while if `a` is unsigned then an unsigned\n        integer of the same precision as the platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in the\n        result as dimensions with size one. With this option, the result\n        will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `prod` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    initial : scalar, optional\n        The starting value for this product. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        Elements to include in the product. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    product_along_axis : ndarray, see `dtype` parameter above.\n        An array shaped as `a` but with the specified axis removed.\n        Returns a reference to `out` if specified.\n\n    See Also\n    --------\n    ndarray.prod : equivalent method\n    ufuncs-output-type\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.  That means that, on a 32-bit platform:\n\n    >>> x = np.array([536870910, 536870910, 536870910, 536870910])\n    >>> np.prod(x)\n    16 # may vary\n\n    The product of an empty array is the neutral element 1:\n\n    >>> np.prod([])\n    1.0\n\n    Examples\n    --------\n    By default, calculate the product of all elements:\n\n    >>> np.prod([1.,2.])\n    2.0\n\n    Even when the input array is two-dimensional:\n\n    >>> np.prod([[1.,2.],[3.,4.]])\n    24.0\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod([[1.,2.],[3.,4.]], axis=1)\n    array([  2.,  12.])\n\n    Or select specific elements to include:\n\n    >>> np.prod([1., np.nan, 3.], where=[True, False, True])\n    3.0\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype == np.uint\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == int\n    True\n\n    You can also start the product with a value other than one:\n\n    >>> np.prod([1, 2], initial=5)\n    10\n    ","^0","^9"],["^ ","^7","load","^8","\n    Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.\n\n    .. warning:: Loading files that contain object arrays uses the ``pickle``\n                 module, which is not secure against erroneous or maliciously\n                 constructed data. Consider passing ``allow_pickle=False`` to\n                 load data that is known not to contain object arrays for the\n                 safer handling of untrusted sources.\n\n    Parameters\n    ----------\n    file : file-like object, string, or pathlib.Path\n        The file to read. File-like objects must support the\n        ``seek()`` and ``read()`` methods. Pickled files require that the\n        file-like object support the ``readline()`` method as well.\n    mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode (see\n        `numpy.memmap` for a detailed description of the modes).  A\n        memory-mapped array is kept on disk. However, it can be accessed\n        and sliced like any ndarray.  Memory mapping is especially useful\n        for accessing small fragments of large files without reading the\n        entire file into memory.\n    allow_pickle : bool, optional\n        Allow loading pickled object arrays stored in npy files. Reasons for\n        disallowing pickles include security, as loading pickled data can\n        execute arbitrary code. If pickles are disallowed, loading object\n        arrays will fail. Default: False\n\n        .. versionchanged:: 1.16.3\n            Made default False in response to CVE-2019-6446.\n\n    fix_imports : bool, optional\n        Only useful when loading Python 2 generated pickled files on Python 3,\n        which includes npy/npz files containing object arrays. If `fix_imports`\n        is True, pickle will try to map the old Python 2 names to the new names\n        used in Python 3.\n    encoding : str, optional\n        What encoding to use when reading Python 2 strings. Only useful when\n        loading Python 2 generated pickled files in Python 3, which includes\n        npy/npz files containing object arrays. Values other than 'latin1',\n        'ASCII', and 'bytes' are not allowed, as they can corrupt numerical\n        data. Default: 'ASCII'\n\n    Returns\n    -------\n    result : array, tuple, dict, etc.\n        Data stored in the file. For ``.npz`` files, the returned instance\n        of NpzFile class must be closed to avoid leaking file descriptors.\n\n    Raises\n    ------\n    IOError\n        If the input file does not exist or cannot be read.\n    ValueError\n        The file contains an object array, but allow_pickle=False given.\n\n    See Also\n    --------\n    save, savez, savez_compressed, loadtxt\n    memmap : Create a memory-map to an array stored in a file on disk.\n    lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.\n\n    Notes\n    -----\n    - If the file contains pickle data, then whatever object is stored\n      in the pickle is returned.\n    - If the file is a ``.npy`` file, then a single array is returned.\n    - If the file is a ``.npz`` file, then a dictionary-like object is\n      returned, containing ``{filename: array}`` key-value pairs, one for\n      each file in the archive.\n    - If the file is a ``.npz`` file, the returned value supports the\n      context manager protocol in a similar fashion to the open function::\n\n        with load('foo.npz') as data:\n            a = data['a']\n\n      The underlying file descriptor is closed when exiting the 'with'\n      block.\n\n    Examples\n    --------\n    Store data to disk, and load it again:\n\n    >>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n    >>> np.load('/tmp/123.npy')\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    Store compressed data to disk, and load it again:\n\n    >>> a=np.array([[1, 2, 3], [4, 5, 6]])\n    >>> b=np.array([1, 2])\n    >>> np.savez('/tmp/123.npz', a=a, b=b)\n    >>> data = np.load('/tmp/123.npz')\n    >>> data['a']\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> data['b']\n    array([1, 2])\n    >>> data.close()\n\n    Mem-map the stored array, and then access the second row\n    directly from disk:\n\n    >>> X = np.load('/tmp/123.npy', mmap_mode='r')\n    >>> X[1, :]\n    memmap([4, 5, 6])\n\n    ","^0","^9"],["^ ","^7","sum","^8","\n    Sum of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Elements to sum.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a sum is performed.  The default,\n        axis=None, will sum all of the elements of the input array.  If\n        axis is negative it counts from the last to the first axis.\n\n        .. versionadded:: 1.7.0\n\n        If axis is a tuple of ints, a sum is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before.\n    dtype : dtype, optional\n        The type of the returned array and of the accumulator in which the\n        elements are summed.  The dtype of `a` is used by default unless `a`\n        has an integer dtype of less precision than the default platform\n        integer.  In that case, if `a` is signed then the platform integer\n        is used while if `a` is unsigned then an unsigned integer of the\n        same precision as the platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `sum` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    initial : scalar, optional\n        Starting value for the sum. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        Elements to include in the sum. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    sum_along_axis : ndarray\n        An array with the same shape as `a`, with the specified\n        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n        is returned.  If an output array is specified, a reference to\n        `out` is returned.\n\n    See Also\n    --------\n    ndarray.sum : Equivalent method.\n\n    add.reduce : Equivalent functionality of `add`.\n\n    cumsum : Cumulative sum of array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    mean, average\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    The sum of an empty array is the neutral element 0:\n\n    >>> np.sum([])\n    0.0\n\n    For floating point numbers the numerical precision of sum (and\n    ``np.add.reduce``) is in general limited by directly adding each number\n    individually to the result causing rounding errors in every step.\n    However, often numpy will use a  numerically better approach (partial\n    pairwise summation) leading to improved precision in many use-cases.\n    This improved precision is always provided when no ``axis`` is given.\n    When ``axis`` is given, it will depend on which axis is summed.\n    Technically, to provide the best speed possible, the improved precision\n    is only used when the summation is along the fast axis in memory.\n    Note that the exact precision may vary depending on other parameters.\n    In contrast to NumPy, Python's ``math.fsum`` function uses a slower but\n    more precise approach to summation.\n    Especially when summing a large number of lower precision floating point\n    numbers, such as ``float32``, numerical errors can become significant.\n    In such cases it can be advisable to use `dtype=\"float64\"` to use a higher\n    precision for the output.\n\n    Examples\n    --------\n    >>> np.sum([0.5, 1.5])\n    2.0\n    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n    1\n    >>> np.sum([[0, 1], [0, 5]])\n    6\n    >>> np.sum([[0, 1], [0, 5]], axis=0)\n    array([0, 6])\n    >>> np.sum([[0, 1], [0, 5]], axis=1)\n    array([1, 5])\n    >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\n    array([1., 5.])\n\n    If the accumulator is too small, overflow occurs:\n\n    >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n    -128\n\n    You can also start the sum with a value other than zero:\n\n    >>> np.sum([10], initial=5)\n    15\n    ","^0","^9"],["^ ","^7","str","^8","str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.","^0","^0"],["^ ","^7","int64","^8","Signed integer type, compatible with Python `int` anc C ``long``.\n    Character code: ``'l'``.\n    Canonical name: ``np.int_``.\n    Alias *on this platform*: ``np.int64``: 64-bit signed integer (-9223372036854775808 to 9223372036854775807).\n    Alias *on this platform*: ``np.intp``: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.","^0","^0"],["^ ","^7","nper","^8","\n    Compute the number of periodic payments.\n\n    .. deprecated:: 1.18\n\n       `nper` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    :class:`decimal.Decimal` type is not supported.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Notes\n    -----\n    The number of periods ``nper`` is computed by solving the equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n    but if ``rate = 0`` then::\n\n     fv + pv + pmt*nper = 0\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n    Examples\n    --------\n    If you only had $150/month to pay towards the loan, how long would it take\n    to pay-off a loan of $8,000 at 7% annual interest?\n\n    >>> print(np.round(np.nper(0.07/12, -150, 8000), 5))\n    64.07335\n\n    So, over 64 months would be required to pay off the loan.\n\n    The same analysis could be done with several different interest rates\n    and/or payments and/or total amounts to produce an entire table.\n\n    >>> np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n    ...                    -150   : -99     : 50    ,\n    ...                    8000   : 9001    : 1000]))\n    array([[[ 64.07334877,  74.06368256],\n            [108.07548412, 127.99022654]],\n           [[ 66.12443902,  76.87897353],\n            [114.70165583, 137.90124779]]])\n\n    ","^0","^9"],["^ ","^7","issubclass_","^8","\n    Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError if one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> np.issubclass_(np.int32, int)\n    False # True on Python 2.7\n    >>> np.issubclass_(np.int32, float)\n    False\n\n    ","^0","^9"],["^ ","^7","long","^8","int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4","^0","^0"],["^ ","^7","longcomplex","^8","Complex number type composed of two extended-precision floating-point\n    numbers.\n    Character code: ``'G'``.\n    Canonical name: ``np.clongdouble``.\n    Alias: ``np.clongfloat``.\n    Alias: ``np.longcomplex``.\n    Alias *on this platform*: ``np.complex256``: Complex number type composed of 2 128-bit extended-precision floating-point numbers.","^0","^0"],["^ ","^7","dot","^8","\n    dot(a, b, out=None)\n\n    Dot product of two arrays. Specifically,\n\n    - If both `a` and `b` are 1-D arrays, it is inner product of vectors\n      (without complex conjugation).\n\n    - If both `a` and `b` are 2-D arrays, it is matrix multiplication,\n      but using :func:`matmul` or ``a @ b`` is preferred.\n\n    - If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`\n      and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.\n\n    - If `a` is an N-D array and `b` is a 1-D array, it is a sum product over\n      the last axis of `a` and `b`.\n\n    - If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a\n      sum product over the last axis of `a` and the second-to-last axis of `b`::\n\n        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])\n\n    Parameters\n    ----------\n    a : array_like\n        First argument.\n    b : array_like\n        Second argument.\n    out : ndarray, optional\n        Output argument. This must have the exact kind that would be returned\n        if it was not used. In particular, it must have the right type, must be\n        C-contiguous, and its dtype must be the dtype that would be returned\n        for `dot(a,b)`. This is a performance feature. Therefore, if these\n        conditions are not met, an exception is raised, instead of attempting\n        to be flexible.\n\n    Returns\n    -------\n    output : ndarray\n        Returns the dot product of `a` and `b`.  If `a` and `b` are both\n        scalars or both 1-D arrays then a scalar is returned; otherwise\n        an array is returned.\n        If `out` is given, then it is returned.\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` is not the same size as\n        the second-to-last dimension of `b`.\n\n    See Also\n    --------\n    vdot : Complex-conjugating dot product.\n    tensordot : Sum products over arbitrary axes.\n    einsum : Einstein summation convention.\n    matmul : '@' operator as method with out parameter.\n\n    Examples\n    --------\n    >>> np.dot(3, 4)\n    12\n\n    Neither argument is complex-conjugated:\n\n    >>> np.dot([2j, 3j], [2j, 3j])\n    (-13+0j)\n\n    For 2-D arrays it is the matrix product:\n\n    >>> a = [[1, 0], [0, 1]]\n    >>> b = [[4, 1], [2, 2]]\n    >>> np.dot(a, b)\n    array([[4, 1],\n           [2, 2]])\n\n    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))\n    >>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n    >>> np.dot(a, b)[2,3,2,1,2,2]\n    499128\n    >>> sum(a[2,3,2,:] * b[1,2,:,2])\n    499128\n\n    ","^0","^9"],["^ ","^7","fv","^8","\n    Compute the future value.\n\n    .. deprecated:: 1.18\n\n       `fv` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Given:\n     * a present value, `pv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value at the end of the `nper` periods\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pmt : scalar or array_like of shape(M, )\n        Payment\n    pv : scalar or array_like of shape(M, )\n        Present value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Future values.  If all input is scalar, returns a scalar float.  If\n        any input is array_like, returns future values for each input element.\n        If multiple inputs are array_like, they all must have the same shape.\n\n    Notes\n    -----\n    The future value is computed by solving the equation::\n\n     fv +\n     pv*(1+rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n     fv + pv + pmt * nper == 0\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n\n    Examples\n    --------\n    What is the future value after 10 years of saving $100 now, with\n    an additional monthly savings of $100.  Assume the interest rate is\n    5% (annually) compounded monthly?\n\n    >>> np.fv(0.05/12, 10*12, -100, -100)\n    15692.928894335748\n\n    By convention, the negative sign represents cash flow out (i.e. money not\n    available today).  Thus, saving $100 a month at 5% annual interest leads\n    to $15,692.93 available to spend in 10 years.\n\n    If any input is array_like, returns an array of equal shape.  Let's\n    compare different interest rates from the example above.\n\n    >>> a = np.array((0.05, 0.06, 0.07))/12\n    >>> np.fv(a, 10*12, -100, -100)\n    array([ 15692.92889434,  16569.87435405,  17509.44688102]) # may vary\n\n    ","^0","^9"],["^ ","^7","trace","^8","\n    Return the sum along diagonals of the array.\n\n    If `a` is 2-D, the sum along its diagonal with the given offset\n    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.\n\n    If `a` has more than two dimensions, then the axes specified by axis1 and\n    axis2 are used to determine the 2-D sub-arrays whose traces are returned.\n    The shape of the resulting array is the same as that of `a` with `axis1`\n    and `axis2` removed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal. Can be both positive\n        and negative. Defaults to 0.\n    axis1, axis2 : int, optional\n        Axes to be used as the first and second axis of the 2-D sub-arrays\n        from which the diagonals should be taken. Defaults are the first two\n        axes of `a`.\n    dtype : dtype, optional\n        Determines the data-type of the returned array and of the accumulator\n        where the elements are summed. If dtype has the value None and `a` is\n        of integer type of precision less than the default integer\n        precision, then the default integer precision is used. Otherwise,\n        the precision is the same as that of `a`.\n    out : ndarray, optional\n        Array into which the output is placed. Its type is preserved and\n        it must be of the right shape to hold the output.\n\n    Returns\n    -------\n    sum_along_diagonals : ndarray\n        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has\n        larger dimensions, then an array of sums along diagonals is returned.\n\n    See Also\n    --------\n    diag, diagonal, diagflat\n\n    Examples\n    --------\n    >>> np.trace(np.eye(3))\n    3.0\n    >>> a = np.arange(8).reshape((2,2,2))\n    >>> np.trace(a)\n    array([6, 8])\n\n    >>> a = np.arange(24).reshape((2,2,2,3))\n    >>> np.trace(a).shape\n    (2, 3)\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","nanargmin","^8","\n    Return the indices of the minimum values in the specified axis ignoring\n    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results\n    cannot be trusted if a slice contains only NaNs and Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmin, nanargmax\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmin(a)\n    0\n    >>> np.nanargmin(a)\n    2\n    >>> np.nanargmin(a, axis=0)\n    array([1, 1])\n    >>> np.nanargmin(a, axis=1)\n    array([1, 0])\n\n    ","^0","^9"],["^ ","^7","cbrt","^8","cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the cube-root of an array, element-wise.\n\n.. versionadded:: 1.10.0\n\nParameters\n----------\nx : array_like\n    The values whose cube-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the cube\n    cube-root of each element in `x`.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\n\nExamples\n--------\n>>> np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])","^0","^;"],["^ ","^7","min_scalar_type","^8","\n    min_scalar_type(a)\n\n    For scalar ``a``, returns the data type with the smallest size\n    and smallest scalar kind which can hold its value.  For non-scalar\n    array ``a``, returns the vector's dtype unmodified.\n\n    Floating point values are not demoted to integers,\n    and complex values are not demoted to floats.\n\n    Parameters\n    ----------\n    a : scalar or array_like\n        The value whose minimal data type is to be found.\n\n    Returns\n    -------\n    out : dtype\n        The minimal data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, promote_types, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.min_scalar_type(10)\n    dtype('uint8')\n\n    >>> np.min_scalar_type(-260)\n    dtype('int16')\n\n    >>> np.min_scalar_type(3.1)\n    dtype('float16')\n\n    >>> np.min_scalar_type(1e50)\n    dtype('float64')\n\n    >>> np.min_scalar_type(np.arange(4,dtype='f8'))\n    dtype('float64')\n\n    ","^0","^9"],["^ ","^7","cross","^8","\n    Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  Ignored if\n        both input vectors have dimension 2, as the return is scalar.\n        By default, the last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.9.0\n\n    Supports full broadcasting of the inputs.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    array(-3)\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the `right-hand rule`.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n\n    ","^0","^9"],["^ ","^8","Capsule objects let you wrap a C \"void *\" pointer in a Python\nobject.  They're a way of passing data through the Python interpreter\nwithout creating your own custom type.\n\nCapsules are used for communication between extension modules.\nThey provide a way for an extension module to export a C interface\nto other extension modules, so that extension modules can use the\nPython import mechanism to link to one another.\n","^0","~:py-capsule"],["^ ","^7","mintypecode","^8","\n    Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must represent the smallest size dtype such\n    that an array of the returned type can handle the data from an array of\n    all types in `typechars` (or if `typechars` is an array, then its\n    dtype.char).\n\n    Parameters\n    ----------\n    typechars : list of str or array_like\n        If a list of strings, each string should represent a dtype.\n        If array_like, the character representation of the array dtype is used.\n    typeset : str or list of str, optional\n        The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'.\n    default : str, optional\n        The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`.\n\n    Returns\n    -------\n    typechar : str\n        The character representing the minimum-size type that was found.\n\n    See Also\n    --------\n    dtype, sctype2char, maximum_sctype\n\n    Examples\n    --------\n    >>> np.mintypecode(['d', 'f', 'S'])\n    'd'\n    >>> x = np.array([1.1, 2-3.j])\n    >>> np.mintypecode(x)\n    'D'\n\n    >>> np.mintypecode('abceh', default='G')\n    'G'\n\n    ","^0","^9"],["^ ","^7","cumprod","^8","\n    Return the cumulative product of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    cumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to out is returned.\n\n    See Also\n    --------\n    ufuncs-output-type\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([1,2,3])\n    >>> np.cumprod(a) # intermediate results 1, 1*2\n    ...               # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumprod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of `a`:\n\n    >>> np.cumprod(a, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of `a`:\n\n    >>> np.cumprod(a,axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n\n    ","^0","^9"],["^ ","^7","repeat","^8","\n    Repeat elements of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    repeats : int or array of ints\n        The number of repetitions for each element.  `repeats` is broadcasted\n        to fit the shape of the given axis.\n    axis : int, optional\n        The axis along which to repeat values.  By default, use the\n        flattened input array, and return a flat output array.\n\n    Returns\n    -------\n    repeated_array : ndarray\n        Output array which has the same shape as `a`, except along\n        the given axis.\n\n    See Also\n    --------\n    tile : Tile an array.\n\n    Examples\n    --------\n    >>> np.repeat(3, 4)\n    array([3, 3, 3, 3])\n    >>> x = np.array([[1,2],[3,4]])\n    >>> np.repeat(x, 2)\n    array([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> np.repeat(x, 3, axis=1)\n    array([[1, 1, 1, 2, 2, 2],\n           [3, 3, 3, 4, 4, 4]])\n    >>> np.repeat(x, [1, 2], axis=0)\n    array([[1, 2],\n           [3, 4],\n           [3, 4]])\n\n    ","^0","^9"],["^ ","^7","matrix","^8","\n    matrix(data, dtype=None, copy=True)\n\n    .. note:: It is no longer recommended to use this class, even for linear\n              algebra. Instead use regular arrays. The class may be removed\n              in the future.\n\n    Returns a matrix from an array-like object, or from a string of data.\n    A matrix is a specialized 2-D array that retains its 2-D nature\n    through operations.  It has certain special operators, such as ``*``\n    (matrix multiplication) and ``**`` (matrix power).\n\n    Parameters\n    ----------\n    data : array_like or string\n       If `data` is a string, it is interpreted as a matrix with commas\n       or spaces separating columns, and semicolons separating rows.\n    dtype : data-type\n       Data-type of the output matrix.\n    copy : bool\n       If `data` is already an `ndarray`, then this flag determines\n       whether the data is copied (the default), or whether a view is\n       constructed.\n\n    See Also\n    --------\n    array\n\n    Examples\n    --------\n    >>> a = np.matrix('1 2; 3 4')\n    >>> a\n    matrix([[1, 2],\n            [3, 4]])\n\n    >>> np.matrix([[1, 2], [3, 4]])\n    matrix([[1, 2],\n            [3, 4]])\n\n    ","^0","^0"],["^ "],["^ ","^7","less_equal","^8","less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 =< x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngreater, less, greater_equal, equal, not_equal\n\nExamples\n--------\n>>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])","^0","^;"],["^ ","^7","kaiser","^8","\n    Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n    beta : float\n        Shape parameter for window.\n\n    Returns\n    -------\n    out : array\n        The window, with the maximum value normalized to one (the value\n        one appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, hanning\n\n    Notes\n    -----\n    The Kaiser window is defined as\n\n    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}\n               \\right)/I_0(\\beta)\n\n    with\n\n    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},\n\n    where :math:`I_0` is the modified zeroth-order Bessel function.\n\n    The Kaiser was named for Jim Kaiser, who discovered a simple\n    approximation to the DPSS window based on Bessel functions.  The Kaiser\n    window is a very good approximation to the Digital Prolate Spheroidal\n    Sequence, or Slepian window, which is the transform which maximizes the\n    energy in the main lobe of the window relative to total energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise NaNs will\n    get returned.\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> np.kaiser(12, 14)\n     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> window = np.kaiser(51, 14)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Kaiser window\")\n    Text(0.5, 1.0, 'Kaiser window')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"Sample\")\n    Text(0.5, 0, 'Sample')\n    >>> plt.show()\n\n    >>> plt.figure()\n    <Figure size 640x480 with 0 Axes>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(mag)\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Kaiser window\")\n    Text(0.5, 1.0, 'Frequency response of Kaiser window')\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    Text(0, 0.5, 'Magnitude [dB]')\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    Text(0.5, 0, 'Normalized frequency [cycles per sample]')\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...) # may vary\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","add_newdoc_ufunc","^8","add_ufunc_docstring(ufunc, new_docstring)\n\n    Replace the docstring for a ufunc with new_docstring.\n    This method will only work if the current docstring for\n    the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)\n\n    Parameters\n    ----------\n    ufunc : numpy.ufunc\n        A ufunc whose current doc is NULL.\n    new_docstring : string\n        The new docstring for the ufunc.\n\n    Notes\n    -----\n    This method allocates memory for new_docstring on\n    the heap. Technically this creates a mempory leak, since this\n    memory will not be reclaimed until the end of the program\n    even if the ufunc itself is removed. However this will only\n    be a problem if the user is repeatedly creating ufuncs with\n    no documentation, adding documentation via add_newdoc_ufunc,\n    and then throwing away the ufunc.","^0","^?"],["^ ","^7","memmap","^8","Create a memory-map to an array stored in a *binary* file on disk.\n\n    Memory-mapped files are used for accessing small segments of large files\n    on disk, without reading the entire file into memory.  NumPy's\n    memmap's are array-like objects.  This differs from Python's ``mmap``\n    module, which uses file-like objects.\n\n    This subclass of ndarray has some unpleasant interactions with\n    some operations, because it doesn't quite fit properly as a subclass.\n    An alternative to using this subclass is to create the ``mmap``\n    object yourself, then create an ndarray with ndarray.__new__ directly,\n    passing the object created in its 'buffer=' parameter.\n\n    This class may at some point be turned into a factory function\n    which returns a view into an mmap buffer.\n\n    Delete the memmap instance to close the memmap file.\n\n\n    Parameters\n    ----------\n    filename : str, file-like object, or pathlib.Path instance\n        The file name or file object to be used as the array data buffer.\n    dtype : data-type, optional\n        The data-type used to interpret the file contents.\n        Default is `uint8`.\n    mode : {'r+', 'r', 'w+', 'c'}, optional\n        The file is opened in this mode:\n\n        +------+-------------------------------------------------------------+\n        | 'r'  | Open existing file for reading only.                        |\n        +------+-------------------------------------------------------------+\n        | 'r+' | Open existing file for reading and writing.                 |\n        +------+-------------------------------------------------------------+\n        | 'w+' | Create or overwrite existing file for reading and writing.  |\n        +------+-------------------------------------------------------------+\n        | 'c'  | Copy-on-write: assignments affect data in memory, but       |\n        |      | changes are not saved to disk.  The file on disk is         |\n        |      | read-only.                                                  |\n        +------+-------------------------------------------------------------+\n\n        Default is 'r+'.\n    offset : int, optional\n        In the file, array data starts at this offset. Since `offset` is\n        measured in bytes, it should normally be a multiple of the byte-size\n        of `dtype`. When ``mode != 'r'``, even positive offsets beyond end of\n        file are valid; The file will be extended to accommodate the\n        additional data. By default, ``memmap`` will start at the beginning of\n        the file, even if ``filename`` is a file pointer ``fp`` and\n        ``fp.tell() != 0``.\n    shape : tuple, optional\n        The desired shape of the array. If ``mode == 'r'`` and the number\n        of remaining bytes after `offset` is not a multiple of the byte-size\n        of `dtype`, you must specify `shape`. By default, the returned array\n        will be 1-D with the number of elements determined by file size\n        and data-type.\n    order : {'C', 'F'}, optional\n        Specify the order of the ndarray memory layout:\n        :term:`row-major`, C-style or :term:`column-major`,\n        Fortran-style.  This only has an effect if the shape is\n        greater than 1-D.  The default order is 'C'.\n\n    Attributes\n    ----------\n    filename : str or pathlib.Path instance\n        Path to the mapped file.\n    offset : int\n        Offset position in the file.\n    mode : str\n        File mode.\n\n    Methods\n    -------\n    flush\n        Flush any changes in memory to file on disk.\n        When you delete a memmap object, flush is called first to write\n        changes to disk before removing the object.\n\n\n    See also\n    --------\n    lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.\n\n    Notes\n    -----\n    The memmap object can be used anywhere an ndarray is accepted.\n    Given a memmap ``fp``, ``isinstance(fp, numpy.ndarray)`` returns\n    ``True``.\n    \n    Memory-mapped files cannot be larger than 2GB on 32-bit systems.\n\n    When a memmap causes a file to be created or extended beyond its\n    current size in the filesystem, the contents of the new part are\n    unspecified. On systems with POSIX filesystem semantics, the extended\n    part will be filled with zero bytes.\n\n    Examples\n    --------\n    >>> data = np.arange(12, dtype='float32')\n    >>> data.resize((3,4))\n\n    This example uses a temporary file so that doctest doesn't write\n    files to your directory. You would use a 'normal' filename.\n\n    >>> from tempfile import mkdtemp\n    >>> import os.path as path\n    >>> filename = path.join(mkdtemp(), 'newfile.dat')\n\n    Create a memmap with dtype and shape that matches our data:\n\n    >>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n    >>> fp\n    memmap([[0., 0., 0., 0.],\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.]], dtype=float32)\n\n    Write data to memmap array:\n\n    >>> fp[:] = data[:]\n    >>> fp\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    >>> fp.filename == path.abspath(filename)\n    True\n\n    Deletion flushes memory changes to disk before removing the object:\n\n    >>> del fp\n\n    Load the memmap and verify data was stored:\n\n    >>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n    >>> newfp\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    Read-only memmap:\n\n    >>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n    >>> fpr.flags.writeable\n    False\n\n    Copy-on-write memmap:\n\n    >>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n    >>> fpc.flags.writeable\n    True\n\n    It's possible to assign to copy-on-write array, but values are only\n    written into the memory copy of the array, and not written to disk:\n\n    >>> fpc\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n    >>> fpc[0,:] = 0\n    >>> fpc\n    memmap([[  0.,   0.,   0.,   0.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    File on disk is unchanged:\n\n    >>> fpr\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    Offset into a memmap:\n\n    >>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n    >>> fpo\n    memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)\n\n    ","^0","^0"],["^ ","^8","","^0","^<"],["^ ","^7","nonzero","^8","\n    Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`,\n    containing the indices of the non-zero elements in that\n    dimension. The values in `a` are always tested and returned in\n    row-major, C-style order.\n\n    To group the indices by element, rather than dimension, use `argwhere`,\n    which returns a row for each non-zero element.\n\n    .. note::\n\n       When called on a zero-d array or scalar, ``nonzero(a)`` is treated\n       as ``nonzero(atleast1d(a))``.\n\n       .. deprecated:: 1.17.0\n\n          Use `atleast1d` explicitly if this behavior is deliberate.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero :\n        Return indices that are non-zero in the flattened version of the input\n        array.\n    ndarray.nonzero :\n        Equivalent ndarray method.\n    count_nonzero :\n        Counts the number of non-zero elements in the input array.\n\n    Notes\n    -----\n    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is\n    recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which\n    will correctly handle 0-d arrays.\n\n    Examples\n    --------\n    >>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])\n    >>> x\n    array([[3, 0, 0],\n           [0, 4, 0],\n           [5, 6, 0]])\n    >>> np.nonzero(x)\n    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))\n\n    >>> x[np.nonzero(x)]\n    array([3, 4, 5, 6])\n    >>> np.transpose(np.nonzero(x))\n    array([[0, 0],\n           [1, 1],\n           [2, 0],\n           [2, 1]])\n\n    A common use for ``nonzero`` is to find the indices of an array, where\n    a condition is True.  Given an array `a`, the condition `a` > 3 is a\n    boolean array and since False is interpreted as 0, np.nonzero(a > 3)\n    yields the indices of the `a` where the condition is true.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> a > 3\n    array([[False, False, False],\n           [ True,  True,  True],\n           [ True,  True,  True]])\n    >>> np.nonzero(a > 3)\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    Using this result to index `a` is equivalent to using the mask directly:\n\n    >>> a[np.nonzero(a > 3)]\n    array([4, 5, 6, 7, 8, 9])\n    >>> a[a > 3]  # prefer this spelling\n    array([4, 5, 6, 7, 8, 9])\n\n    ``nonzero`` can also be called as a method of the array.\n\n    >>> (a > 3).nonzero()\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    ","^0","^9"],["^ ","^8","Concrete implementation of SourceLoader using the file system.","^0","~:source-file-loader"],["^ ","^7","rollaxis","^8","\n    Roll the specified axis backwards, until it lies in a given position.\n\n    This function continues to be supported for backward compatibility, but you\n    should prefer `moveaxis`. The `moveaxis` function was added in NumPy\n    1.11.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to roll backwards.  The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        The axis is rolled until it lies before this position.  The default,\n        0, results in a \"complete\" roll.\n\n    Returns\n    -------\n    res : ndarray\n        For NumPy >= 1.10.0 a view of `a` is always returned. For earlier\n        NumPy versions a view of `a` is returned only if the order of the\n        axes is changed, otherwise the input array is returned.\n\n    See Also\n    --------\n    moveaxis : Move array axes to new positions.\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n\n    ","^0","^9"],["^ ","^7","ppmt","^8","\n    Compute the payment against loan principal.\n\n    .. deprecated:: 1.18\n\n       `ppmt` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    per : array_like, int\n        Amount paid against the loan changes.  The `per` is the period of\n        interest.\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    See Also\n    --------\n    pmt, pv, ipmt\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","isnat","^8","isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for NaT (not a time) and return result as a boolean array.\n\n.. versionadded:: 1.13.0\n\nParameters\n----------\nx : array_like\n    Input array with datetime or timedelta data type.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    True where ``x`` is NaT, false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisnan, isinf, isneginf, isposinf, isfinite\n\nExamples\n--------\n>>> np.isnat(np.datetime64(\"NaT\"))\nTrue\n>>> np.isnat(np.datetime64(\"2016-01-01\"))\nFalse\n>>> np.isnat(np.array([\"NaT\", \"2016-01-01\"], dtype=\"datetime64[ns]\"))\narray([ True, False])","^0","^;"],["^ ","^7","roots","^8","\n    Return the roots of a polynomial with coefficients given in p.\n\n    The values in the rank-1 array `p` are coefficients of a polynomial.\n    If the length of `p` is n+1 then the polynomial is described by::\n\n      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n    Parameters\n    ----------\n    p : array_like\n        Rank-1 array of polynomial coefficients.\n\n    Returns\n    -------\n    out : ndarray\n        An array containing the roots of the polynomial.\n\n    Raises\n    ------\n    ValueError\n        When `p` cannot be converted to a rank-1 array.\n\n    See also\n    --------\n    poly : Find the coefficients of a polynomial with a given sequence\n           of roots.\n    polyval : Compute polynomial values.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    The algorithm relies on computing the eigenvalues of the\n    companion matrix [1]_.\n\n    References\n    ----------\n    .. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:\n        Cambridge University Press, 1999, pp. 146-7.\n\n    Examples\n    --------\n    >>> coeff = [3.2, 2, 1]\n    >>> np.roots(coeff)\n    array([-0.3125+0.46351241j, -0.3125-0.46351241j])\n\n    ","^0","^9"],["^ ","^7","max","^8","\n    Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to operate.  By default, flattened input is\n        used.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, the maximum is selected over multiple axes,\n        instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `amax` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    initial : scalar, optional\n        The minimum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        Elements to compare for the maximum. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    amin :\n        The minimum value of an array along a given axis, propagating any NaNs.\n    nanmax :\n        The maximum value of an array along a given axis, ignoring any NaNs.\n    maximum :\n        Element-wise maximum of two arrays, propagating any NaNs.\n    fmax :\n        Element-wise maximum of two arrays, ignoring any NaNs.\n    argmax :\n        Return the indices of the maximum values.\n\n    nanmin, minimum, fmin\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well. To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Don't use `amax` for element-wise comparison of 2 arrays; when\n    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than\n    ``amax(a, axis=0)``.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)           # Maximum of the flattened array\n    3\n    >>> np.amax(a, axis=0)   # Maxima along the first axis\n    array([2, 3])\n    >>> np.amax(a, axis=1)   # Maxima along the second axis\n    array([1, 3])\n    >>> np.amax(a, where=[False, True], initial=-1, axis=0)\n    array([-1,  3])\n    >>> b = np.arange(5, dtype=float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.amax(b, where=~np.isnan(b), initial=-1)\n    4.0\n    >>> np.nanmax(b)\n    4.0\n\n    You can use an initial value to compute the maximum of an empty slice, or\n    to initialize it to a different value:\n\n    >>> np.max([[-50], [10]], axis=-1, initial=0)\n    array([ 0, 10])\n\n    Notice that the initial value is used as one of the elements for which the\n    maximum is determined, unlike for the default argument Python's max\n    function, which is only used for empty iterables.\n\n    >>> np.max([5], initial=6)\n    6\n    >>> max([5], default=6)\n    5\n    ","^0","^9"],["^ ","^7","info","^8","\n    Get help information for a function, class, or module.\n\n    Parameters\n    ----------\n    object : object or str, optional\n        Input object or name to get information about. If `object` is a\n        numpy object, its docstring is given. If it is a string, available\n        modules are searched for matching objects.  If None, information\n        about `info` itself is returned.\n    maxwidth : int, optional\n        Printing width.\n    output : file like object, optional\n        File like object that the output is written to, default is\n        ``stdout``.  The object has to be opened in 'w' or 'a' mode.\n    toplevel : str, optional\n        Start search at this level.\n\n    See Also\n    --------\n    source, lookfor\n\n    Notes\n    -----\n    When used interactively with an object, ``np.info(obj)`` is equivalent\n    to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython\n    prompt.\n\n    Examples\n    --------\n    >>> np.info(np.polyval) # doctest: +SKIP\n       polyval(p, x)\n         Evaluate the polynomial p at x.\n         ...\n\n    When using a string for `object` it is possible to get multiple results.\n\n    >>> np.info('fft') # doctest: +SKIP\n         *** Found in numpy ***\n    Core FFT routines\n    ...\n         *** Found in numpy.fft ***\n     fft(a, n=None, axis=-1)\n    ...\n         *** Repeat reference found in numpy.fft.fftpack ***\n         *** Total of 3 references found. ***\n\n    ","^0","^9"],["^ ","^7","numpy.compat","^8","\nCompatibility module.\n\nThis module contains duplicated code from Python itself or 3rd party\nextensions, which may be included for the following reasons:\n\n  * compatibility\n  * we may only need a small subset of the copied library/module\n\n","^0","^>"],["^ ","^7","vsplit","^8","\n    Split an array into multiple sub-arrays vertically (row-wise).\n\n    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent\n    to ``split`` with `axis=0` (default), the array is always split along the\n    first axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[ 0.,   1.,   2.,   3.],\n           [ 4.,   5.,   6.,   7.],\n           [ 8.,   9.,  10.,  11.],\n           [12.,  13.,  14.,  15.]])\n    >>> np.vsplit(x, 2)\n    [array([[0., 1., 2., 3.],\n           [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],\n           [12., 13., 14., 15.]])]\n    >>> np.vsplit(x, np.array([3, 6]))\n    [array([[ 0.,  1.,  2.,  3.],\n           [ 4.,  5.,  6.,  7.],\n           [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]\n\n    With a higher dimensional array the split is still along the first axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[0.,  1.],\n            [2.,  3.]],\n           [[4.,  5.],\n            [6.,  7.]]])\n    >>> np.vsplit(x, 2)\n    [array([[[0., 1.],\n            [2., 3.]]]), array([[[4., 5.],\n            [6., 7.]]])]\n\n    ","^0","^9"],["^ ","^7","polysub","^8","\n    Difference (subtraction) of two polynomials.\n\n    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.\n    `a1` and `a2` can be either array_like sequences of the polynomials'\n    coefficients (including coefficients equal to zero), or `poly1d` objects.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d\n        Minuend and subtrahend polynomials, respectively.\n\n    Returns\n    -------\n    out : ndarray or poly1d\n        Array or `poly1d` object of the difference polynomial's coefficients.\n\n    See Also\n    --------\n    polyval, polydiv, polymul, polyadd\n\n    Examples\n    --------\n    .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\n\n    >>> np.polysub([2, 10, -2], [3, 10, -4])\n    array([-1,  0,  2])\n\n    ","^0","^9"],["^ ","^7","array_equal","^8","\n    True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n\n    ","^0","^9"],["^ ","^7","linspace","^8","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","mat","^8","\n    Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n    dtype : data-type\n       Data-type of the output matrix.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n\n    ","^0","^9"],["^ ","^7","frombuffer","^8","frombuffer(buffer, dtype=float, count=-1, offset=0)\n\n    Interpret a buffer as a 1-dimensional array.\n\n    Parameters\n    ----------\n    buffer : buffer_like\n        An object that exposes the buffer interface.\n    dtype : data-type, optional\n        Data-type of the returned array; default: float.\n    count : int, optional\n        Number of items to read. ``-1`` means all data in the buffer.\n    offset : int, optional\n        Start reading the buffer from this offset (in bytes); default: 0.\n\n    Notes\n    -----\n    If the buffer has data that is not in machine byte-order, this should\n    be specified as part of the data-type, e.g.::\n\n      >>> dt = np.dtype(int)\n      >>> dt = dt.newbyteorder('>')\n      >>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP\n\n    The data of the resulting array will not be byteswapped, but will be\n    interpreted correctly.\n\n    Examples\n    --------\n    >>> s = b'hello world'\n    >>> np.frombuffer(s, dtype='S1', count=5, offset=6)\n    array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n    >>> np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\n    array([1, 2], dtype=uint8)\n    >>> np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\n    array([1, 2, 3], dtype=uint8)","^0","^?"],["^ ","^7","flatiter","^8","Flat iterator object to iterate over arrays.\n\n    A `flatiter` iterator is returned by ``x.flat`` for any array `x`.\n    It allows iterating over the array as if it were a 1-D array,\n    either in a for-loop or by calling its `next` method.\n\n    Iteration is done in row-major, C-style order (the last\n    index varying the fastest). The iterator can also be indexed using\n    basic slicing or advanced indexing.\n\n    See Also\n    --------\n    ndarray.flat : Return a flat iterator over an array.\n    ndarray.flatten : Returns a flattened copy of an array.\n\n    Notes\n    -----\n    A `flatiter` iterator can not be constructed directly from Python code\n    by calling the `flatiter` constructor.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> fl = x.flat\n    >>> type(fl)\n    <class 'numpy.flatiter'>\n    >>> for item in fl:\n    ...     print(item)\n    ...\n    0\n    1\n    2\n    3\n    4\n    5\n\n    >>> fl[2:4]\n    array([2, 3])","^0","^0"],["^ ","^7","setbufsize","^8","\n    Set the size of the buffer used in ufuncs.\n\n    Parameters\n    ----------\n    size : int\n        Size of buffer.\n\n    ","^0","^9"],["^ ","^8","","^0","^:"],["^ ","^8","Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.","^0","~:list"],["^ ","^7","busday_count","^8","\n    busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)\n\n    Counts the number of valid days between `begindates` and\n    `enddates`, not including the day of `enddates`.\n\n    If ``enddates`` specifies a date value that is earlier than the\n    corresponding ``begindates`` date value, the count will be negative.\n\n    .. versionadded:: 1.7.0\n\n    Parameters\n    ----------\n    begindates : array_like of datetime64[D]\n        The array of the first dates for counting.\n    enddates : array_like of datetime64[D]\n        The array of the end dates for counting, which are excluded\n        from the count themselves.\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates.  They may be\n        specified in any order, and NaT (not-a-time) dates are ignored.\n        This list is saved in a normalized form that is suited for\n        fast calculations of valid days.\n    busdaycal : busdaycalendar, optional\n        A `busdaycalendar` object which specifies the valid days. If this\n        parameter is provided, neither weekmask nor holidays may be\n        provided.\n    out : array of int, optional\n        If provided, this array is filled with the result.\n\n    Returns\n    -------\n    out : array of int\n        An array with a shape from broadcasting ``begindates`` and ``enddates``\n        together, containing the number of valid days between\n        the begin and end dates.\n\n    See Also\n    --------\n    busdaycalendar: An object that specifies a custom set of valid days.\n    is_busday : Returns a boolean array indicating valid days.\n    busday_offset : Applies an offset counted in valid days.\n\n    Examples\n    --------\n    >>> # Number of weekdays in January 2011\n    ... np.busday_count('2011-01', '2011-02')\n    21\n    >>> # Number of weekdays in 2011\n    >>> np.busday_count('2011', '2012')\n    260\n    >>> # Number of Saturdays in 2011\n    ... np.busday_count('2011', '2012', weekmask='Sat')\n    53\n    ","^0","^9"],["^ ","^7","polyint","^8","\n    Return an antiderivative (indefinite integral) of a polynomial.\n\n    The returned order `m` antiderivative `P` of polynomial `p` satisfies\n    :math:`\\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\n    integration constants `k`. The constants determine the low-order\n    polynomial part\n\n    .. math:: \\frac{k_{m-1}}{0!} x^0 + \\ldots + \\frac{k_0}{(m-1)!}x^{m-1}\n\n    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.\n\n    Parameters\n    ----------\n    p : array_like or poly1d\n        Polynomial to integrate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of the antiderivative. (Default: 1)\n    k : list of `m` scalars or scalar, optional\n        Integration constants. They are given in the order of integration:\n        those corresponding to highest-order terms come first.\n\n        If ``None`` (default), all constants are assumed to be zero.\n        If `m = 1`, a single scalar can be given instead of a list.\n\n    See Also\n    --------\n    polyder : derivative of a polynomial\n    poly1d.integ : equivalent method\n\n    Examples\n    --------\n    The defining property of the antiderivative:\n\n    >>> p = np.poly1d([1,1,1])\n    >>> P = np.polyint(p)\n    >>> P\n     poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary\n    >>> np.polyder(P) == p\n    True\n\n    The integration constants default to zero, but can be specified:\n\n    >>> P = np.polyint(p, 3)\n    >>> P(0)\n    0.0\n    >>> np.polyder(P)(0)\n    0.0\n    >>> np.polyder(P, 2)(0)\n    0.0\n    >>> P = np.polyint(p, 3, k=[6,5,3])\n    >>> P\n    poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary\n\n    Note that 3 = 6 / 2!, and that the constants are given in the order of\n    integrations. Constant of the highest-order polynomial term comes first:\n\n    >>> np.polyder(P, 2)(0)\n    6.0\n    >>> np.polyder(P, 1)(0)\n    5.0\n    >>> P(0)\n    3.0\n\n    ","^0","^9"],["^ ","^7","maximum","^8","maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise maximum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The maximum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nminimum :\n    Element-wise minimum of two arrays, propagates NaNs.\nfmax :\n    Element-wise maximum of two arrays, ignores NaNs.\namax :\n    The maximum value of an array along a given axis, propagates NaNs.\nnanmax :\n    The maximum value of an array along a given axis, ignores NaNs.\n\nfmin, amin, nanmin\n\nNotes\n-----\nThe maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when\nneither x1 nor x2 are nans, but it is faster and does proper\nbroadcasting.\n\nExamples\n--------\n>>> np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n\n>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([nan, nan, nan])\n>>> np.maximum(np.Inf, 1)\ninf","^0","^;"],["^ ","^7","negative","^8","negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNumerical negative, element-wise.\n\nParameters\n----------\nx : array_like or scalar\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    Returned array or scalar: `y = -x`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.negative([1.,-1.])\narray([-1.,  1.])","^0","^;"],["^ ","^7","diagonal","^8","\n    Return specified diagonals.\n\n    If `a` is 2-D, returns the diagonal of `a` with the given offset,\n    i.e., the collection of elements of the form ``a[i, i+offset]``.  If\n    `a` has more than two dimensions, then the axes specified by `axis1`\n    and `axis2` are used to determine the 2-D sub-array whose diagonal is\n    returned.  The shape of the resulting array can be determined by\n    removing `axis1` and `axis2` and appending an index to the right equal\n    to the size of the resulting diagonals.\n\n    In versions of NumPy prior to 1.7, this function always returned a new,\n    independent array containing a copy of the values in the diagonal.\n\n    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,\n    but depending on this fact is deprecated. Writing to the resulting\n    array continues to work as it used to, but a FutureWarning is issued.\n\n    Starting in NumPy 1.9 it returns a read-only view on the original array.\n    Attempting to write to the resulting array will produce an error.\n\n    In some future release, it will return a read/write view and writing to\n    the returned array will alter your original array.  The returned array\n    will have the same type as the input array.\n\n    If you don't write to the array returned by this function, then you can\n    just ignore all of the above.\n\n    If you depend on the current behavior, then we suggest copying the\n    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead\n    of just ``np.diagonal(a)``. This will work with both past and future\n    versions of NumPy.\n\n    Parameters\n    ----------\n    a : array_like\n        Array from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal.  Can be positive or\n        negative.  Defaults to main diagonal (0).\n    axis1 : int, optional\n        Axis to be used as the first axis of the 2-D sub-arrays from which\n        the diagonals should be taken.  Defaults to first axis (0).\n    axis2 : int, optional\n        Axis to be used as the second axis of the 2-D sub-arrays from\n        which the diagonals should be taken. Defaults to second axis (1).\n\n    Returns\n    -------\n    array_of_diagonals : ndarray\n        If `a` is 2-D, then a 1-D array containing the diagonal and of the\n        same type as `a` is returned unless `a` is a `matrix`, in which case\n        a 1-D array rather than a (2-D) `matrix` is returned in order to\n        maintain backward compatibility.\n\n        If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`\n        are removed, and a new axis inserted at the end corresponding to the\n        diagonal.\n\n    Raises\n    ------\n    ValueError\n        If the dimension of `a` is less than 2.\n\n    See Also\n    --------\n    diag : MATLAB work-a-like for 1-D and 2-D arrays.\n    diagflat : Create diagonal arrays.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape(2,2)\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> a.diagonal()\n    array([0, 3])\n    >>> a.diagonal(1)\n    array([1])\n\n    A 3-D example:\n\n    >>> a = np.arange(8).reshape(2,2,2); a\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> a.diagonal(0,  # Main diagonals of two arrays created by skipping\n    ...            0,  # across the outer(left)-most axis last and\n    ...            1)  # the \"middle\" (row) axis first.\n    array([[0, 6],\n           [1, 7]])\n\n    The sub-arrays whose main diagonals we just obtained; note that each\n    corresponds to fixing the right-most (column) axis, and that the\n    diagonals are \"packed\" in rows.\n\n    >>> a[:,:,0]  # main diagonal is [0 6]\n    array([[0, 2],\n           [4, 6]])\n    >>> a[:,:,1]  # main diagonal is [1 7]\n    array([[1, 3],\n           [5, 7]])\n\n    The anti-diagonal can be obtained by reversing the order of elements\n    using either `numpy.flipud` or `numpy.fliplr`.\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> np.fliplr(a).diagonal()  # Horizontal flip\n    array([2, 4, 6])\n    >>> np.flipud(a).diagonal()  # Vertical flip\n    array([6, 4, 2])\n\n    Note that the order in which the diagonal is retrieved varies depending\n    on the flip function.\n    ","^0","^9"],["^ ","^7","ipmt","^8","\n    Compute the interest portion of a payment.\n\n    .. deprecated:: 1.18\n\n       `ipmt` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    per : scalar or array_like of shape(M, )\n        Interest paid against the loan changes during the life or the loan.\n        The `per` is the payment period to calculate the interest amount.\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pv : scalar or array_like of shape(M, )\n        Present value\n    fv : scalar or array_like of shape(M, ), optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Interest portion of payment.  If all input is scalar, returns a scalar\n        float.  If any input is array_like, returns interest payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    See Also\n    --------\n    ppmt, pmt, pv\n\n    Notes\n    -----\n    The total payment is made up of payment against principal plus interest.\n\n    ``pmt = ppmt + ipmt``\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n    Examples\n    --------\n    What is the amortization schedule for a 1 year loan of $2500 at\n    8.24% interest per year compounded monthly?\n\n    >>> principal = 2500.00\n\n    The 'per' variable represents the periods of the loan.  Remember that\n    financial equations start the period count at 1!\n\n    >>> per = np.arange(1*12) + 1\n    >>> ipmt = np.ipmt(0.0824/12, per, 1*12, principal)\n    >>> ppmt = np.ppmt(0.0824/12, per, 1*12, principal)\n\n    Each element of the sum of the 'ipmt' and 'ppmt' arrays should equal\n    'pmt'.\n\n    >>> pmt = np.pmt(0.0824/12, 1*12, principal)\n    >>> np.allclose(ipmt + ppmt, pmt)\n    True\n\n    >>> fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'\n    >>> for payment in per:\n    ...     index = payment - 1\n    ...     principal = principal + ppmt[index]\n    ...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))\n     1  -200.58   -17.17  2299.42\n     2  -201.96   -15.79  2097.46\n     3  -203.35   -14.40  1894.11\n     4  -204.74   -13.01  1689.37\n     5  -206.15   -11.60  1483.22\n     6  -207.56   -10.18  1275.66\n     7  -208.99    -8.76  1066.67\n     8  -210.42    -7.32   856.25\n     9  -211.87    -5.88   644.38\n    10  -213.32    -4.42   431.05\n    11  -214.79    -2.96   216.26\n    12  -216.26    -1.49    -0.00\n\n    >>> interestpd = np.sum(ipmt)\n    >>> np.round(interestpd, 2)\n    -112.98\n\n    ","^0","^9"],["^ ","^7","einsum_path","^8","\n    einsum_path(subscripts, *operands, optimize='greedy')\n\n    Evaluates the lowest cost contraction order for an einsum expression by\n    considering the creation of intermediate arrays.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation.\n    *operands : list of array_like\n        These are the arrays for the operation.\n    optimize : {bool, list, tuple, 'greedy', 'optimal'}\n        Choose the type of path. If a tuple is provided, the second argument is\n        assumed to be the maximum intermediate size created. If only a single\n        argument is provided the largest input or output array size is used\n        as a maximum intermediate size.\n\n        * if a list is given that starts with ``einsum_path``, uses this as the\n          contraction path\n        * if False no optimization is taken\n        * if True defaults to the 'greedy' algorithm\n        * 'optimal' An algorithm that combinatorially explores all possible\n          ways of contracting the listed tensors and choosest the least costly\n          path. Scales exponentially with the number of terms in the\n          contraction.\n        * 'greedy' An algorithm that chooses the best pair contraction\n          at each step. Effectively, this algorithm searches the largest inner,\n          Hadamard, and then outer products at each step. Scales cubically with\n          the number of terms in the contraction. Equivalent to the 'optimal'\n          path for most contractions.\n\n        Default is 'greedy'.\n\n    Returns\n    -------\n    path : list of tuples\n        A list representation of the einsum path.\n    string_repr : str\n        A printable representation of the einsum path.\n\n    Notes\n    -----\n    The resulting path indicates which terms of the input contraction should be\n    contracted first, the result of this contraction is then appended to the\n    end of the contraction list. This list can then be iterated over until all\n    intermediate contractions are complete.\n\n    See Also\n    --------\n    einsum, linalg.multi_dot\n\n    Examples\n    --------\n\n    We can begin with a chain dot example. In this case, it is optimal to\n    contract the ``b`` and ``c`` tensors first as represented by the first\n    element of the path ``(1, 2)``. The resulting tensor is added to the end\n    of the contraction and the remaining contraction ``(0, 1)`` is then\n    completed.\n\n    >>> np.random.seed(123)\n    >>> a = np.random.rand(2, 2)\n    >>> b = np.random.rand(2, 5)\n    >>> c = np.random.rand(5, 2)\n    >>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')\n    >>> print(path_info[0])\n    ['einsum_path', (1, 2), (0, 1)]\n    >>> print(path_info[1])\n      Complete contraction:  ij,jk,kl->il # may vary\n             Naive scaling:  4\n         Optimized scaling:  3\n          Naive FLOP count:  1.600e+02\n      Optimized FLOP count:  5.600e+01\n       Theoretical speedup:  2.857\n      Largest intermediate:  4.000e+00 elements\n    -------------------------------------------------------------------------\n    scaling                  current                                remaining\n    -------------------------------------------------------------------------\n       3                   kl,jk->jl                                ij,jl->il\n       3                   jl,ij->il                                   il->il\n\n\n    A more complex index transformation example.\n\n    >>> I = np.random.rand(10, 10, 10, 10)\n    >>> C = np.random.rand(10, 10)\n    >>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,\n    ...                            optimize='greedy')\n\n    >>> print(path_info[0])\n    ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]\n    >>> print(path_info[1]) \n      Complete contraction:  ea,fb,abcd,gc,hd->efgh # may vary\n             Naive scaling:  8\n         Optimized scaling:  5\n          Naive FLOP count:  8.000e+08\n      Optimized FLOP count:  8.000e+05\n       Theoretical speedup:  1000.000\n      Largest intermediate:  1.000e+04 elements\n    --------------------------------------------------------------------------\n    scaling                  current                                remaining\n    --------------------------------------------------------------------------\n       5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh\n       5               bcde,fb->cdef                         gc,hd,cdef->efgh\n       5               cdef,gc->defg                            hd,defg->efgh\n       5               defg,hd->efgh                               efgh->efgh\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","require","^8","\n    Return an ndarray of the provided type that satisfies requirements.\n\n    This function is useful to be sure that an array with the correct flags\n    is returned for passing to compiled code (perhaps through ctypes).\n\n    Parameters\n    ----------\n    a : array_like\n       The object to be converted to a type-and-requirement-satisfying array.\n    dtype : data-type\n       The required data-type. If None preserve the current dtype. If your\n       application requires the data to be in native byteorder, include\n       a byteorder specification as a part of the dtype specification.\n    requirements : str or list of str\n       The requirements list can be any of the following\n\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\n       * 'WRITEABLE' ('W')    - ensure a writable array\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\n\n    Returns\n    -------\n    out : ndarray\n        Array with specified requirements and type if given.\n\n    See Also\n    --------\n    asarray : Convert input to an ndarray.\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Notes\n    -----\n    The returned array will be guaranteed to have the listed requirements\n    by making a copy if needed.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : False\n      WRITEABLE : True\n      ALIGNED : True\n      WRITEBACKIFCOPY : False\n      UPDATEIFCOPY : False\n\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n    >>> y.flags\n      C_CONTIGUOUS : False\n      F_CONTIGUOUS : True\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      WRITEBACKIFCOPY : False\n      UPDATEIFCOPY : False\n\n    ","^0","^9"],["^ ","^7","nancumsum","^8","\n    Return the cumulative sum of array elements over a given axis treating Not a\n    Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are\n    encountered and leading NaNs are replaced by zeros.\n\n    Zeros are returned for slices that are all-NaN or empty.\n\n    .. versionadded:: 1.12.0\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See `ufuncs-output-type` for\n        more details.\n\n    Returns\n    -------\n    nancumsum : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which it is returned. The result has the same\n        size as `a`, and the same shape as `a` if `axis` is not None\n        or `a` is a 1-d array.\n\n    See Also\n    --------\n    numpy.cumsum : Cumulative sum across array propagating NaNs.\n    isnan : Show which elements are NaN.\n\n    Examples\n    --------\n    >>> np.nancumsum(1)\n    array([1])\n    >>> np.nancumsum([1])\n    array([1])\n    >>> np.nancumsum([1, np.nan])\n    array([1.,  1.])\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nancumsum(a)\n    array([1.,  3.,  6.,  6.])\n    >>> np.nancumsum(a, axis=0)\n    array([[1.,  2.],\n           [4.,  2.]])\n    >>> np.nancumsum(a, axis=1)\n    array([[1.,  3.],\n           [3.,  3.]])\n\n    ","^0","^9"],["^ ","^7","clongfloat","^8","Complex number type composed of two extended-precision floating-point\n    numbers.\n    Character code: ``'G'``.\n    Canonical name: ``np.clongdouble``.\n    Alias: ``np.clongfloat``.\n    Alias: ``np.longcomplex``.\n    Alias *on this platform*: ``np.complex256``: Complex number type composed of 2 128-bit extended-precision floating-point numbers.","^0","^0"],["^ ","^7","isnan","^8","isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for NaN and return result as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    True where ``x`` is NaN, false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisinf, isneginf, isposinf, isfinite, isnat\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\n\nExamples\n--------\n>>> np.isnan(np.nan)\nTrue\n>>> np.isnan(np.inf)\nFalse\n>>> np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False])","^0","^;"],["^ ","^7","reciprocal","^8","reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the reciprocal of the argument, element-wise.\n\nCalculates ``1/x``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    Return array.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\n.. note::\n    This function is not designed to work with integers.\n\nFor integer arguments with absolute value larger than 1 the result is\nalways zero because of the way Python handles integer division.  For\ninteger zero the result is an overflow.\n\nExamples\n--------\n>>> np.reciprocal(2.)\n0.5\n>>> np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])","^0","^;"],["^ ","^7","partition","^8","\n    Return a partitioned copy of an array.\n\n    Creates a copy of the array with its elements rearranged in such a\n    way that the value of the element in k-th position is in the\n    position it would be in a sorted array. All elements smaller than\n    the k-th element are moved before this element and all equal or\n    greater are moved behind it. The ordering of the elements in the two\n    partitions is undefined.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    kth : int or sequence of ints\n        Element index to partition by. The k-th value of the element\n        will be in its final sorted position and all smaller elements\n        will be moved before it and all equal or greater elements behind\n        it. The order of all elements in the partitions is undefined. If\n        provided with a sequence of k-th it will partition all elements\n        indexed by k-th  of them into their sorted position at once.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument\n        specifies which fields to compare first, second, etc.  A single\n        field can be specified as a string.  Not all fields need be\n        specified, but unspecified fields will still be used, in the\n        order in which they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    partitioned_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.partition : Method to sort an array in-place.\n    argpartition : Indirect partition.\n    sort : Full sorting\n\n    Notes\n    -----\n    The various selection algorithms are characterized by their average\n    speed, worst case performance, work space size, and whether they are\n    stable. A stable sort keeps items with the same key in the same\n    relative order. The available algorithms have the following\n    properties:\n\n    ================= ======= ============= ============ =======\n       kind            speed   worst case    work space  stable\n    ================= ======= ============= ============ =======\n    'introselect'        1        O(n)           0         no\n    ================= ======= ============= ============ =======\n\n    All the partition algorithms make temporary copies of the data when\n    partitioning along any but the last axis.  Consequently,\n    partitioning along the last axis is faster and uses less space than\n    partitioning along any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the\n    real and imaginary parts are non-nan then the order is determined by\n    the real parts except when they are equal, in which case the order\n    is determined by the imaginary parts.\n\n    Examples\n    --------\n    >>> a = np.array([3, 4, 2, 1])\n    >>> np.partition(a, 3)\n    array([2, 1, 3, 4])\n\n    >>> np.partition(a, (1, 3))\n    array([1, 2, 3, 4])\n\n    ","^0","^9"],["^ ","^7","where","^8","\n    where(condition, [x, y])\n\n    Return elements chosen from `x` or `y` depending on `condition`.\n\n    .. note::\n        When only `condition` is provided, this function is a shorthand for\n        ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be\n        preferred, as it behaves correctly for subclasses. The rest of this\n        documentation covers only the case where all three arguments are\n        provided.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        Where True, yield `x`, otherwise yield `y`.\n    x, y : array_like\n        Values from which to choose. `x`, `y` and `condition` need to be\n        broadcastable to some shape.\n\n    Returns\n    -------\n    out : ndarray\n        An array with elements from `x` where `condition` is True, and elements\n        from `y` elsewhere.\n\n    See Also\n    --------\n    choose\n    nonzero : The function that is called when x and y are omitted\n\n    Notes\n    -----\n    If all the arrays are 1-D, `where` is equivalent to::\n\n        [xv if c else yv\n         for c, xv, yv in zip(condition, x, y)]\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.where(a < 5, a, 10*a)\n    array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])\n\n    This can be used on multidimensional arrays too:\n\n    >>> np.where([[True, False], [True, True]],\n    ...          [[1, 2], [3, 4]],\n    ...          [[9, 8], [7, 6]])\n    array([[1, 8],\n           [3, 4]])\n\n    The shapes of x, y, and the condition are broadcast together:\n\n    >>> x, y = np.ogrid[:3, :4]\n    >>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast\n    array([[10,  0,  0,  0],\n           [10, 11,  1,  1],\n           [10, 11, 12,  2]])\n\n    >>> a = np.array([[0, 1, 2],\n    ...               [0, 2, 4],\n    ...               [0, 3, 6]])\n    >>> np.where(a < 4, a, -1)  # -1 is broadcast\n    array([[ 0,  1,  2],\n           [ 0,  2, -1],\n           [ 0,  3, -1]])\n    ","^0","^9"],["^ ","^7","minimum","^8","minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The minimum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nmaximum :\n    Element-wise maximum of two arrays, propagates NaNs.\nfmin :\n    Element-wise minimum of two arrays, ignores NaNs.\namin :\n    The minimum value of an array along a given axis, propagates NaNs.\nnanmin :\n    The minimum value of an array along a given axis, ignores NaNs.\n\nfmax, amax, nanmax\n\nNotes\n-----\nThe minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when\nneither x1 nor x2 are NaNs, but it is faster and does proper\nbroadcasting.\n\nExamples\n--------\n>>> np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([nan, nan, nan])\n>>> np.minimum(-np.Inf, 1)\n-inf","^0","^;"],["^ ","^7","interp","^8","\n    One-dimensional linear interpolation.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given discrete data points (`xp`, `fp`), evaluated at `x`.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates at which to evaluate the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing if argument\n        `period` is not specified. Otherwise, `xp` is internally sorted after\n        normalizing the periodic boundaries with ``xp = xp % period``.\n\n    fp : 1-D sequence of float or complex\n        The y-coordinates of the data points, same length as `xp`.\n\n    left : optional float or complex corresponding to fp\n        Value to return for `x < xp[0]`, default is `fp[0]`.\n\n    right : optional float or complex corresponding to fp\n        Value to return for `x > xp[-1]`, default is `fp[-1]`.\n\n    period : None or float, optional\n        A period for the x-coordinates. This parameter allows the proper\n        interpolation of angular x-coordinates. Parameters `left` and `right`\n        are ignored if `period` is specified.\n\n        .. versionadded:: 1.10.0\n\n    Returns\n    -------\n    y : float or complex (corresponding to fp) or ndarray\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n        If `xp` or `fp` are not 1-D sequences\n        If `period == 0`\n\n    Notes\n    -----\n    The x-coordinate sequence is expected to be increasing, but this is not\n    explicitly enforced.  However, if the sequence `xp` is non-increasing,\n    interpolation results are meaningless.\n\n    Note that, since NaN is unsortable, `xp` also cannot contain NaNs.\n\n    A simple check for `xp` being strictly increasing is::\n\n        np.all(np.diff(xp) > 0)\n\n    Examples\n    --------\n    >>> xp = [1, 2, 3]\n    >>> fp = [3, 2, 0]\n    >>> np.interp(2.5, xp, fp)\n    1.0\n    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\n    array([3.  , 3.  , 2.5 , 0.56, 0.  ])\n    >>> UNDEF = -99.0\n    >>> np.interp(3.14, xp, fp, right=UNDEF)\n    -99.0\n\n    Plot an interpolant to the sine function:\n\n    >>> x = np.linspace(0, 2*np.pi, 10)\n    >>> y = np.sin(x)\n    >>> xvals = np.linspace(0, 2*np.pi, 50)\n    >>> yinterp = np.interp(xvals, x, y)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(xvals, yinterp, '-x')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n\n    Interpolation with periodic x-coordinates:\n\n    >>> x = [-180, -170, -185, 185, -10, -5, 0, 365]\n    >>> xp = [190, -190, 350, -350]\n    >>> fp = [5, 10, 3, 4]\n    >>> np.interp(x, xp, fp, period=360)\n    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])\n\n    Complex interpolation:\n\n    >>> x = [1.5, 4.0]\n    >>> xp = [2,3,5]\n    >>> fp = [1.0j, 0, 2+3j]\n    >>> np.interp(x, xp, fp)\n    array([0.+1.j , 1.+1.5j])\n\n    ","^0","^9"],["^ ","^7","genfromtxt","^8","\n    Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.\n\n    Parameters\n    ----------\n    fname : file, str, pathlib.Path, list of str, generator\n        File, filename, list, or generator to read.  If the filename\n        extension is `.gz` or `.bz2`, the file is first decompressed. Note\n        that generators must return byte strings. The strings\n        in a list or produced by a generator are treated as lines.\n    dtype : dtype, optional\n        Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually.\n    comments : str, optional\n        The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded\n    delimiter : str, int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field.\n    skiprows : int, optional\n        `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.\n    skip_header : int, optional\n        The number of lines to skip at the beginning of the file.\n    skip_footer : int, optional\n        The number of lines to skip at the end of the file.\n    converters : variable, optional\n        The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``.\n    missing : variable, optional\n        `missing` was removed in numpy 1.10. Please use `missing_values`\n        instead.\n    missing_values : variable, optional\n        The set of strings corresponding to missing data.\n    filling_values : variable, optional\n        The set of values to be used as default when the data are missing.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\n    names : {None, True, str, sequence}, optional\n        If `names` is True, the field names are read from the first line after\n        the first `skip_header` lines.  This line can optionally be proceeded\n        by a comment delimiter. If `names` is a sequence or a single-string of\n        comma-separated names, the names will be used to define the field names\n        in a structured dtype. If `names` is None, the names of the dtype\n        fields will be used, if any.\n    excludelist : sequence, optional\n        A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended an underscore:\n        for example, `file` would become `file_`.\n    deletechars : str, optional\n        A string combining invalid characters that must be deleted from the\n        names.\n    defaultfmt : str, optional\n        A format used to define default field names, such as \"f%i\" or \"f_%02i\".\n    autostrip : bool, optional\n        Whether to automatically strip white spaces from the variables.\n    replace_space : char, optional\n        Character(s) used in replacement of white spaces in the variables\n        names. By default, use a '_'.\n    case_sensitive : {True, False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``\n    usemask : bool, optional\n        If True, return a masked array.\n        If False, return a regular array.\n    loose : bool, optional\n        If True, do not raise errors for invalid values.\n    invalid_raise : bool, optional\n        If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped.\n    max_rows : int,  optional\n        The maximum number of rows to read. Must not be used with skip_footer\n        at the same time.  If given, the value must be at least 1. Default is\n        to read the entire file.\n\n        .. versionadded:: 1.10.0\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply when `fname` is\n        a file object.  The special value 'bytes' enables backward compatibility\n        workarounds that ensure that you receive byte arrays when possible\n        and passes latin1 encoded strings to converters. Override this value to\n        receive unicode arrays and pass strings as input to converters.  If set\n        to None the system default is used. The default value is 'bytes'.\n\n        .. versionadded:: 1.14.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file. If `usemask` is True, this is a\n        masked array.\n\n    See Also\n    --------\n    numpy.loadtxt : equivalent function when no data is missing.\n\n    Notes\n    -----\n    * When spaces are used as delimiters, or when no delimiter has been given\n      as input, there should not be any missing data between two fields.\n    * When the variables are named (either by a flexible dtype or with `names`,\n      there must not be any header in the file (else a ValueError\n      exception is raised).\n    * Individual values are not stripped of spaces by default.\n      When using a custom converter, make sure the function does remove spaces.\n\n    References\n    ----------\n    .. [1] NumPy User Guide, section `I/O with NumPy\n           <https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html>`_.\n\n    Examples\n    ---------\n    >>> from io import StringIO\n    >>> import numpy as np\n\n    Comma delimited file with mixed dtype\n\n    >>> s = StringIO(u\"1,1.3,abcde\")\n    >>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n    ... ('mystring','S5')], delimiter=\",\")\n    >>> data\n    array((1, 1.3, b'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\n    Using dtype = None\n\n    >>> _ = s.seek(0) # needed for StringIO example only\n    >>> data = np.genfromtxt(s, dtype=None,\n    ... names = ['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, b'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\n    Specifying dtype and names\n\n    >>> _ = s.seek(0)\n    >>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n    ... names=['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, b'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\n    An example with fixed-width columns\n\n    >>> s = StringIO(u\"11.3abcde\")\n    >>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n    ...     delimiter=[1,3,5])\n    >>> data\n    array((1, 1.3, b'abcde'),\n          dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', 'S5')])\n\n    An example to show comments\n\n    >>> f = StringIO('''\n    ... text,# of chars\n    ... hello world,11\n    ... numpy,5''')\n    >>> np.genfromtxt(f, dtype='S12,S12', delimiter=',')\n    array([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],\n      dtype=[('f0', 'S12'), ('f1', 'S12')])\n\n    ","^0","^9"],["^ ","^7","errstate","^8","\n    errstate(**kwargs)\n\n    Context manager for floating-point error handling.\n\n    Using an instance of `errstate` as a context manager allows statements in\n    that context to execute with a known error handling behavior. Upon entering\n    the context the error handling is set with `seterr` and `seterrcall`, and\n    upon exiting it is reset to what it was before.\n\n    ..  versionchanged:: 1.17.0\n        `errstate` is also usable as a function decorator, saving\n        a level of indentation if an entire function is wrapped.\n        See :py:class:`contextlib.ContextDecorator` for more information.\n\n    Parameters\n    ----------\n    kwargs : {divide, over, under, invalid}\n        Keyword arguments. The valid keywords are the possible floating-point\n        exceptions. Each keyword should have a string value that defines the\n        treatment for the particular error. Possible values are\n        {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.\n\n    See Also\n    --------\n    seterr, geterr, seterrcall, geterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> from collections import OrderedDict\n    >>> olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n    >>> np.arange(3) / 0.\n    array([nan, inf, inf])\n    >>> with np.errstate(divide='warn'):\n    ...     np.arange(3) / 0.\n    array([nan, inf, inf])\n\n    >>> np.sqrt(-1)\n    nan\n    >>> with np.errstate(invalid='raise'):\n    ...     np.sqrt(-1)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 2, in <module>\n    FloatingPointError: invalid value encountered in sqrt\n\n    Outside the context the error handling behavior has not changed:\n\n    >>> OrderedDict(sorted(np.geterr().items()))\n    OrderedDict([('divide', 'ignore'), ('invalid', 'ignore'), ('over', 'ignore'), ('under', 'ignore')])\n\n    ","^0","^0"],["^ ","^7","set_numeric_ops","^8","set_numeric_ops(op1=func1, op2=func2, ...)\n\n    Set numerical operators for array objects.\n\n    .. deprecated:: 1.16\n\n        For the general case, use :c:func:`PyUFunc_ReplaceLoopBySignature`.\n        For ndarray subclasses, define the ``__array_ufunc__`` method and\n        override the relevant ufunc.\n\n    Parameters\n    ----------\n    op1, op2, ... : callable\n        Each ``op = func`` pair describes an operator to be replaced.\n        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace\n        addition by modulus 5 addition.\n\n    Returns\n    -------\n    saved_ops : list of callables\n        A list of all operators, stored before making replacements.\n\n    Notes\n    -----\n    .. WARNING::\n       Use with care!  Incorrect usage may lead to memory errors.\n\n    A function replacing an operator cannot make use of that operator.\n    For example, when replacing add, you may not use ``+``.  Instead,\n    directly call ufuncs.\n\n    Examples\n    --------\n    >>> def add_mod5(x, y):\n    ...     return np.add(x, y) % 5\n    ...\n    >>> old_funcs = np.set_numeric_ops(add=add_mod5)\n\n    >>> x = np.arange(12).reshape((3, 4))\n    >>> x + x\n    array([[0, 2, 4, 1],\n           [3, 0, 2, 4],\n           [1, 3, 0, 2]])\n\n    >>> ignore = np.set_numeric_ops(**old_funcs) # restore operators","^0","^?"],["^ ","^7","degrees","^8","degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from radians to degrees.\n\nParameters\n----------\nx : array_like\n    Input array in radians.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray of floats\n    The corresponding degree values; if `out` was supplied this is a\n    reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nrad2deg : equivalent function\n\nExamples\n--------\nConvert a radian array to degrees\n\n>>> rad = np.arange(12.)*np.pi/6\n>>> np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])\n\n>>> out = np.zeros((rad.shape))\n>>> r = np.degrees(rad, out)\n>>> np.all(r == out)\nTrue","^0","^;"],["^ ","^8","","^0","~:bool"],["^ ","^7","diff","^8","\n    Calculate the n-th discrete difference along the given axis.\n\n    The first difference is given by ``out[i] = a[i+1] - a[i]`` along\n    the given axis, higher differences are calculated by using `diff`\n    recursively.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        The number of times values are differenced. If zero, the input\n        is returned as-is.\n    axis : int, optional\n        The axis along which the difference is taken, default is the\n        last axis.\n    prepend, append : array_like, optional\n        Values to prepend or append to `a` along axis prior to\n        performing the difference.  Scalar values are expanded to\n        arrays with length 1 in the direction of axis and the shape\n        of the input array in along all other axes.  Otherwise the\n        dimension and shape must match `a` except along axis.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    diff : ndarray\n        The n-th differences. The shape of the output is the same as `a`\n        except along `axis` where the dimension is smaller by `n`. The\n        type of the output is the same as the type of the difference\n        between any two elements of `a`. This is the same as the type of\n        `a` in most cases. A notable exception is `datetime64`, which\n        results in a `timedelta64` output array.\n\n    See Also\n    --------\n    gradient, ediff1d, cumsum\n\n    Notes\n    -----\n    Type is preserved for boolean arrays, so the result will contain\n    `False` when consecutive elements are the same and `True` when they\n    differ.\n\n    For unsigned integer arrays, the results will also be unsigned. This\n    should not be surprising, as the result is consistent with\n    calculating the difference directly:\n\n    >>> u8_arr = np.array([1, 0], dtype=np.uint8)\n    >>> np.diff(u8_arr)\n    array([255], dtype=uint8)\n    >>> u8_arr[1,...] - u8_arr[0,...]\n    255\n\n    If this is not desirable, then the array should be cast to a larger\n    integer type first:\n\n    >>> i16_arr = u8_arr.astype(np.int16)\n    >>> np.diff(i16_arr)\n    array([-1], dtype=int16)\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.diff(x)\n    array([ 1,  2,  3, -7])\n    >>> np.diff(x, n=2)\n    array([  1,   1, -10])\n\n    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n    >>> np.diff(x)\n    array([[2, 3, 4],\n           [5, 1, 2]])\n    >>> np.diff(x, axis=0)\n    array([[-1,  2,  0, -2]])\n\n    >>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)\n    >>> np.diff(x)\n    array([1, 1], dtype='timedelta64[D]')\n\n    ","^0","^9"],["^ ","^7","isin","^8","\n    Calculates `element in test_elements`, broadcasting over `element` only.\n    Returns a boolean array of the same shape as `element` that is True\n    where an element of `element` is in `test_elements` and False otherwise.\n\n    Parameters\n    ----------\n    element : array_like\n        Input array.\n    test_elements : array_like\n        The values against which to test each value of `element`.\n        This argument is flattened if it is an array or array_like.\n        See notes for behavior with non-array-like parameters.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n    invert : bool, optional\n        If True, the values in the returned array are inverted, as if\n        calculating `element not in test_elements`. Default is False.\n        ``np.isin(a, b, invert=True)`` is equivalent to (but faster\n        than) ``np.invert(np.isin(a, b))``.\n\n    Returns\n    -------\n    isin : ndarray, bool\n        Has the same shape as `element`. The values `element[isin]`\n        are in `test_elements`.\n\n    See Also\n    --------\n    in1d                  : Flattened version of this function.\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n\n    `isin` is an element-wise function version of the python keyword `in`.\n    ``isin(a, b)`` is roughly equivalent to\n    ``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.\n\n    `element` and `test_elements` are converted to arrays if they are not\n    already. If `test_elements` is a set (or other non-sequence collection)\n    it will be converted to an object array with one element, rather than an\n    array of the values contained in `test_elements`. This is a consequence\n    of the `array` constructor's way of handling non-sequence collections.\n    Converting the set to a list usually gives the desired behavior.\n\n    .. versionadded:: 1.13.0\n\n    Examples\n    --------\n    >>> element = 2*np.arange(4).reshape((2, 2))\n    >>> element\n    array([[0, 2],\n           [4, 6]])\n    >>> test_elements = [1, 2, 4, 8]\n    >>> mask = np.isin(element, test_elements)\n    >>> mask\n    array([[False,  True],\n           [ True, False]])\n    >>> element[mask]\n    array([2, 4])\n\n    The indices of the matched values can be obtained with `nonzero`:\n\n    >>> np.nonzero(mask)\n    (array([0, 1]), array([1, 0]))\n\n    The test can also be inverted:\n\n    >>> mask = np.isin(element, test_elements, invert=True)\n    >>> mask\n    array([[ True, False],\n           [False,  True]])\n    >>> element[mask]\n    array([0, 6])\n\n    Because of how `array` handles sets, the following does not\n    work as expected:\n\n    >>> test_set = {1, 2, 4, 8}\n    >>> np.isin(element, test_set)\n    array([[False, False],\n           [False, False]])\n\n    Casting the set to a list gives the expected result:\n\n    >>> np.isin(element, list(test_set))\n    array([[False,  True],\n           [ True, False]])\n    ","^0","^9"],["^ ","^8",null,"^0","^B"],["^ ","^7","argmin","^8","\n    Returns the indices of the minimum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed.\n\n    See Also\n    --------\n    ndarray.argmin, argmax\n    amin : The minimum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n    take_along_axis : Apply ``np.expand_dims(index_array, axis)`` \n                      from argmin to an array as if by calling min.\n\n    Notes\n    -----\n    In case of multiple occurrences of the minimum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> a = np.arange(6).reshape(2,3) + 10\n    >>> a\n    array([[10, 11, 12],\n           [13, 14, 15]])\n    >>> np.argmin(a)\n    0\n    >>> np.argmin(a, axis=0)\n    array([0, 0, 0])\n    >>> np.argmin(a, axis=1)\n    array([0, 0])\n\n    Indices of the minimum elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)\n    >>> ind\n    (0, 0)\n    >>> a[ind]\n    10\n\n    >>> b = np.arange(6) + 10\n    >>> b[4] = 10\n    >>> b\n    array([10, 11, 12, 13, 10, 15])\n    >>> np.argmin(b)  # Only the first occurrence is returned.\n    0\n\n    >>> x = np.array([[4,2,3], [1,0,3]])\n    >>> index_array = np.argmin(x, axis=-1)\n    >>> # Same as np.min(x, axis=-1, keepdims=True)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\n    array([[2],\n           [0]])\n    >>> # Same as np.max(x, axis=-1)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\n    array([2, 0])\n\n    ","^0","^9"],["^ ","^7","chararray","^8","\n    chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,\n              strides=None, order=None)\n\n    Provides a convenient view on arrays of string and unicode values.\n\n    .. note::\n       The `chararray` class exists for backwards compatibility with\n       Numarray, it is not recommended for new development. Starting from numpy\n       1.4, if one needs arrays of strings, it is recommended to use arrays of\n       `dtype` `object_`, `string_` or `unicode_`, and use the free functions\n       in the `numpy.char` module for fast vectorized string operations.\n\n    Versus a regular NumPy array of type `str` or `unicode`, this\n    class adds the following functionality:\n\n      1) values automatically have whitespace removed from the end\n         when indexed\n\n      2) comparison operators automatically remove whitespace from the\n         end when comparing values\n\n      3) vectorized string operations are provided as methods\n         (e.g. `.endswith`) and infix operators (e.g. ``\"+\", \"*\", \"%\"``)\n\n    chararrays should be created using `numpy.char.array` or\n    `numpy.char.asarray`, rather than this constructor directly.\n\n    This constructor creates the array, using `buffer` (with `offset`\n    and `strides`) if it is not ``None``. If `buffer` is ``None``, then\n    constructs a new array with `strides` in \"C order\", unless both\n    ``len(shape) >= 2`` and ``order='F'``, in which case `strides`\n    is in \"Fortran order\".\n\n    Methods\n    -------\n    astype\n    argsort\n    copy\n    count\n    decode\n    dump\n    dumps\n    encode\n    endswith\n    expandtabs\n    fill\n    find\n    flatten\n    getfield\n    index\n    isalnum\n    isalpha\n    isdecimal\n    isdigit\n    islower\n    isnumeric\n    isspace\n    istitle\n    isupper\n    item\n    join\n    ljust\n    lower\n    lstrip\n    nonzero\n    put\n    ravel\n    repeat\n    replace\n    reshape\n    resize\n    rfind\n    rindex\n    rjust\n    rsplit\n    rstrip\n    searchsorted\n    setfield\n    setflags\n    sort\n    split\n    splitlines\n    squeeze\n    startswith\n    strip\n    swapaxes\n    swapcase\n    take\n    title\n    tofile\n    tolist\n    tostring\n    translate\n    transpose\n    upper\n    view\n    zfill\n\n    Parameters\n    ----------\n    shape : tuple\n        Shape of the array.\n    itemsize : int, optional\n        Length of each array element, in number of characters. Default is 1.\n    unicode : bool, optional\n        Are the array elements of type unicode (True) or string (False).\n        Default is False.\n    buffer : int, optional\n        Memory address of the start of the array data.  Default is None,\n        in which case a new array is created.\n    offset : int, optional\n        Fixed stride displacement from the beginning of an axis?\n        Default is 0. Needs to be >=0.\n    strides : array_like of ints, optional\n        Strides for the array (see `ndarray.strides` for full description).\n        Default is None.\n    order : {'C', 'F'}, optional\n        The order in which the array data is stored in memory: 'C' ->\n        \"row major\" order (the default), 'F' -> \"column major\"\n        (Fortran) order.\n\n    Examples\n    --------\n    >>> charar = np.chararray((3, 3))\n    >>> charar[:] = 'a'\n    >>> charar\n    chararray([[b'a', b'a', b'a'],\n               [b'a', b'a', b'a'],\n               [b'a', b'a', b'a']], dtype='|S1')\n\n    >>> charar = np.chararray(charar.shape, itemsize=5)\n    >>> charar[:] = 'abc'\n    >>> charar\n    chararray([[b'abc', b'abc', b'abc'],\n               [b'abc', b'abc', b'abc'],\n               [b'abc', b'abc', b'abc']], dtype='|S5')\n\n    ","^0","^0"],["^ ","^7","shares_memory","^8","\n    shares_memory(a, b, max_work=None)\n\n    Determine if two arrays share memory\n\n    Parameters\n    ----------\n    a, b : ndarray\n        Input arrays\n    max_work : int, optional\n        Effort to spend on solving the overlap problem (maximum number\n        of candidate solutions to consider). The following special\n        values are recognized:\n\n        max_work=MAY_SHARE_EXACT  (default)\n            The problem is solved exactly. In this case, the function returns\n            True only if there is an element shared between the arrays.\n        max_work=MAY_SHARE_BOUNDS\n            Only the memory bounds of a and b are checked.\n\n    Raises\n    ------\n    numpy.TooHardError\n        Exceeded max_work.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    may_share_memory\n\n    Examples\n    --------\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n\n    ","^0","^9"],["^ ","^7","flip","^8","\n    Reverse the order of elements in an array along the given axis.\n\n    The shape of the array is preserved, but the elements are reordered.\n\n    .. versionadded:: 1.12.0\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n    axis : None or int or tuple of ints, optional\n         Axis or axes along which to flip over. The default,\n         axis=None, will flip over all of the axes of the input array.\n         If axis is negative it counts from the last to the first axis.\n\n         If axis is a tuple of ints, flipping is performed on all of the axes\n         specified in the tuple.\n\n         .. versionchanged:: 1.15.0\n            None and tuples of axes are supported\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the entries of axis reversed.  Since a view is\n        returned, this operation is done in constant time.\n\n    See Also\n    --------\n    flipud : Flip an array vertically (axis=0).\n    fliplr : Flip an array horizontally (axis=1).\n\n    Notes\n    -----\n    flip(m, 0) is equivalent to flipud(m).\n\n    flip(m, 1) is equivalent to fliplr(m).\n\n    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.\n\n    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all\n    positions.\n\n    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at\n    position 0 and position 1.\n\n    Examples\n    --------\n    >>> A = np.arange(8).reshape((2,2,2))\n    >>> A\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> np.flip(A, 0)\n    array([[[4, 5],\n            [6, 7]],\n           [[0, 1],\n            [2, 3]]])\n    >>> np.flip(A, 1)\n    array([[[2, 3],\n            [0, 1]],\n           [[6, 7],\n            [4, 5]]])\n    >>> np.flip(A)\n    array([[[7, 6],\n            [5, 4]],\n           [[3, 2],\n            [1, 0]]])\n    >>> np.flip(A, (0, 2))\n    array([[[5, 4],\n            [7, 6]],\n           [[1, 0],\n            [3, 2]]])\n    >>> A = np.random.randn(3,4,5)\n    >>> np.all(np.flip(A,2) == A[:,:,::-1,...])\n    True\n    ","^0","^9"],["^ ","^7","block","^8","\n    Assemble an nd-array from nested lists of blocks.\n\n    Blocks in the innermost lists are concatenated (see `concatenate`) along\n    the last dimension (-1), then these are concatenated along the\n    second-last dimension (-2), and so on until the outermost list is reached.\n\n    Blocks can be of any dimension, but will not be broadcasted using the normal\n    rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``\n    the same for all blocks. This is primarily useful for working with scalars,\n    and means that code like ``np.block([v, 1])`` is valid, where\n    ``v.ndim == 1``.\n\n    When the nested list is two levels deep, this allows block matrices to be\n    constructed from their components.\n\n    .. versionadded:: 1.13.0\n\n    Parameters\n    ----------\n    arrays : nested list of array_like or scalars (but not tuples)\n        If passed a single ndarray or scalar (a nested list of depth 0), this\n        is returned unmodified (and not copied).\n\n        Elements shapes must match along the appropriate axes (without\n        broadcasting), but leading 1s will be prepended to the shape as\n        necessary to make the dimensions match.\n\n    Returns\n    -------\n    block_array : ndarray\n        The array assembled from the given blocks.\n\n        The dimensionality of the output is equal to the greatest of:\n        * the dimensionality of all the inputs\n        * the depth to which the input list is nested\n\n    Raises\n    ------\n    ValueError\n        * If list depths are mismatched - for instance, ``[[a, b], c]`` is\n          illegal, and should be spelt ``[[a, b], [c]]``\n        * If lists are empty - for instance, ``[[a, b], []]``\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays together.\n    stack : Stack arrays in sequence along a new dimension.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n    Notes\n    -----\n\n    When called with only scalars, ``np.block`` is equivalent to an ndarray\n    call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to\n    ``np.array([[1, 2], [3, 4]])``.\n\n    This function does not enforce that the blocks lie on a fixed grid.\n    ``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::\n\n        AAAbb\n        AAAbb\n        cccDD\n\n    But is also allowed to produce, for some ``a, b, c, d``::\n\n        AAAbb\n        AAAbb\n        cDDDD\n\n    Since concatenation happens along the last axis first, `block` is _not_\n    capable of producing the following directly::\n\n        AAAbb\n        cccbb\n        cccDD\n\n    Matlab's \"square bracket stacking\", ``[A, B, ...; p, q, ...]``, is\n    equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.\n\n    Examples\n    --------\n    The most common use of this function is to build a block matrix\n\n    >>> A = np.eye(2) * 2\n    >>> B = np.eye(3) * 3\n    >>> np.block([\n    ...     [A,               np.zeros((2, 3))],\n    ...     [np.ones((3, 2)), B               ]\n    ... ])\n    array([[2., 0., 0., 0., 0.],\n           [0., 2., 0., 0., 0.],\n           [1., 1., 3., 0., 0.],\n           [1., 1., 0., 3., 0.],\n           [1., 1., 0., 0., 3.]])\n\n    With a list of depth 1, `block` can be used as `hstack`\n\n    >>> np.block([1, 2, 3])              # hstack([1, 2, 3])\n    array([1, 2, 3])\n\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.block([a, b, 10])             # hstack([a, b, 10])\n    array([ 1,  2,  3,  2,  3,  4, 10])\n\n    >>> A = np.ones((2, 2), int)\n    >>> B = 2 * A\n    >>> np.block([A, B])                 # hstack([A, B])\n    array([[1, 1, 2, 2],\n           [1, 1, 2, 2]])\n\n    With a list of depth 2, `block` can be used in place of `vstack`:\n\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.block([[a], [b]])             # vstack([a, b])\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> A = np.ones((2, 2), int)\n    >>> B = 2 * A\n    >>> np.block([[A], [B]])             # vstack([A, B])\n    array([[1, 1],\n           [1, 1],\n           [2, 2],\n           [2, 2]])\n\n    It can also be used in places of `atleast_1d` and `atleast_2d`\n\n    >>> a = np.array(0)\n    >>> b = np.array([1])\n    >>> np.block([a])                    # atleast_1d(a)\n    array([0])\n    >>> np.block([b])                    # atleast_1d(b)\n    array([1])\n\n    >>> np.block([[a]])                  # atleast_2d(a)\n    array([[0]])\n    >>> np.block([[b]])                  # atleast_2d(b)\n    array([[1]])\n\n\n    ","^0","^9"],["^ ","^7","putmask","^8","\n    putmask(a, mask, values)\n\n    Changes elements of an array based on conditional and input values.\n\n    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.\n\n    If `values` is not the same size as `a` and `mask` then it will repeat.\n    This gives behavior different from ``a[mask] = values``.\n\n    Parameters\n    ----------\n    a : array_like\n        Target array.\n    mask : array_like\n        Boolean mask array. It has to be the same shape as `a`.\n    values : array_like\n        Values to put into `a` where `mask` is True. If `values` is smaller\n        than `a` it will be repeated.\n\n    See Also\n    --------\n    place, put, take, copyto\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> np.putmask(x, x>2, x**2)\n    >>> x\n    array([[ 0,  1,  2],\n           [ 9, 16, 25]])\n\n    If `values` is smaller than `a` it is repeated:\n\n    >>> x = np.arange(5)\n    >>> np.putmask(x, x>1, [-33, -44])\n    >>> x\n    array([  0,   1, -33, -44, -33])\n\n    ","^0","^9"],["^ ","^7","arctanh","^8","arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic tangent element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nemath.arctanh\n\nNotes\n-----\n`arctanh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `tanh(z) = x`. The convention is to return\nthe `z` whose imaginary part lies in `[-pi/2, pi/2]`.\n\nFor real-valued input data types, `arctanh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arctanh` is a complex analytical function\nthat has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\n\nThe inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\n       https://en.wikipedia.org/wiki/Arctanh\n\nExamples\n--------\n>>> np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])","^0","^;"],["^ ","^7","take","^8","\n    Take elements from an array along an axis.\n\n    When axis is not None, this function does the same thing as \"fancy\"\n    indexing (indexing arrays using arrays); however, it can be easier to use\n    if you need elements along a given axis. A call such as\n    ``np.take(arr, indices, axis=3)`` is equivalent to\n    ``arr[:,:,:,indices,...]``.\n\n    Explained without fancy indexing, this is equivalent to the following use\n    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of\n    indices::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        Nj = indices.shape\n        for ii in ndindex(Ni):\n            for jj in ndindex(Nj):\n                for kk in ndindex(Nk):\n                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]\n\n    Parameters\n    ----------\n    a : array_like (Ni..., M, Nk...)\n        The source array.\n    indices : array_like (Nj...)\n        The indices of the values to extract.\n\n        .. versionadded:: 1.8.0\n\n        Also allow scalars for indices.\n    axis : int, optional\n        The axis over which to select values. By default, the flattened\n        input array is used.\n    out : ndarray, optional (Ni..., Nj..., Nk...)\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype. Note that `out` is always\n        buffered if `mode='raise'`; use other modes for better performance.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    Returns\n    -------\n    out : ndarray (Ni..., Nj..., Nk...)\n        The returned array has the same type as `a`.\n\n    See Also\n    --------\n    compress : Take elements using a boolean mask\n    ndarray.take : equivalent method\n    take_along_axis : Take elements by matching the array and the index arrays\n\n    Notes\n    -----\n\n    By eliminating the inner loop in the description above, and using `s_` to\n    build simple slice objects, `take` can be expressed  in terms of applying\n    fancy indexing to each 1-d slice::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nj):\n                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]\n\n    For this reason, it is equivalent to (but faster than) the following use\n    of `apply_along_axis`::\n\n        out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)\n\n    Examples\n    --------\n    >>> a = [4, 3, 5, 7, 6, 8]\n    >>> indices = [0, 1, 4]\n    >>> np.take(a, indices)\n    array([4, 3, 6])\n\n    In this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n    >>> a = np.array(a)\n    >>> a[indices]\n    array([4, 3, 6])\n\n    If `indices` is not one dimensional, the output also has these dimensions.\n\n    >>> np.take(a, [[0, 1], [2, 3]])\n    array([[4, 3],\n           [5, 7]])\n    ","^0","^9"],["^ ","^7","conjugate","^8","conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the complex conjugate, element-wise.\n\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n----------\nx : array_like\n    Input value.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The complex conjugate of `x`, with same dtype as `y`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\n`conj` is an alias for `conjugate`:\n\n>>> np.conj is np.conjugate\nTrue\n\nExamples\n--------\n>>> np.conjugate(1+2j)\n(1-2j)\n\n>>> x = np.eye(2) + 1j * np.eye(2)\n>>> np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])","^0","^;"],["^ ","^7","__getattr__","^8",null,"^0","^9"],["^ ","^7","seterrcall","^8","\n    Set the floating-point error callback function or log object.\n\n    There are two ways to capture floating-point error messages.  The first\n    is to set the error-handler to 'call', using `seterr`.  Then, set\n    the function to call using this function.\n\n    The second is to set the error-handler to 'log', using `seterr`.\n    Floating-point errors then trigger a call to the 'write' method of\n    the provided object.\n\n    Parameters\n    ----------\n    func : callable f(err, flag) or object with write method\n        Function to call upon floating-point errors ('call'-mode) or\n        object whose 'write' method is used to log such message ('log'-mode).\n\n        The call function takes two arguments. The first is a string describing\n        the type of error (such as \"divide by zero\", \"overflow\", \"underflow\",\n        or \"invalid value\"), and the second is the status flag.  The flag is a\n        byte, whose four least-significant bits indicate the type of error, one\n        of \"divide\", \"over\", \"under\", \"invalid\"::\n\n          [0 0 0 0 divide over under invalid]\n\n        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n        If an object is provided, its write method should take one argument,\n        a string.\n\n    Returns\n    -------\n    h : callable, log instance or None\n        The old error handler.\n\n    See Also\n    --------\n    seterr, geterr, geterrcall\n\n    Examples\n    --------\n    Callback upon error:\n\n    >>> def err_handler(type, flag):\n    ...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n    ...\n\n    >>> saved_handler = np.seterrcall(err_handler)\n    >>> save_err = np.seterr(all='call')\n    >>> from collections import OrderedDict\n\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([inf, inf, inf])\n\n    >>> np.seterrcall(saved_handler)\n    <function err_handler at 0x...>\n    >>> OrderedDict(sorted(np.seterr(**save_err).items()))\n    OrderedDict([('divide', 'call'), ('invalid', 'call'), ('over', 'call'), ('under', 'call')])\n\n    Log error message:\n\n    >>> class Log(object):\n    ...     def write(self, msg):\n    ...         print(\"LOG: %s\" % msg)\n    ...\n\n    >>> log = Log()\n    >>> saved_handler = np.seterrcall(log)\n    >>> save_err = np.seterr(all='log')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    LOG: Warning: divide by zero encountered in true_divide\n    array([inf, inf, inf])\n\n    >>> np.seterrcall(saved_handler)\n    <numpy.core.numeric.Log object at 0x...>\n    >>> OrderedDict(sorted(np.seterr(**save_err).items()))\n    OrderedDict([('divide', 'log'), ('invalid', 'log'), ('over', 'log'), ('under', 'log')])\n\n    ","^0","^9"],["^ ","^7","unicode","^8","str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.","^0","^0"],["^ ","^8","","^0","^<"],["^ ","^7","iscomplex","^8","\n    Returns a bool array, where True if input element is complex.\n\n    What is tested is whether the input has a non-zero imaginary part, not if\n    the input type is complex.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray of bools\n        Output array.\n\n    See Also\n    --------\n    isreal\n    iscomplexobj : Return True if x is a complex type or an array of complex\n                   numbers.\n\n    Examples\n    --------\n    >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([ True, False, False, False, False,  True])\n\n    ","^0","^9"],["^ ","^7","ushort","^8","Unsigned integer type, compatible with C ``unsigned short``.\n    Character code: ``'H'``.\n    Canonical name: ``np.ushort``.\n    Alias *on this platform*: ``np.uint16``: 16-bit unsigned integer (0 to 65535).","^0","^0"],["^ "],["^ ","^7","fmod","^8","fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the element-wise remainder of division.\n\nThis is the NumPy implementation of the C library function fmod, the\nremainder has the same sign as the dividend `x1`. It is equivalent to\nthe Matlab(TM) ``rem`` function and should not be confused with the\nPython modulus operator ``x1 % x2``.\n\nParameters\n----------\nx1 : array_like\n    Dividend.\nx2 : array_like\n    Divisor. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : array_like\n    The remainder of the division of `x1` by `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nremainder : Equivalent to the Python ``%`` operator.\ndivide\n\nNotes\n-----\nThe result of the modulo operation for negative dividend and divisors\nis bound by conventions. For `fmod`, the sign of result is the sign of\nthe dividend, while for `remainder` the sign of the result is the sign\nof the divisor. The `fmod` function is equivalent to the Matlab(TM)\n``rem`` function.\n\nExamples\n--------\n>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n\n>>> np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n>>> a = np.arange(-3, 3).reshape(3, 2)\n>>> a\narray([[-3, -2],\n       [-1,  0],\n       [ 1,  2]])\n>>> np.fmod(a, [2,2])\narray([[-1,  0],\n       [-1,  0],\n       [ 1,  0]])","^0","^;"],["^ ","^7","can_cast","^8","\n    can_cast(from_, to, casting='safe')\n\n    Returns True if cast between data types can occur according to the\n    casting rule.  If from is a scalar or array scalar, also returns\n    True if the scalar value can be cast without overflow or truncation\n    to an integer.\n\n    Parameters\n    ----------\n    from_ : dtype, dtype specifier, scalar, or array\n        Data type, scalar, or array to cast from.\n    to : dtype or dtype specifier\n        Data type to cast to.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    out : bool\n        True if cast can occur according to the casting rule.\n\n    Notes\n    -----\n    .. versionchanged:: 1.17.0\n       Casting between a simple data type and a structured one is possible only\n       for \"unsafe\" casting.  Casting to multiple fields is allowed, but\n       casting from multiple fields is not.\n\n    .. versionchanged:: 1.9.0\n       Casting from numeric to string types in 'safe' casting mode requires\n       that the string dtype length is long enough to store the maximum\n       integer/float value converted.\n\n    See also\n    --------\n    dtype, result_type\n\n    Examples\n    --------\n    Basic examples\n\n    >>> np.can_cast(np.int32, np.int64)\n    True\n    >>> np.can_cast(np.float64, complex)\n    True\n    >>> np.can_cast(complex, float)\n    False\n\n    >>> np.can_cast('i8', 'f8')\n    True\n    >>> np.can_cast('i8', 'f4')\n    False\n    >>> np.can_cast('i4', 'S4')\n    False\n\n    Casting scalars\n\n    >>> np.can_cast(100, 'i1')\n    True\n    >>> np.can_cast(150, 'i1')\n    False\n    >>> np.can_cast(150, 'u1')\n    True\n\n    >>> np.can_cast(3.5e100, np.float32)\n    False\n    >>> np.can_cast(1000.0, np.float32)\n    True\n\n    Array scalar checks the value, array does not\n\n    >>> np.can_cast(np.array(1000.0), np.float32)\n    True\n    >>> np.can_cast(np.array([1000.0]), np.float32)\n    False\n\n    Using the casting rules\n\n    >>> np.can_cast('i8', 'i8', 'no')\n    True\n    >>> np.can_cast('<i8', '>i8', 'no')\n    False\n\n    >>> np.can_cast('<i8', '>i8', 'equiv')\n    True\n    >>> np.can_cast('<i4', '>i8', 'equiv')\n    False\n\n    >>> np.can_cast('<i4', '>i8', 'safe')\n    True\n    >>> np.can_cast('<i8', '>i4', 'safe')\n    False\n\n    >>> np.can_cast('<i8', '>i4', 'same_kind')\n    True\n    >>> np.can_cast('<i8', '>u4', 'same_kind')\n    False\n\n    >>> np.can_cast('<i8', '>u4', 'unsafe')\n    True\n\n    ","^0","^9"],["^ ","^7","quantile","^8","\n    Compute the q-th quantile of the data along the specified axis.\n    \n    .. versionadded:: 1.15.0\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    q : array_like of float\n        Quantile or sequence of quantiles to compute, which must be between\n        0 and 1 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the quantiles are computed. The\n        default is to compute the quantile(s) along a flattened\n        version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to\n        use when the desired quantile lies between two data points\n        ``i < j``:\n\n            * linear: ``i + (j - i) * fraction``, where ``fraction``\n              is the fractional part of the index surrounded by ``i``\n              and ``j``.\n            * lower: ``i``.\n            * higher: ``j``.\n            * nearest: ``i`` or ``j``, whichever is nearest.\n            * midpoint: ``(i + j) / 2``.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n    Returns\n    -------\n    quantile : scalar or ndarray\n        If `q` is a single quantile and `axis=None`, then the result\n        is a scalar. If multiple quantiles are given, first axis of\n        the result corresponds to the quantiles. The other axes are\n        the axes that remain after the reduction of `a`. If the input\n        contains integers or floats smaller than ``float64``, the output\n        data-type is ``float64``. Otherwise, the output data-type is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean\n    percentile : equivalent to quantile, but with q in the range [0, 100].\n    median : equivalent to ``quantile(..., 0.5)``\n    nanquantile\n\n    Notes\n    -----\n    Given a vector ``V`` of length ``N``, the q-th quantile of\n    ``V`` is the value ``q`` of the way from the minimum to the\n    maximum in a sorted copy of ``V``. The values and distances of\n    the two nearest neighbors as well as the `interpolation` parameter\n    will determine the quantile if the normalized ranking does not\n    match the location of ``q`` exactly. This function is the same as\n    the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and the\n    same as the maximum if ``q=1.0``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.quantile(a, 0.5)\n    3.5\n    >>> np.quantile(a, 0.5, axis=0)\n    array([6.5, 4.5, 2.5])\n    >>> np.quantile(a, 0.5, axis=1)\n    array([7.,  2.])\n    >>> np.quantile(a, 0.5, axis=1, keepdims=True)\n    array([[7.],\n           [2.]])\n    >>> m = np.quantile(a, 0.5, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.quantile(a, 0.5, axis=0, out=out)\n    array([6.5, 4.5, 2.5])\n    >>> m\n    array([6.5, 4.5, 2.5])\n    >>> b = a.copy()\n    >>> np.quantile(b, 0.5, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a == b)\n    ","^0","^9"],["^ ","^7","unwrap","^8","\n    Unwrap by changing deltas between values to 2*pi complement.\n\n    Unwrap radian phase `p` by changing absolute jumps greater than\n    `discont` to their 2*pi complement along the given axis.\n\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``pi``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        Output array.\n\n    See Also\n    --------\n    rad2deg, deg2rad\n\n    Notes\n    -----\n    If the discontinuity in `p` is smaller than ``pi``, but larger than\n    `discont`, no unwrapping is done because taking the 2*pi complement\n    would only make the discontinuity larger.\n\n    Examples\n    --------\n    >>> phase = np.linspace(0, np.pi, num=5)\n    >>> phase[3:] += np.pi\n    >>> phase\n    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary\n    >>> np.unwrap(phase)\n    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary\n\n    ","^0","^9"],["^ ","^8","","^0","^="],["^ ","^7","short","^8","Signed integer type, compatible with C ``short``.\n    Character code: ``'h'``.\n    Canonical name: ``np.short``.\n    Alias *on this platform*: ``np.int16``: 16-bit signed integer (-32768 to 32767).","^0","^0"],["^ ","^7","datetime_as_string","^8","\n    datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')\n\n    Convert an array of datetimes into an array of strings.\n\n    Parameters\n    ----------\n    arr : array_like of datetime64\n        The array of UTC timestamps to format.\n    unit : str\n        One of None, 'auto', or a :ref:`datetime unit <arrays.dtypes.dateunits>`.\n    timezone : {'naive', 'UTC', 'local'} or tzinfo\n        Timezone information to use when displaying the datetime. If 'UTC', end\n        with a Z to indicate UTC time. If 'local', convert to the local timezone\n        first, and suffix with a +-#### timezone offset. If a tzinfo object,\n        then do as with 'local', but use the specified timezone.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}\n        Casting to allow when changing between datetime units.\n\n    Returns\n    -------\n    str_arr : ndarray\n        An array of strings the same shape as `arr`.\n\n    Examples\n    --------\n    >>> import pytz\n    >>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n    >>> d\n    array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n           '2002-10-27T07:30'], dtype='datetime64[m]')\n\n    Setting the timezone to UTC shows the same information, but with a Z suffix\n\n    >>> np.datetime_as_string(d, timezone='UTC')\n    array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n           '2002-10-27T07:30Z'], dtype='<U35')\n\n    Note that we picked datetimes that cross a DST boundary. Passing in a\n    ``pytz`` timezone object will print the appropriate offset\n\n    >>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))\n    array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',\n           '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')\n\n    Passing in a unit will change the precision\n\n    >>> np.datetime_as_string(d, unit='h')\n    array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],\n          dtype='<U32')\n    >>> np.datetime_as_string(d, unit='s')\n    array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',\n           '2002-10-27T07:30:00'], dtype='<U38')\n\n    'casting' can be used to specify whether precision can be changed\n\n    >>> np.datetime_as_string(d, unit='h', casting='safe')\n    Traceback (most recent call last):\n        ...\n    TypeError: Cannot create a datetime string as units 'h' from a NumPy\n    datetime with units 'm' according to the rule 'safe'\n    ","^0","^9"],["^ ","^7","datetime_data","^8","datetime_data(dtype, /)\n\n    Get information about the step size of a date or time type.\n\n    The returned tuple can be passed as the second argument of `numpy.datetime64` and\n    `numpy.timedelta64`.\n\n    Parameters\n    ----------\n    dtype : dtype\n        The dtype object, which must be a `datetime64` or `timedelta64` type.\n\n    Returns\n    -------\n    unit : str\n        The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype\n        is based.\n    count : int\n        The number of base units in a step.\n\n    Examples\n    --------\n    >>> dt_25s = np.dtype('timedelta64[25s]')\n    >>> np.datetime_data(dt_25s)\n    ('s', 25)\n    >>> np.array(10, dt_25s).astype('timedelta64[s]')\n    array(250, dtype='timedelta64[s]')\n\n    The result can be used to construct a datetime that uses the same units\n    as a timedelta\n\n    >>> np.datetime64('2010', np.datetime_data(dt_25s))\n    numpy.datetime64('2010-01-01T00:00:00','25s')","^0","^?"],["^ ","^8","","^0","^:"],["^ ","^7","imag","^8","\n    Return the imaginary part of the complex argument.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray or scalar\n        The imaginary component of the complex argument. If `val` is real,\n        the type of `val` is used for the output.  If `val` has complex\n        elements, the returned type is float.\n\n    See Also\n    --------\n    real, angle, real_if_close\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.imag\n    array([2.,  4.,  6.])\n    >>> a.imag = np.array([8, 10, 12])\n    >>> a\n    array([1. +8.j,  3.+10.j,  5.+12.j])\n    >>> np.imag(1 + 1j)\n    1.0\n\n    ","^0","^9"],["^ ","^7","count_nonzero","^8","\n    Counts the number of non-zero values in the array ``a``.\n\n    The word \"non-zero\" is in reference to the Python 2.x\n    built-in method ``__nonzero__()`` (renamed ``__bool__()``\n    in Python 3.x) of Python objects that tests an object's\n    \"truthfulness\". For example, any number is considered\n    truthful if it is nonzero, whereas any string is considered\n    truthful if it is not the empty string. Thus, this function\n    (recursively) counts how many elements in ``a`` (and in\n    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``\n    method evaluated to ``True``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n    axis : int or tuple, optional\n        Axis or tuple of axes along which to count non-zeros.\n        Default is None, meaning that non-zeros will be counted\n        along a flattened version of ``a``.\n\n        .. versionadded:: 1.12.0\n\n    Returns\n    -------\n    count : int or array of int\n        Number of non-zero values in the array along a given axis.\n        Otherwise, the total number of non-zero values in the array\n        is returned.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> np.count_nonzero(np.eye(4))\n    4\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n    5\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)\n    array([1, 1, 1, 1, 1])\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)\n    array([2, 3])\n\n    ","^0","^9"],["^ ","^7","float128","^8","Extended-precision floating-point number type, compatible with C\n    ``long double`` but not necessarily with IEEE 754 quadruple-precision.\n    Character code: ``'g'``.\n    Canonical name: ``np.longdouble``.\n    Alias: ``np.longfloat``.\n    Alias *on this platform*: ``np.float128``: 128-bit extended-precision floating-point number type.","^0","^0"],["^ ","^7","greater","^8","greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 > x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\n\nSee Also\n--------\ngreater_equal, less, less_equal, equal, not_equal\n\nExamples\n--------\n>>> np.greater([4,2],[2,2])\narray([ True, False])\n\nIf the inputs are ndarrays, then np.greater is equivalent to '>'.\n\n>>> a = np.array([4,2])\n>>> b = np.array([2,2])\n>>> a > b\narray([ True, False])","^0","^;"],["^ ","^7","sort","^8","\n    Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort or radix sort under the covers and, in general,\n        the actual implementation will vary with data type. The 'mergesort' option\n        is retained for backwards compatibility.\n\n        .. versionchanged:: 1.15.0.\n           The 'stable' option was added.\n\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n    partition : Partial sort.\n\n    Notes\n    -----\n    The various sorting algorithms are characterized by their average speed,\n    worst case performance, work space size, and whether they are stable. A\n    stable sort keeps items with the same key in the same relative\n    order. The four algorithms implemented in NumPy have the following\n    properties:\n\n    =========== ======= ============= ============ ========\n       kind      speed   worst case    work space   stable\n    =========== ======= ============= ============ ========\n    'quicksort'    1     O(n^2)            0          no\n    'heapsort'     3     O(n*log(n))       0          no\n    'mergesort'    2     O(n*log(n))      ~n/2        yes\n    'timsort'      2     O(n*log(n))      ~n/2        yes\n    =========== ======= ============= ============ ========\n\n    .. note:: The datatype determines which of 'mergesort' or 'timsort'\n       is actually used, even if 'mergesort' is specified. User selection\n       at a finer scale is not currently available.\n\n    All the sort algorithms make temporary copies of the data when\n    sorting along any but the last axis.  Consequently, sorting along\n    the last axis is faster and uses less space than sorting along\n    any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the real\n    and imaginary parts are non-nan then the order is determined by the\n    real parts except when they are equal, in which case the order is\n    determined by the imaginary parts.\n\n    Previous to numpy 1.4.0 sorting real and complex arrays containing nan\n    values led to undefined behaviour. In numpy versions >= 1.4.0 nan\n    values are sorted to the end. The extended sort order is:\n\n      * Real: [R, nan]\n      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n    where R is a non-nan real value. Complex values with the same nan\n    placements are sorted according to the non-nan part if it exists.\n    Non-nan values are sorted as before.\n\n    .. versionadded:: 1.12.0\n\n    quicksort has been changed to `introsort <https://en.wikipedia.org/wiki/Introsort>`_.\n    When sorting does not make enough progress it switches to\n    `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_.\n    This implementation makes quicksort O(n*log(n)) in the worst case.\n\n    'stable' automatically chooses the best stable sorting algorithm\n    for the data type being sorted.\n    It, along with 'mergesort' is currently mapped to\n    `timsort <https://en.wikipedia.org/wiki/Timsort>`_\n    or `radix sort <https://en.wikipedia.org/wiki/Radix_sort>`_\n    depending on the data type.\n    API forward compatibility currently limits the\n    ability to select the implementation and it is hardwired for the different\n    data types.\n\n    .. versionadded:: 1.17.0\n\n    Timsort is added for better performance on already or nearly\n    sorted data. On random data timsort is almost identical to\n    mergesort. It is now used for stable sort while quicksort is still the\n    default sort if none is chosen. For timsort details, refer to\n    `CPython listsort.txt <https://github.com/python/cpython/blob/3.7/Objects/listsort.txt>`_.\n    'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an\n    O(n) sort instead of O(n log n).\n\n    .. versionchanged:: 1.17.0\n\n    NaT now sorts to the end of arrays for consistency with NaN.\n\n    Examples\n    --------\n    >>> a = np.array([[1,4],[3,1]])\n    >>> np.sort(a)                # sort along the last axis\n    array([[1, 4],\n           [1, 3]])\n    >>> np.sort(a, axis=None)     # sort the flattened array\n    array([1, 1, 3, 4])\n    >>> np.sort(a, axis=0)        # sort along the first axis\n    array([[1, 1],\n           [3, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]\n    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n    ...           ('Galahad', 1.7, 38)]\n    >>> a = np.array(values, dtype=dtype)       # create a structured array\n    >>> np.sort(a, order='height')                        # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n           ('Lancelot', 1.8999999999999999, 38)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    Sort by age, then height if ages are equal:\n\n    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n           ('Arthur', 1.8, 41)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    ","^0","^9"],["^ ","^7","poly1d","^8","\n    A one-dimensional polynomial class.\n\n    A convenience class, used to encapsulate \"natural\" operations on\n    polynomials so that said operations may take on their customary\n    form in code (see Examples).\n\n    Parameters\n    ----------\n    c_or_r : array_like\n        The polynomial's coefficients, in decreasing powers, or if\n        the value of the second parameter is True, the polynomial's\n        roots (values where the polynomial evaluates to 0).  For example,\n        ``poly1d([1, 2, 3])`` returns an object that represents\n        :math:`x^2 + 2x + 3`, whereas ``poly1d([1, 2, 3], True)`` returns\n        one that represents :math:`(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6`.\n    r : bool, optional\n        If True, `c_or_r` specifies the polynomial's roots; the default\n        is False.\n    variable : str, optional\n        Changes the variable used when printing `p` from `x` to `variable`\n        (see Examples).\n\n    Examples\n    --------\n    Construct the polynomial :math:`x^2 + 2x + 3`:\n\n    >>> p = np.poly1d([1, 2, 3])\n    >>> print(np.poly1d(p))\n       2\n    1 x + 2 x + 3\n\n    Evaluate the polynomial at :math:`x = 0.5`:\n\n    >>> p(0.5)\n    4.25\n\n    Find the roots:\n\n    >>> p.r\n    array([-1.+1.41421356j, -1.-1.41421356j])\n    >>> p(p.r)\n    array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary\n\n    These numbers in the previous line represent (0, 0) to machine precision\n\n    Show the coefficients:\n\n    >>> p.c\n    array([1, 2, 3])\n\n    Display the order (the leading zero-coefficients are removed):\n\n    >>> p.order\n    2\n\n    Show the coefficient of the k-th power in the polynomial\n    (which is equivalent to ``p.c[-(i+1)]``):\n\n    >>> p[1]\n    2\n\n    Polynomials can be added, subtracted, multiplied, and divided\n    (returns quotient and remainder):\n\n    >>> p * p\n    poly1d([ 1,  4, 10, 12,  9])\n\n    >>> (p**3 + 4) / p\n    (poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))\n\n    ``asarray(p)`` gives the coefficient array, so polynomials can be\n    used in all functions that accept arrays:\n\n    >>> p**2 # square of polynomial\n    poly1d([ 1,  4, 10, 12,  9])\n\n    >>> np.square(p) # square of individual coefficients\n    array([1, 4, 9])\n\n    The variable used in the string representation of `p` can be modified,\n    using the `variable` parameter:\n\n    >>> p = np.poly1d([1,2,3], variable='z')\n    >>> print(p)\n       2\n    1 z + 2 z + 3\n\n    Construct a polynomial from its roots:\n\n    >>> np.poly1d([1, 2], True)\n    poly1d([ 1., -3.,  2.])\n\n    This is the same polynomial as obtained by:\n\n    >>> np.poly1d([1, -1]) * np.poly1d([1, -2])\n    poly1d([ 1, -3,  2])\n\n    ","^0","^0"],["^ ","^7","isfinite","^8","isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for finiteness (not infinity or not Not a Number).\n\nThe result is returned as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray, bool\n    True where ``x`` is not positive infinity, negative infinity,\n    or NaN; false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisinf, isneginf, isposinf, isnan\n\nNotes\n-----\nNot a Number, positive infinity and negative infinity are considered\nto be non-finite.\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.  Errors result if the\nsecond argument is also supplied when `x` is a scalar input, or if\nfirst and second arguments have different shapes.\n\nExamples\n--------\n>>> np.isfinite(1)\nTrue\n>>> np.isfinite(0)\nTrue\n>>> np.isfinite(np.nan)\nFalse\n>>> np.isfinite(np.inf)\nFalse\n>>> np.isfinite(np.NINF)\nFalse\n>>> np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isfinite(x, y)\narray([0, 1, 0])\n>>> y\narray([0, 1, 0])","^0","^;"],["^ ","^7","log","^8","log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNatural logarithm, element-wise.\n\nThe natural logarithm `log` is the inverse of the exponential function,\nso that `log(exp(x)) = x`. The natural logarithm is logarithm in base\n`e`.\n\nParameters\n----------\nx : array_like\n    Input value.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The natural logarithm of `x`, element-wise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlog10, log2, log1p, emath.log\n\nNotes\n-----\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `exp(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log` always returns real output. For\neach value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm\n\nExamples\n--------\n>>> np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])","^0","^;"],["^ ","^7","complex128","^8","Complex number type composed of two double-precision floating-point\n    numbers, compatible with Python `complex`.\n    Character code: ``'D'``.\n    Canonical name: ``np.cdouble``.\n    Alias: ``np.cfloat``.\n    Alias: ``np.complex_``.\n    Alias *on this platform*: ``np.complex128``: Complex number type composed of 2 64-bit-precision floating-point numbers.","^0","^0"],["^ ","^7","fromfunction","^8","\n    Construct an array by executing a function over each coordinate.\n\n    The resulting array therefore has a value ``fn(x, y, z)`` at\n    coordinate ``(x, y, z)``.\n\n    Parameters\n    ----------\n    function : callable\n        The function is called with N parameters, where N is the rank of\n        `shape`.  Each parameter represents the coordinates of the array\n        varying along a specific axis.  For example, if `shape`\n        were ``(2, 2)``, then the parameters would be\n        ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``\n    shape : (N,) tuple of ints\n        Shape of the output array, which also determines the shape of\n        the coordinate arrays passed to `function`.\n    dtype : data-type, optional\n        Data-type of the coordinate arrays passed to `function`.\n        By default, `dtype` is float.\n\n    Returns\n    -------\n    fromfunction : any\n        The result of the call to `function` is passed back directly.\n        Therefore the shape of `fromfunction` is completely determined by\n        `function`.  If `function` returns a scalar value, the shape of\n        `fromfunction` would not match the `shape` parameter.\n\n    See Also\n    --------\n    indices, meshgrid\n\n    Notes\n    -----\n    Keywords other than `dtype` are passed to `function`.\n\n    Examples\n    --------\n    >>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\n    array([[ True, False, False],\n           [False,  True, False],\n           [False, False,  True]])\n\n    >>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\n    array([[0, 1, 2],\n           [1, 2, 3],\n           [2, 3, 4]])\n\n    ","^0","^9"],["^ ","^7","nancumprod","^8","\n    Return the cumulative product of array elements over a given axis treating Not a\n    Numbers (NaNs) as one.  The cumulative product does not change when NaNs are\n    encountered and leading NaNs are replaced by ones.\n\n    Ones are returned for slices that are all-NaN or empty.\n\n    .. versionadded:: 1.12.0\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    nancumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case it is returned.\n\n    See Also\n    --------\n    numpy.cumprod : Cumulative product across array propagating NaNs.\n    isnan : Show which elements are NaN.\n\n    Examples\n    --------\n    >>> np.nancumprod(1)\n    array([1])\n    >>> np.nancumprod([1])\n    array([1])\n    >>> np.nancumprod([1, np.nan])\n    array([1.,  1.])\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nancumprod(a)\n    array([1.,  2.,  6.,  6.])\n    >>> np.nancumprod(a, axis=0)\n    array([[1.,  2.],\n           [3.,  2.]])\n    >>> np.nancumprod(a, axis=1)\n    array([[1.,  2.],\n           [3.,  3.]])\n\n    ","^0","^9"],["^ ","^7","divmod","^8","divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn element-wise quotient and remainder simultaneously.\n\n.. versionadded:: 1.13.0\n\n``np.divmod(x, y)`` is equivalent to ``(x // y, x % y)``, but faster\nbecause it avoids redundant work. It is used to implement the Python\nbuilt-in function ``divmod`` on NumPy arrays.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout1 : ndarray\n    Element-wise quotient resulting from floor division.\n    This is a scalar if both `x1` and `x2` are scalars.\nout2 : ndarray\n    Element-wise remainder from floor division.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloor_divide : Equivalent to Python's ``//`` operator.\nremainder : Equivalent to Python's ``%`` operator.\nmodf : Equivalent to ``divmod(x, 1)`` for positive ``x`` with the return\n       values switched.\n\nExamples\n--------\n>>> np.divmod(np.arange(5), 3)\n(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))","^0","^;"],["^ ","^8","","^0","^<"],["^ ","^7","diag_indices_from","^8","\n    Return the indices to access the main diagonal of an n-dimensional array.\n\n    See `diag_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array, at least 2-D\n\n    See Also\n    --------\n    diag_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    ","^0","^9"],["^ ","^7","savetxt","^8","\n    Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename or file handle\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : 1D or 2D array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs, optional\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored. For complex `X`, the legal options\n        for `fmt` are:\n\n        * a single specifier, `fmt='%.4e'`, resulting in numbers formatted\n          like `' (%s+%sj)' % (fmt, fmt)`\n        * a full string specifying every real and imaginary part, e.g.\n          `' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'` for 3 columns\n        * a list of specifiers, one per column - in this case, the real\n          and imaginary part must have separate specifiers,\n          e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns\n    delimiter : str, optional\n        String or character separating columns.\n    newline : str, optional\n        String or character separating lines.\n\n        .. versionadded:: 1.5.0\n    header : str, optional\n        String that will be written at the beginning of the file.\n\n        .. versionadded:: 1.7.0\n    footer : str, optional\n        String that will be written at the end of the file.\n\n        .. versionadded:: 1.7.0\n    comments : str, optional\n        String that will be prepended to the ``header`` and ``footer`` strings,\n        to mark them as comments. Default: '# ',  as expected by e.g.\n        ``numpy.loadtxt``.\n\n        .. versionadded:: 1.7.0\n    encoding : {None, str}, optional\n        Encoding used to encode the outputfile. Does not apply to output\n        streams. If the encoding is something other than 'bytes' or 'latin1'\n        you will not be able to load the file in NumPy versions < 1.14. Default\n        is 'latin1'.\n\n        .. versionadded:: 1.14.0\n\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into an uncompressed ``.npz`` archive\n    savez_compressed : Save several arrays into a compressed ``.npz`` archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to precede result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : unsigned decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <https://docs.python.org/library/string.html#format-specification-mini-language>`_,\n           Python Documentation.\n\n    Examples\n    --------\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n\n    ","^0","^9"],["^ ","^7","timedelta64","^8",null,"^0","^0"],["^ ","^7","atleast_3d","^8","\n    View inputs as arrays with at least three dimensions.\n\n    Parameters\n    ----------\n    arys1, arys2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted to\n        arrays.  Arrays that already have three or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res1, res2, ... : ndarray\n        An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are\n        avoided where possible, and views with three or more dimensions are\n        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n        view of shape ``(M, N, 1)``.\n\n    See Also\n    --------\n    atleast_1d, atleast_2d\n\n    Examples\n    --------\n    >>> np.atleast_3d(3.0)\n    array([[[3.]]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_3d(x).shape\n    (1, 3, 1)\n\n    >>> x = np.arange(12.0).reshape(4,3)\n    >>> np.atleast_3d(x).shape\n    (4, 3, 1)\n    >>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\n    True\n\n    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n    ...     print(arr, arr.shape) # doctest: +SKIP\n    ...\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1 2]]] (1, 1, 2)\n\n    ","^0","^9"],["^ ","^8",null,"^0","^C"],["^ ","^7","ndarray","^8","ndarray(shape, dtype=float, buffer=None, offset=0,\n            strides=None, order=None)\n\n    An array object represents a multidimensional, homogeneous array\n    of fixed-size items.  An associated data-type object describes the\n    format of each element in the array (its byte-order, how many bytes it\n    occupies in memory, whether it is an integer, a floating point number,\n    or something else, etc.)\n\n    Arrays should be constructed using `array`, `zeros` or `empty` (refer\n    to the See Also section below).  The parameters given here refer to\n    a low-level method (`ndarray(...)`) for instantiating an array.\n\n    For more information, refer to the `numpy` module and examine the\n    methods and attributes of an array.\n\n    Parameters\n    ----------\n    (for the __new__ method; see Notes below)\n\n    shape : tuple of ints\n        Shape of created array.\n    dtype : data-type, optional\n        Any object that can be interpreted as a numpy data type.\n    buffer : object exposing buffer interface, optional\n        Used to fill the array with data.\n    offset : int, optional\n        Offset of array data in buffer.\n    strides : tuple of ints, optional\n        Strides of data in memory.\n    order : {'C', 'F'}, optional\n        Row-major (C-style) or column-major (Fortran-style) order.\n\n    Attributes\n    ----------\n    T : ndarray\n        Transpose of the array.\n    data : buffer\n        The array's elements, in memory.\n    dtype : dtype object\n        Describes the format of the elements in the array.\n    flags : dict\n        Dictionary containing information related to memory use, e.g.,\n        'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.\n    flat : numpy.flatiter object\n        Flattened version of the array as an iterator.  The iterator\n        allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\n        assignment examples; TODO).\n    imag : ndarray\n        Imaginary part of the array.\n    real : ndarray\n        Real part of the array.\n    size : int\n        Number of elements in the array.\n    itemsize : int\n        The memory use of each array element in bytes.\n    nbytes : int\n        The total number of bytes required to store the array data,\n        i.e., ``itemsize * size``.\n    ndim : int\n        The array's number of dimensions.\n    shape : tuple of ints\n        Shape of the array.\n    strides : tuple of ints\n        The step-size required to move from one element to the next in\n        memory. For example, a contiguous ``(3, 4)`` array of type\n        ``int16`` in C-order has strides ``(8, 2)``.  This implies that\n        to move from element to element in memory requires jumps of 2 bytes.\n        To move from row-to-row, one needs to jump 8 bytes at a time\n        (``2 * 4``).\n    ctypes : ctypes object\n        Class containing properties of the array needed for interaction\n        with ctypes.\n    base : ndarray\n        If the array is a view into another array, that array is its `base`\n        (unless that array is also a view).  The `base` array is where the\n        array data is actually stored.\n\n    See Also\n    --------\n    array : Construct an array.\n    zeros : Create an array, each element of which is zero.\n    empty : Create an array, but leave its allocated memory unchanged (i.e.,\n            it contains \"garbage\").\n    dtype : Create a data-type.\n\n    Notes\n    -----\n    There are two modes of creating an array using ``__new__``:\n\n    1. If `buffer` is None, then only `shape`, `dtype`, and `order`\n       are used.\n    2. If `buffer` is an object exposing the buffer interface, then\n       all keywords are interpreted.\n\n    No ``__init__`` method is needed because the array is fully initialized\n    after the ``__new__`` method.\n\n    Examples\n    --------\n    These examples illustrate the low-level `ndarray` constructor.  Refer\n    to the `See Also` section above for easier ways of constructing an\n    ndarray.\n\n    First mode, `buffer` is None:\n\n    >>> np.ndarray(shape=(2,2), dtype=float, order='F')\n    array([[0.0e+000, 0.0e+000], # random\n           [     nan, 2.5e-323]])\n\n    Second mode:\n\n    >>> np.ndarray((2,), buffer=np.array([1,2,3]),\n    ...            offset=np.int_().itemsize,\n    ...            dtype=int) # offset = 1*itemsize, i.e. skip first element\n    array([2, 3])","^0","^0"],["^ ","^7","product","^8","\n    Return the product of array elements over a given axis.\n\n    See Also\n    --------\n    prod : equivalent function; see for details.\n    ","^0","^9"],["^ ","^8","Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.","^0","^I"],["^ ","^7","ptp","^8","\n    Range of values (maximum - minimum) along an axis.\n\n    The name of the function comes from the acronym for 'peak to peak'.\n\n    Parameters\n    ----------\n    a : array_like\n        Input values.\n    axis : None or int or tuple of ints, optional\n        Axis along which to find the peaks.  By default, flatten the\n        array.  `axis` may be negative, in\n        which case it counts from the last to the first axis.\n\n        .. versionadded:: 1.15.0\n\n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : array_like\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type of the output values will be cast if necessary.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `ptp` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    ptp : ndarray\n        A new array holding the result, unless `out` was\n        specified, in which case a reference to `out` is returned.\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.ptp(x, axis=0)\n    array([2, 2])\n\n    >>> np.ptp(x, axis=1)\n    array([1, 1])\n\n    ","^0","^9"],["^ ","^7","floating","^8","Abstract base class of all floating-point scalar types.","^0","^0"],["^ ","^7","arctan","^8","arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse tangent, element-wise.\n\nThe inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.\n\nParameters\n----------\nx : array_like\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Out has the same shape as `x`.  Its real part is in\n    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\narctan2 : The \"four quadrant\" arctan of the angle formed by (`x`, `y`)\n    and the positive `x`-axis.\nangle : Argument of complex values.\n\nNotes\n-----\n`arctan` is a multi-valued function: for each `x` there are infinitely\nmany numbers `z` such that tan(`z`) = `x`.  The convention is to return\nthe angle `z` whose real part lies in [-pi/2, pi/2].\n\nFor real-valued input data types, `arctan` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arctan` is a complex analytic function that\nhas [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous\nfrom the left on the former and from the right on the latter.\n\nThe inverse tangent is also known as `atan` or tan^{-1}.\n\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79.\nhttp://www.math.sfu.ca/~cbm/aands/\n\nExamples\n--------\nWe expect the arctan of 0 to be 0, and of 1 to be pi/4:\n\n>>> np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n\n>>> np.pi/4\n0.78539816339744828\n\nPlot arctan:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-10, 10)\n>>> plt.plot(x, np.arctan(x))\n>>> plt.axis('tight')\n>>> plt.show()","^0","^;"],["^ ","^7","fromstring","^8","fromstring(string, dtype=float, count=-1, sep='')\n\n    A new 1-D array initialized from text data in a string.\n\n    Parameters\n    ----------\n    string : str\n        A string containing the data.\n    dtype : data-type, optional\n        The data type of the array; default: float.  For binary input data,\n        the data must be in exactly this format. Most builtin numeric types are \n        supported and extension types may be supported.\n\n        .. versionadded:: 1.18.0\n            Complex dtypes.\n\n    count : int, optional\n        Read this number of `dtype` elements from the data.  If this is\n        negative (the default), the count will be determined from the\n        length of the data.\n    sep : str, optional\n        The string separating numbers in the data; extra whitespace between\n        elements is also ignored.\n\n        .. deprecated:: 1.14\n            Passing ``sep=''``, the default, is deprecated since it will\n            trigger the deprecated binary mode of this function. This mode\n            interprets `string` as binary bytes, rather than ASCII text with\n            decimal numbers, an operation which is better spelt\n            ``frombuffer(string, dtype, count)``. If `string` contains unicode\n            text, the binary mode of `fromstring` will first encode it into\n            bytes using either utf-8 (python 3) or the default encoding\n            (python 2), neither of which produce sane results.\n\n    Returns\n    -------\n    arr : ndarray\n        The constructed array.\n\n    Raises\n    ------\n    ValueError\n        If the string is not the correct size to satisfy the requested\n        `dtype` and `count`.\n\n    See Also\n    --------\n    frombuffer, fromfile, fromiter\n\n    Examples\n    --------\n    >>> np.fromstring('1 2', dtype=int, sep=' ')\n    array([1, 2])\n    >>> np.fromstring('1, 2', dtype=int, sep=',')\n    array([1, 2])","^0","^?"],["^ ","^8","Special keyword value.\n\n    The instance of this class may be used as the default value assigned to a\n    deprecated keyword in order to check if it has been given a user defined\n    value.\n    ","^0","~:no-value-type"],["^ ","^7","signedinteger","^8","Abstract base class of all signed integer scalar types.","^0","^0"],["^ ","^7","any","^8","\n    Test whether any array element along a given axis evaluates to True.\n\n    Returns single boolean unless `axis` is not ``None``\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a logical OR reduction is performed.\n        The default (``axis=None``) is to perform a logical OR over all\n        the dimensions of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See `ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `any` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.any : equivalent method\n\n    all : Test whether all elements along a given axis evaluate to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.any([[True, False], [True, True]])\n    True\n\n    >>> np.any([[True, False], [False, False]], axis=0)\n    array([ True, False])\n\n    >>> np.any([-1, 0, 5])\n    True\n\n    >>> np.any(np.nan)\n    True\n\n    >>> o=np.array(False)\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array(True), array(True))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n\n    ","^0","^9"],["^ ","^7","angle","^8","\n    Return the angle of the complex argument.\n\n    Parameters\n    ----------\n    z : array_like\n        A complex number or sequence of complex numbers.\n    deg : bool, optional\n        Return angle in degrees if True, radians if False (default).\n\n    Returns\n    -------\n    angle : ndarray or scalar\n        The counterclockwise angle from the positive real axis on the complex\n        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.\n\n        ..versionchanged:: 1.16.0\n            This function works on subclasses of ndarray like `ma.array`.\n\n    See Also\n    --------\n    arctan2\n    absolute\n\n    Examples\n    --------\n    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians\n    array([ 0.        ,  1.57079633,  0.78539816]) # may vary\n    >>> np.angle(1+1j, deg=True)                  # in degrees\n    45.0\n\n    ","^0","^9"],["^ ","^7","reshape","^8","\n    Gives a new shape to an array without changing its data.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be reshaped.\n    newshape : int or tuple of ints\n        The new shape should be compatible with the original shape. If\n        an integer, then the result will be a 1-D array of that length.\n        One shape dimension can be -1. In this case, the value is\n        inferred from the length of the array and remaining dimensions.\n    order : {'C', 'F', 'A'}, optional\n        Read the elements of `a` using this index order, and place the\n        elements into the reshaped array using this index order.  'C'\n        means to read / write the elements using C-like index order,\n        with the last axis index changing fastest, back to the first\n        axis index changing slowest. 'F' means to read / write the\n        elements using Fortran-like index order, with the first index\n        changing fastest, and the last index changing slowest. Note that\n        the 'C' and 'F' options take no account of the memory layout of\n        the underlying array, and only refer to the order of indexing.\n        'A' means to read / write the elements in Fortran-like index\n        order if `a` is Fortran *contiguous* in memory, C-like order\n        otherwise.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        This will be a new view object if possible; otherwise, it will\n        be a copy.  Note there is no guarantee of the *memory layout* (C- or\n        Fortran- contiguous) of the returned array.\n\n    See Also\n    --------\n    ndarray.reshape : Equivalent method.\n\n    Notes\n    -----\n    It is not always possible to change the shape of an array without\n    copying the data. If you want an error to be raised when the data is copied,\n    you should assign the new shape to the shape attribute of the array::\n\n     >>> a = np.zeros((10, 2))\n\n     # A transpose makes the array non-contiguous\n     >>> b = a.T\n\n     # Taking a view makes it possible to modify the shape without modifying\n     # the initial object.\n     >>> c = b.view()\n     >>> c.shape = (20)\n     Traceback (most recent call last):\n        ...\n     AttributeError: incompatible shape for a non-contiguous array\n\n    The `order` keyword gives the index ordering both for *fetching* the values\n    from `a`, and then *placing* the values into the output array.\n    For example, let's say you have an array:\n\n    >>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n\n    You can think of reshaping as first raveling the array (using the given\n    index order), then inserting the elements from the raveled array into the\n    new array using the same kind of index ordering as was used for the\n    raveling.\n\n    >>> np.reshape(a, (2, 3)) # C-like index ordering\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering\n    array([[0, 4, 3],\n           [2, 1, 5]])\n    >>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')\n    array([[0, 4, 3],\n           [2, 1, 5]])\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.reshape(a, 6, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    ","^0","^9"],["^ ","^7","i0","^8","\n    Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*\n    \"up-cast\" int dtype arguments unless accompanied by at least one float or\n    complex dtype argument (see Raises below).\n\n    Parameters\n    ----------\n    x : array_like, dtype float or complex\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    out : ndarray, shape = x.shape, dtype = x.dtype\n        The modified Bessel function evaluated at each of the elements of `x`.\n\n    Raises\n    ------\n    TypeError: array cannot be safely cast to required type\n        If argument consists exclusively of int dtypes.\n\n    See Also\n    --------\n    scipy.special.i0, scipy.special.iv, scipy.special.ive\n\n    Notes\n    -----\n    The scipy implementation is recommended over this function: it is a\n    proper ufunc written in C, and more than an order of magnitude faster.\n\n    We use the algorithm published by Clenshaw [1]_ and referenced by\n    Abramowitz and Stegun [2]_, for which the function domain is\n    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev\n    polynomial expansions are employed in each interval. Relative error on\n    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a\n    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).\n\n    References\n    ----------\n    .. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions\", in\n           *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n           Her Majesty's Stationery Office, 1962.\n    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n           Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n           http://www.math.sfu.ca/~cbm/aands/page_379.htm\n    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html\n\n    Examples\n    --------\n    >>> np.i0(0.)\n    array(1.0)  # may vary\n    >>> np.i0([0., 1. + 2j])\n    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary\n\n    ","^0","^9"],["^ ","^7","ndenumerate","^8","\n    Multidimensional index iterator.\n\n    Return an iterator yielding pairs of array coordinates and values.\n\n    Parameters\n    ----------\n    arr : ndarray\n      Input array.\n\n    See Also\n    --------\n    ndindex, flatiter\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> for index, x in np.ndenumerate(a):\n    ...     print(index, x)\n    (0, 0) 1\n    (0, 1) 2\n    (1, 0) 3\n    (1, 1) 4\n\n    ","^0","^0"],["^ ","^7","hamming","^8","\n    Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, with the maximum value normalized to one (the value\n        one appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hanning, kaiser\n\n    Notes\n    -----\n    The Hamming window is defined as\n\n    .. math::  w(n) = 0.54 - 0.46cos\\left(\\frac{2\\pi{n}}{M-1}\\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey\n    and is described in Blackman and Tukey. It was recommended for\n    smoothing the truncated autocovariance function in the time domain.\n    Most references to the Hamming window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 109-110.\n    .. [3] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> np.hamming(12)\n    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n            0.15302337,  0.08      ])\n\n    Plot the window and the frequency response:\n\n    >>> import matplotlib.pyplot as plt\n    >>> from numpy.fft import fft, fftshift\n    >>> window = np.hamming(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hamming window\")\n    Text(0.5, 1.0, 'Hamming window')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"Sample\")\n    Text(0.5, 0, 'Sample')\n    >>> plt.show()\n\n    >>> plt.figure()\n    <Figure size 640x480 with 0 Axes>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(mag)\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Hamming window\")\n    Text(0.5, 1.0, 'Frequency response of Hamming window')\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    Text(0, 0.5, 'Magnitude [dB]')\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    Text(0.5, 0, 'Normalized frequency [cycles per sample]')\n    >>> plt.axis('tight')\n    ...\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^8","","^0","^:"],["^ ","^8","","^0","^:"],["^ ","^8","","^0","^<"],["^ ","^7","array2string","^8","\n    Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int or None, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n    suffix: str, optional\n        The length of the prefix and suffix strings are used to respectively\n        align and wrap the output. An array is typically printed as::\n\n          prefix + array2string(a) + suffix\n\n        The output is left-padded by the length of the prefix string, and\n        wrapping is forced at the column ``max_line_width - len(suffix)``.\n        It should be noted that the content of prefix and suffix strings are\n        not included in the output.\n    style : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.14.0\n    formatter : dict of callables, optional\n        If not None, the keys should indicate the type(s) that the respective\n        formatting function applies to.  Callables should return a string.\n        Types that are not specified (by their corresponding keys) are handled\n        by the default formatters.  Individual types for which a formatter\n        can be set are:\n\n        - 'bool'\n        - 'int'\n        - 'timedelta' : a `numpy.timedelta64`\n        - 'datetime' : a `numpy.datetime64`\n        - 'float'\n        - 'longfloat' : 128-bit floats\n        - 'complexfloat'\n        - 'longcomplexfloat' : composed of two 128-bit floats\n        - 'void' : type `numpy.void`\n        - 'numpystr' : types `numpy.string_` and `numpy.unicode_`\n        - 'str' : all other strings\n\n        Other keys that can be used to set a group of types at once are:\n\n        - 'all' : sets all types\n        - 'int_kind' : sets 'int'\n        - 'float_kind' : sets 'float' and 'longfloat'\n        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n        - 'str_kind' : sets 'str' and 'numpystr'\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr.\n        Defaults to ``numpy.get_printoptions()['threshold']``.\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension.\n        Defaults to ``numpy.get_printoptions()['edgeitems']``.\n    sign : string, either '-', '+', or ' ', optional\n        Controls printing of the sign of floating-point types. If '+', always\n        print the sign of positive values. If ' ', always prints a space\n        (whitespace character) in the sign position of positive values.  If\n        '-', omit the sign character of positive values.\n        Defaults to ``numpy.get_printoptions()['sign']``.\n    floatmode : str, optional\n        Controls the interpretation of the `precision` option for\n        floating-point types.\n        Defaults to ``numpy.get_printoptions()['floatmode']``.\n        Can take the following values:\n\n        - 'fixed': Always print exactly `precision` fractional digits,\n          even if this would print more or fewer digits than\n          necessary to specify the value uniquely.\n        - 'unique': Print the minimum number of fractional digits necessary\n          to represent each value uniquely. Different elements may\n          have a different number of digits.  The value of the\n          `precision` option is ignored.\n        - 'maxprec': Print at most `precision` fractional digits, but if\n          an element can be uniquely represented with fewer digits\n          only print it with that many.\n        - 'maxprec_equal': Print at most `precision` fractional digits,\n          but if every element in the array can be uniquely\n          represented with an equal number of fewer digits, use that\n          many digits for all elements.\n    legacy : string or `False`, optional\n        If set to the string `'1.13'` enables 1.13 legacy printing mode. This\n        approximates numpy 1.13 print output by including a space in the sign\n        position of floats and different behavior for 0d arrays. If set to\n        `False`, disables legacy mode. Unrecognized strings will be ignored\n        with a warning for forward compatibility.\n\n        .. versionadded:: 1.14.0\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    Raises\n    ------\n    TypeError\n        if a callable in `formatter` does not return a string.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions, get_printoptions\n\n    Notes\n    -----\n    If a formatter is specified for a certain type, the `precision` keyword is\n    ignored for that type.\n\n    This is a very flexible function; `array_repr` and `array_str` are using\n    `array2string` internally so keywords with the same name should work\n    identically in all three functions.\n\n    Examples\n    --------\n    >>> x = np.array([1e-16,1,2,3])\n    >>> np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    '[0.,1.,2.,3.]'\n\n    >>> x  = np.arange(3.)\n    >>> np.array2string(x, formatter={'float_kind':lambda x: \"%.2f\" % x})\n    '[0.00 1.00 2.00]'\n\n    >>> x  = np.arange(3)\n    >>> np.array2string(x, formatter={'int':lambda x: hex(x)})\n    '[0x0 0x1 0x2]'\n\n    ","^0","^9"],["^ ","^7","disp","^8","\n    Display a message on a device.\n\n    Parameters\n    ----------\n    mesg : str\n        Message to display.\n    device : object\n        Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods.\n    linefeed : bool, optional\n        Option whether to print a line feed or not. Defaults to True.\n\n    Raises\n    ------\n    AttributeError\n        If `device` does not have a ``write()`` or ``flush()`` method.\n\n    Examples\n    --------\n    Besides ``sys.stdout``, a file-like object can also be used as it has\n    both required methods:\n\n    >>> from io import StringIO\n    >>> buf = StringIO()\n    >>> np.disp(u'\"Display\" in a file', device=buf)\n    >>> buf.getvalue()\n    '\"Display\" in a file\\n'\n\n    ","^0","^9"],["^ ","^7","packbits","^8","\n    packbits(a, axis=None, bitorder='big')\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.\n\n    Parameters\n    ----------\n    a : array_like\n        An array of integers or booleans whose elements should be packed to\n        bits.\n    axis : int, optional\n        The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array.\n    bitorder : {'big', 'little'}, optional\n        The order of the input bits. 'big' will mimic bin(val),\n        ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011 => ``, 'little' will\n        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.\n        Defaults to 'big'.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    packed : ndarray\n        Array of type uint8 whose elements represent bits corresponding to the\n        logical (0 or nonzero) value of the input elements. The shape of\n        `packed` has the same number of dimensions as the input (unless `axis`\n        is None, in which case the output is 1-D).\n\n    See Also\n    --------\n    unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n                array.\n\n    Examples\n    --------\n    >>> a = np.array([[[1,0,1],\n    ...                [0,1,0]],\n    ...               [[1,1,0],\n    ...                [0,0,1]]])\n    >>> b = np.packbits(a, axis=-1)\n    >>> b\n    array([[[160],\n            [ 64]],\n           [[192],\n            [ 32]]], dtype=uint8)\n\n    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\n    and 32 = 0010 0000.\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","percentile","^8","\n    Compute the q-th percentile of the data along the specified axis.\n\n    Returns the q-th percentile(s) of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    q : array_like of float\n        Percentile or sequence of percentiles to compute, which must be between\n        0 and 100 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the percentiles are computed. The\n        default is to compute the percentile(s) along a flattened\n        version of the array.\n\n        .. versionchanged:: 1.9.0\n            A tuple of axes is supported\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined.\n\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to\n        use when the desired percentile lies between two data points\n        ``i < j``:\n\n        * 'linear': ``i + (j - i) * fraction``, where ``fraction``\n          is the fractional part of the index surrounded by ``i``\n          and ``j``.\n        * 'lower': ``i``.\n        * 'higher': ``j``.\n        * 'nearest': ``i`` or ``j``, whichever is nearest.\n        * 'midpoint': ``(i + j) / 2``.\n\n        .. versionadded:: 1.9.0\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n        .. versionadded:: 1.9.0\n\n    Returns\n    -------\n    percentile : scalar or ndarray\n        If `q` is a single percentile and `axis=None`, then the result\n        is a scalar. If multiple percentiles are given, first axis of\n        the result corresponds to the percentiles. The other axes are\n        the axes that remain after the reduction of `a`. If the input\n        contains integers or floats smaller than ``float64``, the output\n        data-type is ``float64``. Otherwise, the output data-type is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean\n    median : equivalent to ``percentile(..., 50)``\n    nanpercentile\n    quantile : equivalent to percentile, except with q in the range [0, 1].\n\n    Notes\n    -----\n    Given a vector ``V`` of length ``N``, the q-th percentile of\n    ``V`` is the value ``q/100`` of the way from the minimum to the\n    maximum in a sorted copy of ``V``. The values and distances of\n    the two nearest neighbors as well as the `interpolation` parameter\n    will determine the percentile if the normalized ranking does not\n    match the location of ``q`` exactly. This function is the same as\n    the median if ``q=50``, the same as the minimum if ``q=0`` and the\n    same as the maximum if ``q=100``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 50, axis=0)\n    array([6.5, 4.5, 2.5])\n    >>> np.percentile(a, 50, axis=1)\n    array([7.,  2.])\n    >>> np.percentile(a, 50, axis=1, keepdims=True)\n    array([[7.],\n           [2.]])\n\n    >>> m = np.percentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.percentile(a, 50, axis=0, out=out)\n    array([6.5, 4.5, 2.5])\n    >>> m\n    array([6.5, 4.5, 2.5])\n\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a == b)\n\n    The different types of interpolation can be visualized graphically:\n\n    .. plot::\n\n        import matplotlib.pyplot as plt\n\n        a = np.arange(4)\n        p = np.linspace(0, 100, 6001)\n        ax = plt.gca()\n        lines = [\n            ('linear', None),\n            ('higher', '--'),\n            ('lower', '--'),\n            ('nearest', '-.'),\n            ('midpoint', '-.'),\n        ]\n        for interpolation, style in lines:\n            ax.plot(\n                p, np.percentile(a, p, interpolation=interpolation),\n                label=interpolation, linestyle=style)\n        ax.set(\n            title='Interpolation methods for list: ' + str(a),\n            xlabel='Percentile',\n            ylabel='List item returned',\n            yticks=a)\n        ax.legend()\n        plt.show()\n\n    ","^0","^9"],["^ ","^7","nanquantile","^8","\n    Compute the qth quantile of the data along the specified axis,\n    while ignoring nan values.\n    Returns the qth quantile(s) of the array elements.\n    \n    .. versionadded:: 1.15.0\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array, containing\n        nan values to be ignored\n    q : array_like of float\n        Quantile or sequence of quantiles to compute, which must be between\n        0 and 1 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the quantiles are computed. The\n        default is to compute the quantile(s) along a flattened\n        version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to\n        use when the desired quantile lies between two data points\n        ``i < j``:\n\n        * linear: ``i + (j - i) * fraction``, where ``fraction``\n          is the fractional part of the index surrounded by ``i``\n          and ``j``.\n        * lower: ``i``.\n        * higher: ``j``.\n        * nearest: ``i`` or ``j``, whichever is nearest.\n        * midpoint: ``(i + j) / 2``.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n        If this is anything but the default value it will be passed\n        through (in the special case of an empty array) to the\n        `mean` function of the underlying array.  If the array is\n        a sub-class and `mean` does not have the kwarg `keepdims` this\n        will raise a RuntimeError.\n\n    Returns\n    -------\n    quantile : scalar or ndarray\n        If `q` is a single percentile and `axis=None`, then the result\n        is a scalar. If multiple quantiles are given, first axis of\n        the result corresponds to the quantiles. The other axes are\n        the axes that remain after the reduction of `a`. If the input\n        contains integers or floats smaller than ``float64``, the output\n        data-type is ``float64``. Otherwise, the output data-type is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    quantile\n    nanmean, nanmedian\n    nanmedian : equivalent to ``nanquantile(..., 0.5)``\n    nanpercentile : same as nanquantile, but with q in the range [0, 100].\n\n    Examples\n    --------\n    >>> a = np.array([[10., 7., 4.], [3., 2., 1.]])\n    >>> a[0][1] = np.nan\n    >>> a\n    array([[10.,  nan,   4.],\n          [ 3.,   2.,   1.]])\n    >>> np.quantile(a, 0.5)\n    nan\n    >>> np.nanquantile(a, 0.5)\n    3.0\n    >>> np.nanquantile(a, 0.5, axis=0)\n    array([6.5, 2. , 2.5])\n    >>> np.nanquantile(a, 0.5, axis=1, keepdims=True)\n    array([[7.],\n           [2.]])\n    >>> m = np.nanquantile(a, 0.5, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.nanquantile(a, 0.5, axis=0, out=out)\n    array([6.5, 2. , 2.5])\n    >>> m\n    array([6.5,  2. ,  2.5])\n    >>> b = a.copy()\n    >>> np.nanquantile(b, 0.5, axis=1, overwrite_input=True)\n    array([7., 2.])\n    >>> assert not np.all(a==b)\n    ","^0","^9"],["^ ","^8","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^0","^@"],["^ ","^7","tril","^8","\n    Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n\n    Parameters\n    ----------\n    m : array_like, shape (M, N)\n        Input array.\n    k : int, optional\n        Diagonal above which to zero elements.  `k = 0` (the default) is the\n        main diagonal, `k < 0` is below it and `k > 0` is above.\n\n    Returns\n    -------\n    tril : ndarray, shape (M, N)\n        Lower triangle of `m`, of same shape and data-type as `m`.\n\n    See Also\n    --------\n    triu : same thing, only for the upper triangle\n\n    Examples\n    --------\n    >>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 0,  0,  0],\n           [ 4,  0,  0],\n           [ 7,  8,  0],\n           [10, 11, 12]])\n\n    ","^0","^9"],["^ ","^7","sin","^8","sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric sine, element-wise.\n\nParameters\n----------\nx : array_like\n    Angle, in radians (:math:`2 \\pi` rad equals 360 degrees).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : array_like\n    The sine of each element of x.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\narcsin, sinh, cos\n\nNotes\n-----\nThe sine is one of the fundamental functions of trigonometry (the\nmathematical study of triangles).  Consider a circle of radius 1\ncentered on the origin.  A ray comes in from the :math:`+x` axis, makes\nan angle at the origin (measured counter-clockwise from that axis), and\ndeparts from the origin.  The :math:`y` coordinate of the outgoing\nray's intersection with the unit circle is the sine of that angle.  It\nranges from -1 for :math:`x=3\\pi / 2` to +1 for :math:`\\pi / 2.`  The\nfunction has zeroes where the angle is a multiple of :math:`\\pi`.\nSines of angles between :math:`\\pi` and :math:`2\\pi` are negative.\nThe numerous properties of the sine and related functions are included\nin any standard trigonometry text.\n\nExamples\n--------\nPrint sine of one angle:\n\n>>> np.sin(np.pi/2.)\n1.0\n\nPrint sines of an array of angles given in degrees:\n\n>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n\nPlot the sine function:\n\n>>> import matplotlib.pylab as plt\n>>> x = np.linspace(-np.pi, np.pi, 201)\n>>> plt.plot(x, np.sin(x))\n>>> plt.xlabel('Angle [rad]')\n>>> plt.ylabel('sin(x)')\n>>> plt.axis('tight')\n>>> plt.show()","^0","^;"],["^ ","^7","flipud","^8","\n    Flip array in the up/down direction.\n\n    Flip the entries in each column in the up/down direction.\n    Rows are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the rows reversed.  Since a view is\n        returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    fliplr : Flip array in the left/right direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to ``m[::-1,...]``.\n    Does not require the array to be two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.0, 2, 3])\n    >>> A\n    array([[1.,  0.,  0.],\n           [0.,  2.,  0.],\n           [0.,  0.,  3.]])\n    >>> np.flipud(A)\n    array([[0.,  0.,  3.],\n           [0.,  2.,  0.],\n           [1.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.flipud(A) == A[::-1,...])\n    True\n\n    >>> np.flipud([1,2])\n    array([2, 1])\n\n    ","^0","^9"],["^ ","^7","power","^8","power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nFirst array elements raised to powers from second array, element-wise.\n\nRaise each base in `x1` to the positionally-corresponding power in\n`x2`.  `x1` and `x2` must be broadcastable to the same shape. Note that an\ninteger type raised to a negative integer power will raise a ValueError.\n\nParameters\n----------\nx1 : array_like\n    The bases.\nx2 : array_like\n    The exponents. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The bases in `x1` raised to the exponents in `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloat_power : power function that promotes integers to float\n\nExamples\n--------\nCube each element in a list.\n\n>>> x1 = range(6)\n>>> x1\n[0, 1, 2, 3, 4, 5]\n>>> np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])\n\nRaise the bases to different exponents.\n\n>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n>>> np.power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\nThe effect of broadcasting.\n\n>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n>>> x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n>>> np.power(x1, x2)\narray([[ 0,  1,  8, 27, 16,  5],\n       [ 0,  1,  8, 27, 16,  5]])","^0","^;"],["^ ","^8","","^0","^:"],["^ ","^7","numpy._pytesttester","^8","\nPytest test running.\n\nThis module implements the ``test()`` function for NumPy modules. The usual\nboiler plate for doing that is to put the following in the module\n``__init__.py`` file::\n\n    from numpy._pytesttester import PytestTester\n    test = PytestTester(__name__).test\n    del PytestTester\n\n\nWarnings filtering and other runtime settings should be dealt with in the\n``pytest.ini`` file in the numpy repo root. The behavior of the test depends on\nwhether or not that file is found as follows:\n\n* ``pytest.ini`` is present (develop mode)\n    All warnings except those explicily filtered out are raised as error.\n* ``pytest.ini`` is absent (release mode)\n    DeprecationWarnings and PendingDeprecationWarnings are ignored, other\n    warnings are passed through.\n\nIn practice, tests run from the numpy repo are run in develop mode. That\nincludes the standard ``python runtests.py`` invocation.\n\nThis module is imported by every numpy subpackage, so lies at the top level to\nsimplify circular import issues. For the same reason, it contains no numpy\nimports at module scope, instead importing numpy within function calls.\n","^0","^>"],["^ ","^7","fabs","^8","fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the absolute values element-wise.\n\nThis function returns the absolute values (positive magnitude) of the\ndata in `x`. Complex values are not handled, use `absolute` to find the\nabsolute values of complex data.\n\nParameters\n----------\nx : array_like\n    The array of numbers for which the absolute values are required. If\n    `x` is a scalar, the result `y` will also be a scalar.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The absolute values of `x`, the returned values are always floats.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nabsolute : Absolute values including `complex` types.\n\nExamples\n--------\n>>> np.fabs(-1)\n1.0\n>>> np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])","^0","^;"],["^ ","^7","gcd","^8","gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the greatest common divisor of ``|x1|`` and ``|x2|``\n\nParameters\n----------\nx1, x2 : array_like, int\n    Arrays of values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\n\nReturns\n-------\ny : ndarray or scalar\n    The greatest common divisor of the absolute value of the inputs\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlcm : The lowest common multiple\n\nExamples\n--------\n>>> np.gcd(12, 20)\n4\n>>> np.gcd.reduce([15, 25, 35])\n5\n>>> np.gcd(np.arange(6), 20)\narray([20,  1,  2,  1,  4,  5])","^0","^;"],["^ ","^7","hypot","^8","hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nGiven the \"legs\" of a right triangle, return its hypotenuse.\n\nEquivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or\n`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),\nit is broadcast for use with each element of the other argument.\n(See Examples)\n\nParameters\n----------\nx1, x2 : array_like\n    Leg of the triangle(s). If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nz : ndarray\n    The hypotenuse of the triangle(s).\n    This is a scalar if both `x1` and `x2` are scalars.\n\nExamples\n--------\n>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\nExample showing broadcast of scalar_like argument:\n\n>>> np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])","^0","^;"],["^ ","^7","unicode_","^8",null,"^0","^0"],["^ ","^7","nested_iters","^8","Create nditers for use in nested loops\n\n    Create a tuple of `nditer` objects which iterate in nested loops over\n    different axes of the op argument. The first iterator is used in the\n    outermost loop, the last in the innermost loop. Advancing one will change\n    the subsequent iterators to point at its new element.\n\n    Parameters\n    ----------\n    op : ndarray or sequence of array_like\n        The array(s) to iterate over.\n\n    axes : list of list of int\n        Each item is used as an \"op_axes\" argument to an nditer\n\n    flags, op_flags, op_dtypes, order, casting, buffersize (optional)\n        See `nditer` parameters of the same name\n\n    Returns\n    -------\n    iters : tuple of nditer\n        An nditer for each item in `axes`, outermost first\n\n    See Also\n    --------\n    nditer\n\n    Examples\n    --------\n\n    Basic usage. Note how y is the \"flattened\" version of\n    [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified\n    the first iter's axes as [1]\n\n    >>> a = np.arange(12).reshape(2, 3, 2)\n    >>> i, j = np.nested_iters(a, [[1], [0, 2]], flags=[\"multi_index\"])\n    >>> for x in i:\n    ...      print(i.multi_index)\n    ...      for y in j:\n    ...          print('', j.multi_index, y)\n    (0,)\n     (0, 0) 0\n     (0, 1) 1\n     (1, 0) 6\n     (1, 1) 7\n    (1,)\n     (0, 0) 2\n     (0, 1) 3\n     (1, 0) 8\n     (1, 1) 9\n    (2,)\n     (0, 0) 4\n     (0, 1) 5\n     (1, 0) 10\n     (1, 1) 11","^0","^?"],["^ ","^7","math","^8","This module provides access to the mathematical functions\ndefined by the C standard.","^0","^>"],["^ ","^7","numpy.ma","^8","\n=============\nMasked Arrays\n=============\n\nArrays sometimes contain invalid or missing data.  When doing operations\non such arrays, we wish to suppress invalid values, which is the purpose masked\narrays fulfill (an example of typical use is given below).\n\nFor example, examine the following array:\n\n>>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])\n\nWhen we try to calculate the mean of the data, the result is undetermined:\n\n>>> np.mean(x)\nnan\n\nThe mean is calculated using roughly ``np.sum(x)/len(x)``, but since\nany number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter\nmasked arrays:\n\n>>> m = np.ma.masked_array(x, np.isnan(x))\n>>> m\nmasked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],\n      mask = [False False False  True False False False  True],\n      fill_value=1e+20)\n\nHere, we construct a masked array that suppress all ``NaN`` values.  We\nmay now proceed to calculate the mean of the other values:\n\n>>> np.mean(m)\n2.6666666666666665\n\n.. [1] Not-a-Number, a floating point value that is the result of an\n       invalid operation.\n\n.. moduleauthor:: Pierre Gerard-Marchant\n.. moduleauthor:: Jarrod Millman\n\n","^0","^>"],["^ ","^7","rate","^8","\n    Compute the rate of interest per period.\n\n    .. deprecated:: 1.18\n\n       `rate` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Parameters\n    ----------\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n    guess : Number, optional\n        Starting guess for solving the rate of interest, default 0.1\n    tol : Number, optional\n        Required tolerance for the solution, default 1e-6\n    maxiter : int, optional\n        Maximum iterations in finding the solution\n\n    Notes\n    -----\n    The rate of interest is computed by iteratively solving the\n    (non-linear) equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0\n\n    for ``rate``.\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    ","^0","^9"],["^ ","^7","ndfromtxt","^8","\n    Load ASCII data stored in a file and return it as a single array.\n\n    .. deprecated:: 1.17\n        ndfromtxt` is a deprecated alias of `genfromtxt` which\n        overwrites the ``usemask`` argument with `False` even when\n        explicitly called as ``ndfromtxt(..., usemask=True)``.\n        Use `genfromtxt` instead.\n\n    Parameters\n    ----------\n    fname, kwargs : For a description of input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function.\n\n    ","^0","^9"],["^ ","^7","bitwise_and","^8","bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``&``.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_and\nbitwise_or\nbitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 is represented by ``00001101``.  Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise AND of 13 and 17 is\ntherefore ``000000001``, or 1:\n\n>>> np.bitwise_and(13, 17)\n1\n\n>>> np.bitwise_and(14, 13)\n12\n>>> np.binary_repr(12)\n'1100'\n>>> np.bitwise_and([14,3], 13)\narray([12,  1])\n\n>>> np.bitwise_and([11,7], [4,25])\narray([0, 1])\n>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n>>> np.bitwise_and([True, True], [False, True])\narray([False,  True])","^0","^;"],["^ ","^7","cdouble","^8","Complex number type composed of two double-precision floating-point\n    numbers, compatible with Python `complex`.\n    Character code: ``'D'``.\n    Canonical name: ``np.cdouble``.\n    Alias: ``np.cfloat``.\n    Alias: ``np.complex_``.\n    Alias *on this platform*: ``np.complex128``: Complex number type composed of 2 64-bit-precision floating-point numbers.","^0","^0"],["^ ","^7","real","^8","\n    Return the real part of the complex argument.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray or scalar\n        The real component of the complex argument. If `val` is real, the type\n        of `val` is used for the output.  If `val` has complex elements, the\n        returned type is float.\n\n    See Also\n    --------\n    real_if_close, imag, angle\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.real\n    array([1.,  3.,  5.])\n    >>> a.real = 9\n    >>> a\n    array([9.+2.j,  9.+4.j,  9.+6.j])\n    >>> a.real = np.array([9, 8, 7])\n    >>> a\n    array([9.+2.j,  8.+4.j,  7.+6.j])\n    >>> np.real(1 + 1j)\n    1.0\n\n    ","^0","^9"],["^ ","^7","fmin","^8","fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then the\nnon-nan element is returned. If both elements are NaNs then the first\nis returned.  The latter distinction is important for complex NaNs,\nwhich are defined as at least one of the real or imaginary parts being\na NaN. The net effect is that NaNs are ignored when possible.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The minimum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfmax :\n    Element-wise maximum of two arrays, ignores NaNs.\nminimum :\n    Element-wise minimum of two arrays, propagates NaNs.\namin :\n    The minimum value of an array along a given axis, propagates NaNs.\nnanmin :\n    The minimum value of an array along a given axis, ignores NaNs.\n\nmaximum, amax, nanmax\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nThe fmin is equivalent to ``np.where(x1 <= x2, x1, x2)`` when neither\nx1 nor x2 are NaNs, but it is faster and does proper broadcasting.\n\nExamples\n--------\n>>> np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n>>> np.fmin(np.eye(2), [0.5, 2])\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n>>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])","^0","^;"],["^ ","^7","format_float_positional","^8","\n    Format a floating-point scalar as a decimal string in positional notation.\n\n    Provides control over rounding, trimming and padding. Uses and assumes\n    IEEE unbiased rounding. Uses the \"Dragon4\" algorithm.\n\n    Parameters\n    ----------\n    x : python float or numpy floating scalar\n        Value to format.\n    precision : non-negative integer or None, optional\n        Maximum number of digits to print. May be None if `unique` is\n        `True`, but must be an integer if unique is `False`.\n    unique : boolean, optional\n        If `True`, use a digit-generation strategy which gives the shortest\n        representation which uniquely identifies the floating-point number from\n        other values of the same type, by judicious rounding. If `precision`\n        was omitted, print out all necessary digits, otherwise digit generation\n        is cut off after `precision` digits and the remaining value is rounded.\n        If `False`, digits are generated as if printing an infinite-precision\n        value and stopping after `precision` digits, rounding the remaining\n        value.\n    fractional : boolean, optional\n        If `True`, the cutoff of `precision` digits refers to the total number\n        of digits after the decimal point, including leading zeros.\n        If `False`, `precision` refers to the total number of significant\n        digits, before or after the decimal point, ignoring leading zeros.\n    trim : one of 'k', '.', '0', '-', optional\n        Controls post-processing trimming of trailing digits, as follows:\n\n        * 'k' : keep trailing zeros, keep decimal point (no trimming)\n        * '.' : trim all trailing zeros, leave decimal point\n        * '0' : trim all but the zero before the decimal point. Insert the\n          zero if it is missing.\n        * '-' : trim trailing zeros and any trailing decimal point\n    sign : boolean, optional\n        Whether to show the sign for positive values.\n    pad_left : non-negative integer, optional\n        Pad the left side of the string with whitespace until at least that\n        many characters are to the left of the decimal point.\n    pad_right : non-negative integer, optional\n        Pad the right side of the string with whitespace until at least that\n        many characters are to the right of the decimal point.\n\n    Returns\n    -------\n    rep : string\n        The string representation of the floating point value\n\n    See Also\n    --------\n    format_float_scientific\n\n    Examples\n    --------\n    >>> np.format_float_positional(np.float32(np.pi))\n    '3.1415927'\n    >>> np.format_float_positional(np.float16(np.pi))\n    '3.14'\n    >>> np.format_float_positional(np.float16(0.3))\n    '0.3'\n    >>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)\n    '0.3000488281'\n    ","^0","^9"],["^ ","^7","__dir__","^8",null,"^0","^9"],["^ ","^7","vectorize","^8","\n    vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,\n              signature=None)\n\n    Generalized function class.\n\n    Define a vectorized function which takes a nested sequence of objects or\n    numpy arrays as inputs and returns a single numpy array or a tuple of numpy\n    arrays. The vectorized function evaluates `pyfunc` over successive tuples\n    of the input arrays like the python map function, except it uses the\n    broadcasting rules of numpy.\n\n    The data type of the output of `vectorized` is determined by calling\n    the function with the first element of the input.  This can be avoided\n    by specifying the `otypes` argument.\n\n    Parameters\n    ----------\n    pyfunc : callable\n        A python function or method.\n    otypes : str or list of dtypes, optional\n        The output data type. It must be specified as either a string of\n        typecode characters or a list of data type specifiers. There should\n        be one data type specifier for each output.\n    doc : str, optional\n        The docstring for the function. If None, the docstring will be the\n        ``pyfunc.__doc__``.\n    excluded : set, optional\n        Set of strings or integers representing the positional or keyword\n        arguments for which the function will not be vectorized.  These will be\n        passed directly to `pyfunc` unmodified.\n\n        .. versionadded:: 1.7.0\n\n    cache : bool, optional\n       If `True`, then cache the first function call that determines the number\n       of outputs if `otypes` is not provided.\n\n        .. versionadded:: 1.7.0\n\n    signature : string, optional\n        Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for\n        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will\n        be called with (and expected to return) arrays with shapes given by the\n        size of corresponding core dimensions. By default, ``pyfunc`` is\n        assumed to take scalars as input and output.\n\n        .. versionadded:: 1.12.0\n\n    Returns\n    -------\n    vectorized : callable\n        Vectorized function.\n\n    See Also\n    --------\n    frompyfunc : Takes an arbitrary Python function and returns a ufunc\n\n    Notes\n    -----\n    The `vectorize` function is provided primarily for convenience, not for\n    performance. The implementation is essentially a for loop.\n\n    If `otypes` is not specified, then a call to the function with the\n    first argument will be used to determine the number of outputs.  The\n    results of this call will be cached if `cache` is `True` to prevent\n    calling the function twice.  However, to implement the cache, the\n    original function must be wrapped which will slow down subsequent\n    calls, so only do this if your function is expensive.\n\n    The new keyword argument interface and `excluded` argument support\n    further degrades performance.\n\n    References\n    ----------\n    .. [1] NumPy Reference, section `Generalized Universal Function API\n           <https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html>`_.\n\n    Examples\n    --------\n    >>> def myfunc(a, b):\n    ...     \"Return a-b if a>b, otherwise return a+b\"\n    ...     if a > b:\n    ...         return a - b\n    ...     else:\n    ...         return a + b\n\n    >>> vfunc = np.vectorize(myfunc)\n    >>> vfunc([1, 2, 3, 4], 2)\n    array([3, 4, 1, 2])\n\n    The docstring is taken from the input function to `vectorize` unless it\n    is specified:\n\n    >>> vfunc.__doc__\n    'Return a-b if a>b, otherwise return a+b'\n    >>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n    >>> vfunc.__doc__\n    'Vectorized `myfunc`'\n\n    The output type is determined by evaluating the first element of the input,\n    unless it is specified:\n\n    >>> out = vfunc([1, 2, 3, 4], 2)\n    >>> type(out[0])\n    <class 'numpy.int64'>\n    >>> vfunc = np.vectorize(myfunc, otypes=[float])\n    >>> out = vfunc([1, 2, 3, 4], 2)\n    >>> type(out[0])\n    <class 'numpy.float64'>\n\n    The `excluded` argument can be used to prevent vectorizing over certain\n    arguments.  This can be useful for array-like arguments of a fixed length\n    such as the coefficients for a polynomial as in `polyval`:\n\n    >>> def mypolyval(p, x):\n    ...     _p = list(p)\n    ...     res = _p.pop(0)\n    ...     while _p:\n    ...         res = res*x + _p.pop(0)\n    ...     return res\n    >>> vpolyval = np.vectorize(mypolyval, excluded=['p'])\n    >>> vpolyval(p=[1, 2, 3], x=[0, 1])\n    array([3, 6])\n\n    Positional arguments may also be excluded by specifying their position:\n\n    >>> vpolyval.excluded.add(0)\n    >>> vpolyval([1, 2, 3], x=[0, 1])\n    array([3, 6])\n\n    The `signature` argument allows for vectorizing functions that act on\n    non-scalar arrays of fixed length. For example, you can use it for a\n    vectorized calculation of Pearson correlation coefficient and its p-value:\n\n    >>> import scipy.stats\n    >>> pearsonr = np.vectorize(scipy.stats.pearsonr,\n    ...                 signature='(n),(n)->(),()')\n    >>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n    (array([ 1., -1.]), array([ 0.,  0.]))\n\n    Or for a vectorized convolution:\n\n    >>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')\n    >>> convolve(np.eye(4), [1, 2, 1])\n    array([[1., 2., 1., 0., 0., 0.],\n           [0., 1., 2., 1., 0., 0.],\n           [0., 0., 1., 2., 1., 0.],\n           [0., 0., 0., 1., 2., 1.]])\n\n    ","^0","^0"],["^ ","^7","radians","^8","radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from degrees to radians.\n\nParameters\n----------\nx : array_like\n    Input array in degrees.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding radian values.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\ndeg2rad : equivalent function\n\nExamples\n--------\nConvert a degree array to radians\n\n>>> deg = np.arange(12.) * 30.\n>>> np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])\n\n>>> out = np.zeros((deg.shape))\n>>> ret = np.radians(deg, out)\n>>> ret is out\nTrue","^0","^;"],["^ ","^7","histogram","^8","\n    Compute the histogram of a set of data.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data. The histogram is computed over the flattened array.\n    bins : int or sequence of scalars or str, optional\n        If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a\n        sequence, it defines a monotonically increasing array of bin edges,\n        including the rightmost edge, allowing for non-uniform bin widths.\n\n        .. versionadded:: 1.11.0\n\n        If `bins` is a string, it defines the method used to calculate the\n        optimal bin width, as defined by `histogram_bin_edges`.\n\n    range : (float, float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored. The first element of the range must be less than or\n        equal to the second. `range` affects the automatic bin\n        computation as well. While bin width is computed to be optimal\n        based on the actual data within `range`, the bin count will fill\n        the entire range including portions containing no data.\n    normed : bool, optional\n\n        .. deprecated:: 1.6.0\n\n        This is equivalent to the `density` argument, but produces incorrect\n        results for unequal bin widths. It should not be used.\n\n        .. versionchanged:: 1.15.0\n            DeprecationWarnings are actually emitted.\n\n    weights : array_like, optional\n        An array of weights, of the same shape as `a`.  Each value in\n        `a` only contributes its associated weight towards the bin count\n        (instead of 1). If `density` is True, the weights are\n        normalized, so that the integral of the density over the range\n        remains 1.\n    density : bool, optional\n        If ``False``, the result will contain the number of samples in\n        each bin. If ``True``, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that the sum of the\n        histogram values will not be equal to 1 unless bins of unity\n        width are chosen; it is not a probability *mass* function.\n\n        Overrides the ``normed`` keyword if given.\n\n    Returns\n    -------\n    hist : array\n        The values of the histogram. See `density` and `weights` for a\n        description of the possible semantics.\n    bin_edges : array of dtype float\n        Return the bin edges ``(length(hist)+1)``.\n\n\n    See Also\n    --------\n    histogramdd, bincount, searchsorted, digitize, histogram_bin_edges\n\n    Notes\n    -----\n    All but the last (righthand-most) bin is half-open.  In other words,\n    if `bins` is::\n\n      [1, 2, 3, 4]\n\n    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and\n    the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which\n    *includes* 4.\n\n\n    Examples\n    --------\n    >>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n    (array([0, 2, 1]), array([0, 1, 2, 3]))\n    >>> np.histogram(np.arange(4), bins=np.arange(5), density=True)\n    (array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))\n    >>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n    (array([1, 4, 1]), array([0, 1, 2, 3]))\n\n    >>> a = np.arange(5)\n    >>> hist, bin_edges = np.histogram(a, density=True)\n    >>> hist\n    array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])\n    >>> hist.sum()\n    2.4999999999999996\n    >>> np.sum(hist * np.diff(bin_edges))\n    1.0\n\n    .. versionadded:: 1.11.0\n\n    Automated Bin Selection Methods example, using 2 peak random data\n    with 2000 points:\n\n    >>> import matplotlib.pyplot as plt\n    >>> rng = np.random.RandomState(10)  # deterministic random data\n    >>> a = np.hstack((rng.normal(size=1000),\n    ...                rng.normal(loc=5, scale=2, size=1000)))\n    >>> _ = plt.hist(a, bins='auto')  # arguments are passed to np.histogram\n    >>> plt.title(\"Histogram with 'auto' bins\")\n    Text(0.5, 1.0, \"Histogram with 'auto' bins\")\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^8","","^0","^="],["^ ","^7","isfortran","^8","\n    Check if the array is Fortran contiguous but *not* C contiguous.\n\n    This function is obsolete and, because of changes due to relaxed stride\n    checking, its return value for the same array may differ for versions\n    of NumPy >= 1.10.0 and previous versions. If you only want to check if an\n    array is Fortran contiguous use ``a.flags.f_contiguous`` instead.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    isfortran : bool\n        Returns True if the array is Fortran contiguous but *not* C contiguous.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.\n\n    >>> np.isfortran(np.array([1, 2], order='F'))\n    False\n\n    ","^0","^9"],["^ ","^7","float16","^8","Half-precision floating-point number type.\n    Character code: ``'e'``.\n    Canonical name: ``np.half``.\n    Alias *on this platform*: ``np.float16``: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.","^0","^0"],["^ ","^7","searchsorted","^8","\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the\n    corresponding elements in `v` were inserted before the indices, the\n    order of `a` would be preserved.\n\n    Assuming that `a` is sorted:\n\n    ======  ============================\n    `side`  returned index `i` satisfies\n    ======  ============================\n    left    ``a[i-1] < v <= a[i]``\n    right   ``a[i-1] <= v < a[i]``\n    ======  ============================\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array. If `sorter` is None, then it must be sorted in\n        ascending order, otherwise `sorter` must be an array of indices\n        that sort it.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort array a into ascending\n        order. They are typically the result of argsort.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `v`.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    This function uses the same algorithm as the builtin python `bisect.bisect_left`\n    (``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,\n    which is also vectorized in the `v` argument.\n\n    Examples\n    --------\n    >>> np.searchsorted([1,2,3,4,5], 3)\n    2\n    >>> np.searchsorted([1,2,3,4,5], 3, side='right')\n    3\n    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\n    array([0, 5, 1, 2])\n\n    ","^0","^9"],["^ ","^7","fromiter","^8","fromiter(iterable, dtype, count=-1)\n\n    Create a new 1-dimensional array from an iterable object.\n\n    Parameters\n    ----------\n    iterable : iterable object\n        An iterable object providing data for the array.\n    dtype : data-type\n        The data-type of the returned array.\n    count : int, optional\n        The number of items to read from *iterable*.  The default is -1,\n        which means all data is read.\n\n    Returns\n    -------\n    out : ndarray\n        The output array.\n\n    Notes\n    -----\n    Specify `count` to improve performance.  It allows ``fromiter`` to\n    pre-allocate the output array, instead of resizing it on demand.\n\n    Examples\n    --------\n    >>> iterable = (x*x for x in range(5))\n    >>> np.fromiter(iterable, float)\n    array([  0.,   1.,   4.,   9.,  16.])","^0","^?"],["^ ","^7","character","^8","Abstract base class of all character string scalar types.","^0","^0"],["^ ","^7","uint64","^8","Unsigned integer type, compatible with C ``unsigned long``.\n    Character code: ``'L'``.\n    Canonical name: ``np.uint``.\n    Alias *on this platform*: ``np.uint64``: 64-bit unsigned integer (0 to 18446744073709551615).\n    Alias *on this platform*: ``np.uintp``: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.","^0","^0"],["^ ","^7","full","^8","\n    Return a new array of given shape and type, filled with `fill_value`.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    fill_value : scalar\n        Fill value.\n    dtype : data-type, optional\n        The desired data-type for the array  The default, None, means\n         `np.array(fill_value).dtype`.\n    order : {'C', 'F'}, optional\n        Whether to store multidimensional data in C- or Fortran-contiguous\n        (row- or column-wise) order in memory.\n\n    Returns\n    -------\n    out : ndarray\n        Array of `fill_value` with the given shape, dtype, and order.\n\n    See Also\n    --------\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n\n    Examples\n    --------\n    >>> np.full((2, 2), np.inf)\n    array([[inf, inf],\n           [inf, inf]])\n    >>> np.full((2, 2), 10)\n    array([[10, 10],\n           [10, 10]])\n\n    ","^0","^9"],["^ ","^7","extract","^8","\n    Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Note that `place` does the exact opposite of `extract`.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    Returns\n    -------\n    extract : ndarray\n        Rank 1 array of values from `arr` where `condition` is True.\n\n    See Also\n    --------\n    take, put, copyto, compress, place\n\n    Examples\n    --------\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]])\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n\n    ","^0","^9"],["^ ","^7","unravel_index","^8","\n    unravel_index(indices, shape, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.\n\n    Parameters\n    ----------\n    indices : array_like\n        An integer array whose elements are indices into the flattened\n        version of an array of dimensions ``shape``. Before version 1.6.0,\n        this function accepted just one index value.\n    shape : tuple of ints\n        The shape of the array to use for unraveling ``indices``.\n\n        .. versionchanged:: 1.16.0\n            Renamed from ``dims`` to ``shape``.\n\n    order : {'C', 'F'}, optional\n        Determines whether the indices should be viewed as indexing in\n        row-major (C-style) or column-major (Fortran-style) order.\n\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    unraveled_coords : tuple of ndarray\n        Each array in the tuple has the same shape as the ``indices``\n        array.\n\n    See Also\n    --------\n    ravel_multi_index\n\n    Examples\n    --------\n    >>> np.unravel_index([22, 41, 37], (7,6))\n    (array([3, 6, 6]), array([4, 5, 1]))\n    >>> np.unravel_index([31, 41, 13], (7,6), order='F')\n    (array([3, 6, 6]), array([4, 5, 1]))\n\n    >>> np.unravel_index(1621, (6,7,8,9))\n    (3, 1, 4, 1)\n\n    ","^0","^9"],["^ ","^7","bool","^8","bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.","^0","^0"],["^ ","^7","blackman","^8","\n    Return the Blackman window.\n\n    The Blackman window is a taper formed by using the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, with the maximum value normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Blackman window is defined as\n\n    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\n    Most references to the Blackman window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function. It is known as a\n    \"near optimal\" tapering function, almost as good (by some measures)\n    as the kaiser window.\n\n    References\n    ----------\n    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\n    Dover Publications, New York.\n\n    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\n    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> np.blackman(12)\n    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n    Plot the window and the frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> window = np.blackman(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Blackman window\")\n    Text(0.5, 1.0, 'Blackman window')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"Sample\")\n    Text(0.5, 0, 'Sample')\n    >>> plt.show()\n\n    >>> plt.figure()\n    <Figure size 640x480 with 0 Axes>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> with np.errstate(divide='ignore', invalid='ignore'):\n    ...     response = 20 * np.log10(mag)\n    ...\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Blackman window\")\n    Text(0.5, 1.0, 'Frequency response of Blackman window')\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    Text(0, 0.5, 'Magnitude [dB]')\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    Text(0.5, 0, 'Normalized frequency [cycles per sample]')\n    >>> _ = plt.axis('tight')\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","numpy.core.defchararray","^8","\nThis module contains a set of functions for vectorized string\noperations and methods.\n\n.. note::\n   The `chararray` class exists for backwards compatibility with\n   Numarray, it is not recommended for new development. Starting from numpy\n   1.4, if one needs arrays of strings, it is recommended to use arrays of\n   `dtype` `object_`, `string_` or `unicode_`, and use the free functions\n   in the `numpy.char` module for fast vectorized string operations.\n\nSome methods will only be available if the corresponding string method is\navailable in your version of Python.\n\nThe preferred alias for `defchararray` is `numpy.char`.\n\n","^0","^>"],["^ ","^7","tile","^8","\n    Construct an array by repeating A the number of times given by reps.\n\n    If `reps` has length ``d``, the result will have dimension of\n    ``max(d, A.ndim)``.\n\n    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\n    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\n    or shape (1, 1, 3) for 3-D replication. If this is not the desired\n    behavior, promote `A` to d-dimensions manually before calling this\n    function.\n\n    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.\n    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n    (1, 1, 2, 2).\n\n    Note : Although tile may be used for broadcasting, it is strongly\n    recommended to use numpy's broadcasting operations and functions.\n\n    Parameters\n    ----------\n    A : array_like\n        The input array.\n    reps : array_like\n        The number of repetitions of `A` along each axis.\n\n    Returns\n    -------\n    c : ndarray\n        The tiled output array.\n\n    See Also\n    --------\n    repeat : Repeat elements of an array.\n    broadcast_to : Broadcast an array to a new shape\n\n    Examples\n    --------\n    >>> a = np.array([0, 1, 2])\n    >>> np.tile(a, 2)\n    array([0, 1, 2, 0, 1, 2])\n    >>> np.tile(a, (2, 2))\n    array([[0, 1, 2, 0, 1, 2],\n           [0, 1, 2, 0, 1, 2]])\n    >>> np.tile(a, (2, 1, 2))\n    array([[[0, 1, 2, 0, 1, 2]],\n           [[0, 1, 2, 0, 1, 2]]])\n\n    >>> b = np.array([[1, 2], [3, 4]])\n    >>> np.tile(b, 2)\n    array([[1, 2, 1, 2],\n           [3, 4, 3, 4]])\n    >>> np.tile(b, (2, 1))\n    array([[1, 2],\n           [3, 4],\n           [1, 2],\n           [3, 4]])\n\n    >>> c = np.array([1,2,3,4])\n    >>> np.tile(c,(4,1))\n    array([[1, 2, 3, 4],\n           [1, 2, 3, 4],\n           [1, 2, 3, 4],\n           [1, 2, 3, 4]])\n    ","^0","^9"],["^ ","^7","broadcast","^8","Produce an object that mimics broadcasting.\n\n    Parameters\n    ----------\n    in1, in2, ... : array_like\n        Input parameters.\n\n    Returns\n    -------\n    b : broadcast object\n        Broadcast the input parameters against one another, and\n        return an object that encapsulates the result.\n        Amongst others, it has ``shape`` and ``nd`` properties, and\n        may be used as an iterator.\n\n    See Also\n    --------\n    broadcast_arrays\n    broadcast_to\n\n    Examples\n    --------\n\n    Manually adding two vectors, using broadcasting:\n\n    >>> x = np.array([[1], [2], [3]])\n    >>> y = np.array([4, 5, 6])\n    >>> b = np.broadcast(x, y)\n\n    >>> out = np.empty(b.shape)\n    >>> out.flat = [u+v for (u,v) in b]\n    >>> out\n    array([[5.,  6.,  7.],\n           [6.,  7.,  8.],\n           [7.,  8.,  9.]])\n\n    Compare against built-in broadcasting:\n\n    >>> x + y\n    array([[5, 6, 7],\n           [6, 7, 8],\n           [7, 8, 9]])","^0","^0"],["^ ","^7","half","^8","Half-precision floating-point number type.\n    Character code: ``'e'``.\n    Canonical name: ``np.half``.\n    Alias *on this platform*: ``np.float16``: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.","^0","^0"],["^ ","^7","setdiff1d","^8","\n    Find the set difference of two arrays.\n\n    Return the unique values in `ar1` that are not in `ar2`.\n\n    Parameters\n    ----------\n    ar1 : array_like\n        Input array.\n    ar2 : array_like\n        Input comparison array.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    setdiff1d : ndarray\n        1D array of values in `ar1` that are not in `ar2`. The result\n        is sorted when `assume_unique=False`, but otherwise only sorted\n        if the input is sorted.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4, 1])\n    >>> b = np.array([3, 4, 5, 6])\n    >>> np.setdiff1d(a, b)\n    array([1, 2])\n\n    ","^0","^9"],["^ ","^7","npv","^8","\n    Returns the NPV (Net Present Value) of a cash flow series.\n\n    .. deprecated:: 1.18\n\n       `npv` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Parameters\n    ----------\n    rate : scalar\n        The discount rate.\n    values : array_like, shape(M, )\n        The values of the time series of cash flows.  The (fixed) time\n        interval between cash flow \"events\" must be the same as that for\n        which `rate` is given (i.e., if `rate` is per year, then precisely\n        a year is understood to elapse between each cash flow event).  By\n        convention, investments or \"deposits\" are negative, income or\n        \"withdrawals\" are positive; `values` must begin with the initial\n        investment, thus `values[0]` will typically be negative.\n\n    Returns\n    -------\n    out : float\n        The NPV of the input cash flow series `values` at the discount\n        `rate`.\n\n    Warnings\n    --------\n    ``npv`` considers a series of cashflows starting in the present (t = 0).\n    NPV can also be defined with a series of future cashflows, paid at the\n    end, rather than the start, of each period. If future cashflows are used,\n    the first cashflow `values[0]` must be zeroed and added to the net\n    present value of the future cashflows. This is demonstrated in the\n    examples.\n\n    Notes\n    -----\n    Returns the result of: [2]_\n\n    .. math :: \\sum_{t=0}^{M-1}{\\frac{values_t}{(1+rate)^{t}}}\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    .. [2] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 346.\n\n    Examples\n    --------\n    Consider a potential project with an initial investment of $40 000 and\n    projected cashflows of $5 000, $8 000, $12 000 and $30 000 at the end of\n    each period discounted at a rate of 8% per period. To find the project's\n    net present value:\n\n    >>> rate, cashflows = 0.08, [-40_000, 5_000, 8_000, 12_000, 30_000]\n    >>> np.npv(rate, cashflows).round(5)\n    3065.22267\n\n    It may be preferable to split the projected cashflow into an initial\n    investment and expected future cashflows. In this case, the value of\n    the initial cashflow is zero and the initial investment is later added\n    to the future cashflows net present value:\n\n    >>> initial_cashflow = cashflows[0]\n    >>> cashflows[0] = 0\n    >>> np.round(np.npv(rate, cashflows) + initial_cashflow, 5)\n    3065.22267\n\n    ","^0","^9"],["^ ","^7","remainder","^8","remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor\n\nNotes\n-----\nReturns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\nintegers.\n``mod`` is an alias of ``remainder``.\n\nExamples\n--------\n>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])","^0","^;"],["^ ","^8","","^0","^<"],["^ ","^7","exp","^8","exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the exponential of all elements in the input array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise exponential of `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nexpm1 : Calculate ``exp(x) - 1`` for all elements in the array.\nexp2  : Calculate ``2**x`` for all elements in the array.\n\nNotes\n-----\nThe irrational number ``e`` is also known as Euler's number.  It is\napproximately 2.718281, and is the base of the natural logarithm,\n``ln`` (this means that, if :math:`x = \\ln y = \\log_e y`,\nthen :math:`e^x = y`. For real input, ``exp(x)`` is always positive.\n\nFor complex arguments, ``x = a + ib``, we can write\n:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already\nknown (it is the real argument, described above).  The second term,\n:math:`e^{ib}`, is :math:`\\cos b + i \\sin b`, a function with\nmagnitude 1 and a periodic phase.\n\nReferences\n----------\n.. [1] Wikipedia, \"Exponential function\",\n       https://en.wikipedia.org/wiki/Exponential_function\n.. [2] M. Abramovitz and I. A. Stegun, \"Handbook of Mathematical Functions\n       with Formulas, Graphs, and Mathematical Tables,\" Dover, 1964, p. 69,\n       http://www.math.sfu.ca/~cbm/aands/page_69.htm\n\nExamples\n--------\nPlot the magnitude and phase of ``exp(x)`` in the complex plane:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)\n>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n>>> out = np.exp(xx)\n\n>>> plt.subplot(121)\n>>> plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')\n>>> plt.title('Magnitude of exp(x)')\n\n>>> plt.subplot(122)\n>>> plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')\n>>> plt.title('Phase (angle) of exp(x)')\n>>> plt.show()","^0","^;"],["^ ","^7","outer","^8","\n    Compute the outer product of two vectors.\n\n    Given two vectors, ``a = [a0, a1, ..., aM]`` and\n    ``b = [b0, b1, ..., bN]``,\n    the outer product [1]_ is::\n\n      [[a0*b0  a0*b1 ... a0*bN ]\n       [a1*b0    .\n       [ ...          .\n       [aM*b0            aM*bN ]]\n\n    Parameters\n    ----------\n    a : (M,) array_like\n        First input vector.  Input is flattened if\n        not already 1-dimensional.\n    b : (N,) array_like\n        Second input vector.  Input is flattened if\n        not already 1-dimensional.\n    out : (M, N) ndarray, optional\n        A location where the result is stored\n\n        .. versionadded:: 1.9.0\n\n    Returns\n    -------\n    out : (M, N) ndarray\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner\n    einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\n    ufunc.outer : A generalization to N dimensions and other operations.\n                  ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.\n\n    References\n    ----------\n    .. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n             ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n             pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n           [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n           [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n           [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n           [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.outer(x, [1, 2, 3])\n    array([['a', 'aa', 'aaa'],\n           ['b', 'bb', 'bbb'],\n           ['c', 'cc', 'ccc']], dtype=object)\n\n    ","^0","^9"],["^ ","^7","uint8","^8","Unsigned integer type, compatible with C ``unsigned char``.\n    Character code: ``'B'``.\n    Canonical name: ``np.ubyte``.\n    Alias *on this platform*: ``np.uint8``: 8-bit unsigned integer (0 to 255).","^0","^0"],["^ ","^7","atleast_2d","^8","\n    View inputs as arrays with at least two dimensions.\n\n    Parameters\n    ----------\n    arys1, arys2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted\n        to arrays.  Arrays that already have two or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res, res2, ... : ndarray\n        An array, or list of arrays, each with ``a.ndim >= 2``.\n        Copies are avoided where possible, and views with two or more\n        dimensions are returned.\n\n    See Also\n    --------\n    atleast_1d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_2d(3.0)\n    array([[3.]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_2d(x)\n    array([[0., 1., 2.]])\n    >>> np.atleast_2d(x).base is x\n    True\n\n    >>> np.atleast_2d(1, [1, 2], [[1, 2]])\n    [array([[1]]), array([[1, 2]]), array([[1, 2]])]\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","lexsort","^8","\n    lexsort(keys, axis=-1)\n\n    Perform an indirect stable sort using a sequence of keys.\n\n    Given multiple sorting keys, which can be interpreted as columns in a\n    spreadsheet, lexsort returns an array of integer indices that describes\n    the sort order by multiple columns. The last key in the sequence is used\n    for the primary sort order, the second-to-last key for the secondary sort\n    order, and so on. The keys argument must be a sequence of objects that\n    can be converted to arrays of the same shape. If a 2D array is provided\n    for the keys argument, it's rows are interpreted as the sorting keys and\n    sorting is according to the last row, second last row etc.\n\n    Parameters\n    ----------\n    keys : (k, N) array or tuple containing k (N,)-shaped sequences\n        The `k` different \"columns\" to be sorted.  The last column (or row if\n        `keys` is a 2D array) is the primary sort key.\n    axis : int, optional\n        Axis to be indirectly sorted.  By default, sort over the last axis.\n\n    Returns\n    -------\n    indices : (N,) ndarray of ints\n        Array of indices that sort the keys along the specified axis.\n\n    See Also\n    --------\n    argsort : Indirect sort.\n    ndarray.sort : In-place sort.\n    sort : Return a sorted copy of an array.\n\n    Examples\n    --------\n    Sort names: first by surname, then by name.\n\n    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n    >>> ind = np.lexsort((first_names, surnames))\n    >>> ind\n    array([1, 2, 0])\n\n    >>> [surnames[i] + \", \" + first_names[i] for i in ind]\n    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n    Sort two columns of numbers:\n\n    >>> a = [1,5,1,4,3,4,4] # First column\n    >>> b = [9,4,0,4,0,2,1] # Second column\n    >>> ind = np.lexsort((b,a)) # Sort by a, then by b\n    >>> ind\n    array([2, 0, 4, 6, 5, 3, 1])\n\n    >>> [(a[i],b[i]) for i in ind]\n    [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]\n\n    Note that sorting is first according to the elements of ``a``.\n    Secondary sorting is according to the elements of ``b``.\n\n    A normal ``argsort`` would have yielded:\n\n    >>> [(a[i],b[i]) for i in np.argsort(a)]\n    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n    Structured arrays are sorted lexically by ``argsort``:\n\n    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n    ...              dtype=np.dtype([('x', int), ('y', int)]))\n\n    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))\n    array([2, 0, 4, 6, 5, 3, 1])\n\n    ","^0","^9"],["^ ","^7","subtract","^8","subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nSubtract arguments, element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays to be subtracted from each other. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The difference of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nEquivalent to ``x1 - x2`` in terms of array broadcasting.\n\nExamples\n--------\n>>> np.subtract(1.0, 4.0)\n-3.0\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n       [ 3.,  3.,  3.],\n       [ 6.,  6.,  6.]])","^0","^;"],["^ ","^8","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^0","^@"],["^ ","^8","","^0","^<"],["^ ","^7","isreal","^8","\n    Returns a bool array, where True if input element is real.\n\n    If element has complex type with zero complex part, the return value\n    for that element is True.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray, bool\n        Boolean array of same shape as `x`.\n\n    See Also\n    --------\n    iscomplex\n    isrealobj : Return True if x is not a complex type.\n\n    Examples\n    --------\n    >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([False,  True,  True,  True,  True, False])\n\n    ","^0","^9"],["^ ","^7","asscalar","^8","\n    Convert an array of size 1 to its scalar equivalent.\n\n    .. deprecated:: 1.16\n\n        Deprecated, use `numpy.ndarray.item()` instead.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array of size 1.\n\n    Returns\n    -------\n    out : scalar\n        Scalar representation of `a`. The output data type is the same type\n        returned by the input's `item` method.\n\n    Examples\n    --------\n    >>> np.asscalar(np.array([24]))\n    24\n    ","^0","^9"],["^ ","^7","select","^8","\n    Return an array drawn from elements in choicelist, depending on conditions.\n\n    Parameters\n    ----------\n    condlist : list of bool ndarrays\n        The list of conditions which determine from which array in `choicelist`\n        the output elements are taken. When multiple conditions are satisfied,\n        the first one encountered in `condlist` is used.\n    choicelist : list of ndarrays\n        The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`.\n    default : scalar, optional\n        The element inserted in `output` when all conditions evaluate to False.\n\n    Returns\n    -------\n    output : ndarray\n        The output at position m is the m-th element of the array in\n        `choicelist` where the m-th element of the corresponding array in\n        `condlist` is True.\n\n    See Also\n    --------\n    where : Return elements from one of two arrays depending on condition.\n    take, choose, compress, diag, diagonal\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> condlist = [x<3, x>5]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist)\n    array([ 0,  1,  2, ..., 49, 64, 81])\n\n    ","^0","^9"],["^ ","^7","identity","^8","\n    Return the identity array.\n\n    The identity array is a square array with ones on\n    the main diagonal.\n\n    Parameters\n    ----------\n    n : int\n        Number of rows (and columns) in `n` x `n` output.\n    dtype : data-type, optional\n        Data-type of the output.  Defaults to ``float``.\n\n    Returns\n    -------\n    out : ndarray\n        `n` x `n` array with its main diagonal set to one,\n        and all other elements 0.\n\n    Examples\n    --------\n    >>> np.identity(3)\n    array([[1.,  0.,  0.],\n           [0.,  1.,  0.],\n           [0.,  0.,  1.]])\n\n    ","^0","^9"],["^ ","^7","geterr","^8","\n    Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> from collections import OrderedDict\n    >>> sorted(np.geterr().items())\n    [('divide', 'warn'), ('invalid', 'warn'), ('over', 'warn'), ('under', 'ignore')]\n    >>> np.arange(3.) / np.arange(3.)\n    array([nan,  1.,  1.])\n\n    >>> oldsettings = np.seterr(all='warn', over='raise')\n    >>> OrderedDict(sorted(np.geterr().items()))\n    OrderedDict([('divide', 'warn'), ('invalid', 'warn'), ('over', 'raise'), ('under', 'warn')])\n    >>> np.arange(3.) / np.arange(3.)\n    array([nan,  1.,  1.])\n\n    ","^0","^9"],["^ ","^7","eye","^8","\n    Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\n    Parameters\n    ----------\n    N : int\n      Number of rows in the output.\n    M : int, optional\n      Number of columns in the output. If None, defaults to `N`.\n    k : int, optional\n      Index of the diagonal: 0 (the default) refers to the main diagonal,\n      a positive value refers to an upper diagonal, and a negative value\n      to a lower diagonal.\n    dtype : data-type, optional\n      Data-type of the returned array.\n    order : {'C', 'F'}, optional\n        Whether the output should be stored in row-major (C-style) or\n        column-major (Fortran-style) order in memory.\n\n        .. versionadded:: 1.14.0\n\n    Returns\n    -------\n    I : ndarray of shape (N,M)\n      An array where all elements are equal to zero, except for the `k`-th\n      diagonal, whose values are equal to one.\n\n    See Also\n    --------\n    identity : (almost) equivalent function\n    diag : diagonal 2-D array from a 1-D array specified by the user.\n\n    Examples\n    --------\n    >>> np.eye(2, dtype=int)\n    array([[1, 0],\n           [0, 1]])\n    >>> np.eye(3, k=1)\n    array([[0.,  1.,  0.],\n           [0.,  0.,  1.],\n           [0.,  0.,  0.]])\n\n    ","^0","^9"],["^ ","^7","heaviside","^8","heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the Heaviside step function.\n\nThe Heaviside step function is defined as::\n\n                          0   if x1 < 0\n    heaviside(x1, x2) =  x2   if x1 == 0\n                          1   if x1 > 0\n\nwhere `x2` is often taken to be 0.5, but 0 and 1 are also sometimes used.\n\nParameters\n----------\nx1 : array_like\n    Input values.\nx2 : array_like\n    The value of the function when x1 is 0. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The output array, element-wise Heaviside step function of `x1`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\n.. versionadded:: 1.13.0\n\nReferences\n----------\n.. Wikipedia, \"Heaviside step function\",\n   https://en.wikipedia.org/wiki/Heaviside_step_function\n\nExamples\n--------\n>>> np.heaviside([-1.5, 0, 2.0], 0.5)\narray([ 0. ,  0.5,  1. ])\n>>> np.heaviside([-1.5, 0, 2.0], 1)\narray([ 0.,  1.,  1.])","^0","^;"],["^ ","^7","busday_offset","^8","\n    busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)\n\n    First adjusts the date to fall on a valid day according to\n    the ``roll`` rule, then applies offsets to the given dates\n    counted in valid days.\n\n    .. versionadded:: 1.7.0\n\n    Parameters\n    ----------\n    dates : array_like of datetime64[D]\n        The array of dates to process.\n    offsets : array_like of int\n        The array of offsets, which is broadcast with ``dates``.\n    roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional\n        How to treat dates that do not fall on a valid day. The default\n        is 'raise'.\n\n          * 'raise' means to raise an exception for an invalid day.\n          * 'nat' means to return a NaT (not-a-time) for an invalid day.\n          * 'forward' and 'following' mean to take the first valid day\n            later in time.\n          * 'backward' and 'preceding' mean to take the first valid day\n            earlier in time.\n          * 'modifiedfollowing' means to take the first valid day\n            later in time unless it is across a Month boundary, in which\n            case to take the first valid day earlier in time.\n          * 'modifiedpreceding' means to take the first valid day\n            earlier in time unless it is across a Month boundary, in which\n            case to take the first valid day later in time.\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates.  They may be\n        specified in any order, and NaT (not-a-time) dates are ignored.\n        This list is saved in a normalized form that is suited for\n        fast calculations of valid days.\n    busdaycal : busdaycalendar, optional\n        A `busdaycalendar` object which specifies the valid days. If this\n        parameter is provided, neither weekmask nor holidays may be\n        provided.\n    out : array of datetime64[D], optional\n        If provided, this array is filled with the result.\n\n    Returns\n    -------\n    out : array of datetime64[D]\n        An array with a shape from broadcasting ``dates`` and ``offsets``\n        together, containing the dates with offsets applied.\n\n    See Also\n    --------\n    busdaycalendar: An object that specifies a custom set of valid days.\n    is_busday : Returns a boolean array indicating valid days.\n    busday_count : Counts how many valid days are in a half-open date range.\n\n    Examples\n    --------\n    >>> # First business day in October 2011 (not accounting for holidays)\n    ... np.busday_offset('2011-10', 0, roll='forward')\n    numpy.datetime64('2011-10-03')\n    >>> # Last business day in February 2012 (not accounting for holidays)\n    ... np.busday_offset('2012-03', -1, roll='forward')\n    numpy.datetime64('2012-02-29')\n    >>> # Third Wednesday in January 2011\n    ... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\n    numpy.datetime64('2011-01-19')\n    >>> # 2012 Mother's Day in Canada and the U.S.\n    ... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\n    numpy.datetime64('2012-05-13')\n\n    >>> # First business day on or after a date\n    ... np.busday_offset('2011-03-20', 0, roll='forward')\n    numpy.datetime64('2011-03-21')\n    >>> np.busday_offset('2011-03-22', 0, roll='forward')\n    numpy.datetime64('2011-03-22')\n    >>> # First business day after a date\n    ... np.busday_offset('2011-03-20', 1, roll='backward')\n    numpy.datetime64('2011-03-21')\n    >>> np.busday_offset('2011-03-22', 1, roll='backward')\n    numpy.datetime64('2011-03-23')\n    ","^0","^9"],["^ ","^7","greater_equal","^8","greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 >= x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : bool or ndarray of bool\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngreater, less, less_equal, equal, not_equal\n\nExamples\n--------\n>>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])","^0","^;"],["^ ","^8","","^0","^<"],["^ ","^7","ulonglong","^8","Signed integer type, compatible with C ``unsigned long long``.\n    Character code: ``'Q'``.","^0","^0"],["^ ","^8","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^0","^@"],["^ ","^7","split","^8","\n    Split an array into multiple sub-arrays as views into `ary`.\n\n    Parameters\n    ----------\n    ary : ndarray\n        Array to be divided into sub-arrays.\n    indices_or_sections : int or 1-D array\n        If `indices_or_sections` is an integer, N, the array will be divided\n        into N equal arrays along `axis`.  If such a split is not possible,\n        an error is raised.\n\n        If `indices_or_sections` is a 1-D array of sorted integers, the entries\n        indicate where along `axis` the array is split.  For example,\n        ``[2, 3]`` would, for ``axis=0``, result in\n\n          - ary[:2]\n          - ary[2:3]\n          - ary[3:]\n\n        If an index exceeds the dimension of the array along `axis`,\n        an empty sub-array is returned correspondingly.\n    axis : int, optional\n        The axis along which to split, default is 0.\n\n    Returns\n    -------\n    sub-arrays : list of ndarrays\n        A list of sub-arrays as views into `ary`.\n\n    Raises\n    ------\n    ValueError\n        If `indices_or_sections` is given as an integer, but\n        a split does not result in equal division.\n\n    See Also\n    --------\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.  Does not raise an exception if\n                  an equal division cannot be made.\n    hsplit : Split array into multiple sub-arrays horizontally (column-wise).\n    vsplit : Split array into multiple sub-arrays vertically (row wise).\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    concatenate : Join a sequence of arrays along an existing axis.\n    stack : Join a sequence of arrays along a new axis.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n\n    Examples\n    --------\n    >>> x = np.arange(9.0)\n    >>> np.split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]\n\n    >>> x = np.arange(8.0)\n    >>> np.split(x, [3, 5, 6, 10])\n    [array([0.,  1.,  2.]),\n     array([3.,  4.]),\n     array([5.]),\n     array([6.,  7.]),\n     array([], dtype=float64)]\n\n    ","^0","^9"],["^ ","^7","asfarray","^8","\n    Return an array converted to a float type.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    dtype : str or dtype object, optional\n        Float type code to coerce input array `a`.  If `dtype` is one of the\n        'int' dtypes, it is replaced with float64.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` as a float ndarray.\n\n    Examples\n    --------\n    >>> np.asfarray([2, 3])\n    array([2.,  3.])\n    >>> np.asfarray([2, 3], dtype='float')\n    array([2.,  3.])\n    >>> np.asfarray([2, 3], dtype='int8')\n    array([2.,  3.])\n\n    ","^0","^9"],["^ ","^7","recfromtxt","^8","\n    Load ASCII data from a file and return it in a record array.\n\n    If ``usemask=False`` a standard `recarray` is returned,\n    if ``usemask=True`` a MaskedRecords array is returned.\n\n    Parameters\n    ----------\n    fname, kwargs : For a description of input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function\n\n    Notes\n    -----\n    By default, `dtype` is None, which means that the data-type of the output\n    array will be determined from the data.\n\n    ","^0","^9"],["^ ","^7","empty_like","^8","\n    empty_like(prototype, dtype=None, order='K', subok=True, shape=None)\n\n    Return a new array with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    prototype : array_like\n        The shape and data-type of `prototype` define these same attributes\n        of the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n\n        .. versionadded:: 1.6.0\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran\n        contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``\n        as closely as possible.\n\n        .. versionadded:: 1.6.0\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of 'a', otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of uninitialized (arbitrary) data with the same\n        shape and type as `prototype`.\n\n    See Also\n    --------\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n\n    Notes\n    -----\n    This function does *not* initialize the returned array; to do that use\n    `zeros_like` or `ones_like` instead.  It may be marginally faster than\n    the functions that do set the array values.\n\n    Examples\n    --------\n    >>> a = ([1,2,3], [4,5,6])                         # a is array-like\n    >>> np.empty_like(a)\n    array([[-1073741821, -1073741821,           3],    # uninitialized\n           [          0,           0, -1073741821]])\n    >>> a = np.array([[1., 2., 3.],[4.,5.,6.]])\n    >>> np.empty_like(a)\n    array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n           [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n    ","^0","^9"],["^ ","^7","log10","^8","log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the base 10 logarithm of the input array, element-wise.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The logarithm to the base 10 of `x`, element-wise. NaNs are\n    returned where x is negative.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nemath.log10\n\nNotes\n-----\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `10**z = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log10` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log10` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it.\n`log10` handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm\n\nExamples\n--------\n>>> np.log10([1e-15, -3.])\narray([-15.,  nan])","^0","^;"],["^ ","^7","mask_indices","^8","\n    Return the indices to access (n, n) arrays, given a masking function.\n\n    Assume `mask_func` is a function that, for a square array a of size\n    ``(n, n)`` with a possible offset argument `k`, when called as\n    ``mask_func(a, k)`` returns a new array with zeros in certain locations\n    (functions like `triu` or `tril` do precisely this). Then this function\n    returns the indices where the non-zero values would be located.\n\n    Parameters\n    ----------\n    n : int\n        The returned indices will be valid to access arrays of shape (n, n).\n    mask_func : callable\n        A function whose call signature is similar to that of `triu`, `tril`.\n        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n        `k` is an optional argument to the function.\n    k : scalar\n        An optional argument which is passed through to `mask_func`. Functions\n        like `triu`, `tril` take a second argument that is interpreted as an\n        offset.\n\n    Returns\n    -------\n    indices : tuple of arrays.\n        The `n` arrays of indices corresponding to the locations where\n        ``mask_func(np.ones((n, n)), k)`` is True.\n\n    See Also\n    --------\n    triu, tril, triu_indices, tril_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    These are the indices that would allow you to access the upper triangular\n    part of any 3x3 array:\n\n    >>> iu = np.mask_indices(3, np.triu)\n\n    For example, if `a` is a 3x3 array:\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> a[iu]\n    array([0, 1, 2, 4, 5, 8])\n\n    An offset can be passed also to the masking function.  This gets us the\n    indices starting on the first diagonal right of the main one:\n\n    >>> iu1 = np.mask_indices(3, np.triu, 1)\n\n    with which we now extract only three elements:\n\n    >>> a[iu1]\n    array([1, 2, 5])\n\n    ","^0","^9"],["^ ","^7","str0","^8",null,"^0","^0"],["^ ","^7","number","^8","Abstract base class of all numeric scalar types.","^0","^0"],["^ ","^7","nanargmax","^8","\n    Return the indices of the maximum values in the specified axis ignoring\n    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the\n    results cannot be trusted if a slice contains only NaNs and -Infs.\n\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmax, nanargmin\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmax(a)\n    0\n    >>> np.nanargmax(a)\n    1\n    >>> np.nanargmax(a, axis=0)\n    array([1, 0])\n    >>> np.nanargmax(a, axis=1)\n    array([1, 1])\n\n    ","^0","^9"],["^ ","^7","sinc","^8","\n    Return the sinc function.\n\n    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array (possibly multi-dimensional) of values for which to to\n        calculate ``sinc(x)``.\n\n    Returns\n    -------\n    out : ndarray\n        ``sinc(x)``, which has the same shape as the input.\n\n    Notes\n    -----\n    ``sinc(0)`` is the limit value 1.\n\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a Lanczos resampling\n    filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. http://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           https://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> x = np.linspace(-4, 4, 41)\n    >>> np.sinc(x)\n     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary\n            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n            -4.92362781e-02,  -3.89804309e-17])\n\n    >>> plt.plot(x, np.sinc(x))\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Sinc Function\")\n    Text(0.5, 1.0, 'Sinc Function')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"X\")\n    Text(0.5, 0, 'X')\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","fmax","^8","fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise maximum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then the\nnon-nan element is returned. If both elements are NaNs then the first\nis returned.  The latter distinction is important for complex NaNs,\nwhich are defined as at least one of the real or imaginary parts being\na NaN. The net effect is that NaNs are ignored when possible.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The maximum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfmin :\n    Element-wise minimum of two arrays, ignores NaNs.\nmaximum :\n    Element-wise maximum of two arrays, propagates NaNs.\namax :\n    The maximum value of an array along a given axis, propagates NaNs.\nnanmax :\n    The maximum value of an array along a given axis, ignores NaNs.\n\nminimum, amin, nanmin\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nThe fmax is equivalent to ``np.where(x1 >= x2, x1, x2)`` when neither\nx1 nor x2 are NaNs, but it is faster and does proper broadcasting.\n\nExamples\n--------\n>>> np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])\n\n>>> np.fmax(np.eye(2), [0.5, 2])\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n>>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])","^0","^;"],["^ ","^7","ravel","^8","Return a contiguous flattened array.\n\n    A 1-D array, containing the elements of the input, is returned.  A copy is\n    made only if needed.\n\n    As of NumPy 1.10, the returned array will have the same type as the input\n    array. (for example, a masked array will be returned for a masked array\n    input)\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  The elements in `a` are read in the order specified by\n        `order`, and packed as a 1-D array.\n    order : {'C','F', 'A', 'K'}, optional\n\n        The elements of `a` are read using this index order. 'C' means\n        to index the elements in row-major, C-style order,\n        with the last axis index changing fastest, back to the first\n        axis index changing slowest.  'F' means to index the elements\n        in column-major, Fortran-style order, with the\n        first index changing fastest, and the last index changing\n        slowest. Note that the 'C' and 'F' options take no account of\n        the memory layout of the underlying array, and only refer to\n        the order of axis indexing.  'A' means to read the elements in\n        Fortran-like index order if `a` is Fortran *contiguous* in\n        memory, C-like order otherwise.  'K' means to read the\n        elements in the order they occur in memory, except for\n        reversing the data when strides are negative.  By default, 'C'\n        index order is used.\n\n    Returns\n    -------\n    y : array_like\n        y is an array of the same subtype as `a`, with shape ``(a.size,)``.\n        Note that matrices are special cased for backward compatibility, if `a`\n        is a matrix, then y is a 1-D ndarray.\n\n    See Also\n    --------\n    ndarray.flat : 1-D iterator over an array.\n    ndarray.flatten : 1-D array copy of the elements of an array\n                      in row-major order.\n    ndarray.reshape : Change the shape of an array without changing its data.\n\n    Notes\n    -----\n    In row-major, C-style order, in two dimensions, the row index\n    varies the slowest, and the column index the quickest.  This can\n    be generalized to multiple dimensions, where row-major order\n    implies that the index along the first axis varies slowest, and\n    the index along the last quickest.  The opposite holds for\n    column-major, Fortran-style index ordering.\n\n    When a view is desired in as many cases as possible, ``arr.reshape(-1)``\n    may be preferable.\n\n    Examples\n    --------\n    It is equivalent to ``reshape(-1, order=order)``.\n\n    >>> x = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.ravel(x)\n    array([1, 2, 3, 4, 5, 6])\n\n    >>> x.reshape(-1)\n    array([1, 2, 3, 4, 5, 6])\n\n    >>> np.ravel(x, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:\n\n    >>> np.ravel(x.T)\n    array([1, 4, 2, 5, 3, 6])\n    >>> np.ravel(x.T, order='A')\n    array([1, 2, 3, 4, 5, 6])\n\n    When ``order`` is 'K', it will preserve orderings that are neither 'C'\n    nor 'F', but won't reverse axes:\n\n    >>> a = np.arange(3)[::-1]; a\n    array([2, 1, 0])\n    >>> a.ravel(order='C')\n    array([2, 1, 0])\n    >>> a.ravel(order='K')\n    array([2, 1, 0])\n\n    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\n    array([[[ 0,  2,  4],\n            [ 1,  3,  5]],\n           [[ 6,  8, 10],\n            [ 7,  9, 11]]])\n    >>> a.ravel(order='C')\n    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n    >>> a.ravel(order='K')\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n\n    ","^0","^9"],["^ ","^7","correlate","^8","\n    Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts::\n\n        c_{av}[k] = sum_n a[n+k] * conj(v[n])\n\n    with a and v sequences being zero-padded where necessary and conj being\n    the conjugate.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is 'valid', unlike `convolve`, which uses 'full'.\n    old_behavior : bool\n        `old_behavior` was removed in NumPy 1.10. If you need the old\n        behavior, use `multiarray.correlate`.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete cross-correlation of `a` and `v`.\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n    multiarray.correlate : Old, no conjugate, version of correlate.\n\n    Notes\n    -----\n    The definition of correlation above is not unique and sometimes correlation\n    may be defined differently. Another common definition is::\n\n        c'_{av}[k] = sum_n a[n] conj(v[n+k])\n\n    which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.\n\n    Examples\n    --------\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([0.5,  2. ,  3.5,  3. ,  0. ])\n\n    Using complex sequences:\n\n    >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')\n    array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])\n\n    Note that you get the time reversed, complex conjugated result\n    when the two input sequences change places, i.e.,\n    ``c_{va}[k] = c^{*}_{av}[-k]``:\n\n    >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')\n    array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\n\n    ","^0","^9"],["^ ","^7","nanmin","^8","\n    Return minimum of an array or minimum along an axis, ignoring any NaNs.\n    When all-NaN slices are encountered a ``RuntimeWarning`` is raised and\n    Nan is returned for that slice.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose minimum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the minimum is computed. The default is to compute\n        the minimum of the flattened array.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        `ufuncs-output-type` for more details.\n\n        .. versionadded:: 1.8.0\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `min` method\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n        .. versionadded:: 1.8.0\n\n    Returns\n    -------\n    nanmin : ndarray\n        An array with the same shape as `a`, with the specified axis\n        removed.  If `a` is a 0-d array, or if axis is None, an ndarray\n        scalar is returned.  The same dtype as `a` is returned.\n\n    See Also\n    --------\n    nanmax :\n        The maximum value of an array along a given axis, ignoring any NaNs.\n    amin :\n        The minimum value of an array along a given axis, propagating any NaNs.\n    fmin :\n        Element-wise minimum of two arrays, ignoring any NaNs.\n    minimum :\n        Element-wise minimum of two arrays, propagating any NaNs.\n    isnan :\n        Shows which elements are Not a Number (NaN).\n    isfinite:\n        Shows which elements are neither NaN nor infinity.\n\n    amax, fmax, maximum\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative\n    infinity is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.min.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmin(a)\n    1.0\n    >>> np.nanmin(a, axis=0)\n    array([1.,  2.])\n    >>> np.nanmin(a, axis=1)\n    array([1.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmin([1, 2, np.nan, np.inf])\n    1.0\n    >>> np.nanmin([1, 2, np.nan, np.NINF])\n    -inf\n\n    ","^0","^9"],["^ ","^7","polyadd","^8","\n    Find the sum of two polynomials.\n\n    Returns the polynomial resulting from the sum of two input polynomials.\n    Each input must be either a poly1d object or a 1D sequence of polynomial\n    coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The sum of the inputs. If either input is a poly1d object, then the\n        output is also a poly1d object. Otherwise, it is a 1D array of\n        polynomial coefficients from highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\n    Examples\n    --------\n    >>> np.polyadd([1, 2], [9, 5, 4])\n    array([9, 6, 6])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2])\n    >>> p2 = np.poly1d([9, 5, 4])\n    >>> print(p1)\n    1 x + 2\n    >>> print(p2)\n       2\n    9 x + 5 x + 4\n    >>> print(np.polyadd(p1, p2))\n       2\n    9 x + 6 x + 6\n\n    ","^0","^9"],["^ ","^8","The specification for a module, used for loading.\n\n    A module's spec is the source for information about the module.  For\n    data associated with the module, including source, use the spec's\n    loader.\n\n    `name` is the absolute name of the module.  `loader` is the loader\n    to use when loading the module.  `parent` is the name of the\n    package the module is in.  The parent is derived from the name.\n\n    `is_package` determines if the module is considered a package or\n    not.  On modules this is reflected by the `__path__` attribute.\n\n    `origin` is the specific location used by the loader from which to\n    load the module, if that information is available.  When filename is\n    set, origin will match.\n\n    `has_location` indicates that a spec's \"origin\" reflects a location.\n    When this is True, `__file__` attribute of the module is set.\n\n    `cached` is the location of the cached bytecode file, if any.  It\n    corresponds to the `__cached__` attribute.\n\n    `submodule_search_locations` is the sequence of path entries to\n    search when importing submodules.  If set, is_package should be\n    True--and False otherwise.\n\n    Packages are simply modules that (may) have submodules.  If a spec\n    has a non-None value in `submodule_search_locations`, the import\n    system will consider modules loaded from the spec as packages.\n\n    Only finders (see importlib.abc.MetaPathFinder and\n    importlib.abc.PathEntryFinder) should modify ModuleSpec instances.\n\n    ","^0","~:module-spec"],["^ ","^8",null,"^0","^C"],["^ ","^7","arcsinh","^8","arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic sine element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\n`arcsinh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `sinh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi/2, pi/2]`.\n\nFor real-valued input data types, `arcsinh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nreturns ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccos` is a complex analytical function that\nhas branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from\nthe right on the former and from the left on the latter.\n\nThe inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\n       https://en.wikipedia.org/wiki/Arcsinh\n\nExamples\n--------\n>>> np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])","^0","^;"],["^ ","^8","\n    A nicer way to build up index tuples for arrays.\n\n    .. note::\n       Use one of the two predefined instances `index_exp` or `s_`\n       rather than directly using `IndexExpression`.\n\n    For any index combination, including slicing and axis insertion,\n    ``a[indices]`` is the same as ``a[np.index_exp[indices]]`` for any\n    array `a`. However, ``np.index_exp[indices]`` can be used anywhere\n    in Python code and returns a tuple of slice objects that can be\n    used in the construction of complex index expressions.\n\n    Parameters\n    ----------\n    maketuple : bool\n        If True, always returns a tuple.\n\n    See Also\n    --------\n    index_exp : Predefined instance that always returns a tuple:\n       `index_exp = IndexExpression(maketuple=True)`.\n    s_ : Predefined instance without tuple conversion:\n       `s_ = IndexExpression(maketuple=False)`.\n\n    Notes\n    -----\n    You can do all this with `slice()` plus a few special objects,\n    but there's a lot to remember and this version is simpler because\n    it uses the standard array indexing syntax.\n\n    Examples\n    --------\n    >>> np.s_[2::2]\n    slice(2, None, 2)\n    >>> np.index_exp[2::2]\n    (slice(2, None, 2),)\n\n    >>> np.array([0, 1, 2, 3, 4])[np.s_[2::2]]\n    array([2, 4])\n\n    ","^0","~:index-expression"],["^ ","^7","ComplexWarning","^8","\n    The warning raised when casting a complex dtype to a real dtype.\n\n    As implemented, casting a complex number to a real discards its imaginary\n    part, but this behavior may not be what the user actually wants.\n\n    ","^0","^0"],["^ ","^7","issctype","^8","\n    Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> np.issctype(np.int32)\n    True\n    >>> np.issctype(list)\n    False\n    >>> np.issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> np.issctype(np.dtype('str'))\n    True\n\n    ","^0","^9"],["^ ","^7","sqrt","^8","sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the non-negative square-root of an array, element-wise.\n\nParameters\n----------\nx : array_like\n    The values whose square-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlib.scimath.sqrt\n    A version which returns complex numbers when given negative reals.\n\nNotes\n-----\n*sqrt* has--consistent with common convention--as its branch cut the\nreal \"interval\" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.\n\nExamples\n--------\n>>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n>>> np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n>>> np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])","^0","^;"],["^ "],["^ ","^7","polymul","^8","\n    Find the product of two polynomials.\n\n    Finds the polynomial resulting from the multiplication of the two input\n    polynomials. Each input must be either a poly1d object or a 1D sequence\n    of polynomial coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The polynomial resulting from the multiplication of the inputs. If\n        either inputs is a poly1d object, then the output is also a poly1d\n        object. Otherwise, it is a 1D array of polynomial coefficients from\n        highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n    convolve : Array convolution. Same output as polymul, but has parameter\n               for overlap mode.\n\n    Examples\n    --------\n    >>> np.polymul([1, 2, 3], [9, 5, 1])\n    array([ 9, 23, 38, 17,  3])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2, 3])\n    >>> p2 = np.poly1d([9, 5, 1])\n    >>> print(p1)\n       2\n    1 x + 2 x + 3\n    >>> print(p2)\n       2\n    9 x + 5 x + 1\n    >>> print(np.polymul(p1, p2))\n       4      3      2\n    9 x + 23 x + 38 x + 17 x + 3\n\n    ","^0","^9"],["^ ","^7","empty","^8","empty(shape, dtype=float, order='C')\n\n    Return a new array of given shape and type, without initializing entries.\n\n    Parameters\n    ----------\n    shape : int or tuple of int\n        Shape of the empty array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        Desired output data-type for the array, e.g, `numpy.int8`. Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: 'C'\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n\n    Returns\n    -------\n    out : ndarray\n        Array of uninitialized (arbitrary) data of the given shape, dtype, and\n        order.  Object arrays will be initialized to None.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n\n    Notes\n    -----\n    `empty`, unlike `zeros`, does not set the array values to zero,\n    and may therefore be marginally faster.  On the other hand, it requires\n    the user to manually set all the values in the array, and should be\n    used with caution.\n\n    Examples\n    --------\n    >>> np.empty([2, 2])\n    array([[ -9.74499359e+001,   6.69583040e-309],\n           [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n    >>> np.empty([2, 2], dtype=int)\n    array([[-1073741821, -1067949133],\n           [  496041986,    19249760]])                     #uninitialized","^0","^?"],["^ ","^7","object0","^8","Any Python object.\n    Character code: ``'O'``.","^0","^0"],["^ ","^7","ndim","^8","\n    Return the number of dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  If it is not already an ndarray, a conversion is\n        attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in `a`.  Scalars are zero-dimensional.\n\n    See Also\n    --------\n    ndarray.ndim : equivalent method\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Examples\n    --------\n    >>> np.ndim([[1,2,3],[4,5,6]])\n    2\n    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.ndim(1)\n    0\n\n    ","^0","^9"],["^ ","^7","polyfit","^8","\n    Least squares polynomial fit.\n\n    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\n    to points `(x, y)`. Returns a vector of coefficients `p` that minimises\n    the squared error in the order `deg`, `deg-1`, ... `0`.\n\n    The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class\n    method is recommended for new code as it is more stable numerically. See\n    the documentation of the method for more information.\n\n    Parameters\n    ----------\n    x : array_like, shape (M,)\n        x-coordinates of the M sample points ``(x[i], y[i])``.\n    y : array_like, shape (M,) or (M, K)\n        y-coordinates of the sample points. Several data sets of sample\n        points sharing the same x-coordinates can be fitted at once by\n        passing in a 2D-array that contains one dataset per column.\n    deg : int\n        Degree of the fitting polynomial\n    rcond : float, optional\n        Relative condition number of the fit. Singular values smaller than\n        this relative to the largest singular value will be ignored. The\n        default value is len(x)*eps, where eps is the relative precision of\n        the float type, about 2e-16 in most cases.\n    full : bool, optional\n        Switch determining nature of return value. When it is False (the\n        default) just the coefficients are returned, when True diagnostic\n        information from the singular value decomposition is also returned.\n    w : array_like, shape (M,), optional\n        Weights to apply to the y-coordinates of the sample points. For\n        gaussian uncertainties, use 1/sigma (not 1/sigma**2).\n    cov : bool or str, optional\n        If given and not `False`, return not just the estimate but also its\n        covariance matrix. By default, the covariance are scaled by\n        chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable\n        except in a relative sense and everything is scaled such that the\n        reduced chi2 is unity. This scaling is omitted if ``cov='unscaled'``,\n        as is relevant for the case that the weights are 1/sigma**2, with\n        sigma known to be a reliable estimate of the uncertainty.\n\n    Returns\n    -------\n    p : ndarray, shape (deg + 1,) or (deg + 1, K)\n        Polynomial coefficients, highest power first.  If `y` was 2-D, the\n        coefficients for `k`-th data set are in ``p[:,k]``.\n\n    residuals, rank, singular_values, rcond\n        Present only if `full` = True.  Residuals is sum of squared residuals\n        of the least-squares fit, the effective rank of the scaled Vandermonde\n        coefficient matrix, its singular values, and the specified value of\n        `rcond`. For more details, see `linalg.lstsq`.\n\n    V : ndarray, shape (M,M) or (M,M,K)\n        Present only if `full` = False and `cov`=True.  The covariance\n        matrix of the polynomial coefficient estimates.  The diagonal of\n        this matrix are the variance estimates for each coefficient.  If y\n        is a 2-D array, then the covariance matrix for the `k`-th data set\n        are in ``V[:,:,k]``\n\n\n    Warns\n    -----\n    RankWarning\n        The rank of the coefficient matrix in the least-squares fit is\n        deficient. The warning is only raised if `full` = False.\n\n        The warnings can be turned off by\n\n        >>> import warnings\n        >>> warnings.simplefilter('ignore', np.RankWarning)\n\n    See Also\n    --------\n    polyval : Compute polynomial values.\n    linalg.lstsq : Computes a least-squares fit.\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\n\n    Notes\n    -----\n    The solution minimizes the squared error\n\n    .. math ::\n        E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\n    in the equations::\n\n        x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]\n        x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]\n        ...\n        x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]\n\n    The coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n    `polyfit` issues a `RankWarning` when the least-squares fit is badly\n    conditioned. This implies that the best fit is not well-defined due\n    to numerical error. The results may be improved by lowering the polynomial\n    degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\n    can also be set to a value smaller than its default, but the resulting\n    fit may be spurious: including contributions from the small singular\n    values can add numerical noise to the result.\n\n    Note that fitting polynomial coefficients is inherently badly conditioned\n    when the degree of the polynomial is large or the interval of sample points\n    is badly centered. The quality of the fit should always be checked in these\n    cases. When polynomial fits are not satisfactory, splines may be a good\n    alternative.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Curve fitting\",\n           https://en.wikipedia.org/wiki/Curve_fitting\n    .. [2] Wikipedia, \"Polynomial interpolation\",\n           https://en.wikipedia.org/wiki/Polynomial_interpolation\n\n    Examples\n    --------\n    >>> import warnings\n    >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n    >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n    >>> z = np.polyfit(x, y, 3)\n    >>> z\n    array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\n    It is convenient to use `poly1d` objects for dealing with polynomials:\n\n    >>> p = np.poly1d(z)\n    >>> p(0.5)\n    0.6143849206349179 # may vary\n    >>> p(3.5)\n    -0.34732142857143039 # may vary\n    >>> p(10)\n    22.579365079365115 # may vary\n\n    High-order polynomials may oscillate wildly:\n\n    >>> with warnings.catch_warnings():\n    ...     warnings.simplefilter('ignore', np.RankWarning)\n    ...     p30 = np.poly1d(np.polyfit(x, y, 30))\n    ...\n    >>> p30(4)\n    -0.80000000000000204 # may vary\n    >>> p30(5)\n    -0.99999999999999445 # may vary\n    >>> p30(4.5)\n    -0.10547061179440398 # may vary\n\n    Illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> xp = np.linspace(-2, 6, 100)\n    >>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n    >>> plt.ylim(-2,2)\n    (-2, 2)\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","string_","^8",null,"^0","^0"],["^ ","^7","choose","^8","\n    Construct an array from an index array and a set of arrays to choose from.\n\n    First of all, if confused or uncertain, definitely look at the Examples -\n    in its full generality, this function is less simple than it might\n    seem from the following code description (below ndi =\n    `numpy.lib.index_tricks`):\n\n    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.\n\n    But this omits some subtleties.  Here is a fully general summary:\n\n    Given an \"index\" array (`a`) of integers and a sequence of `n` arrays\n    (`choices`), `a` and each choice array are first broadcast, as necessary,\n    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =\n    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``\n    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as\n    follows:\n\n    * if ``mode=raise`` (the default), then, first of all, each element of\n      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that\n      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position\n      in `Ba` - then the value at the same position in the new array is the\n      value in `Bchoices[i]` at that same position;\n\n    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; modular arithmetic is used to map integers outside the range\n      `[0, n-1]` back into that range; and then the new array is constructed\n      as above;\n\n    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; negative integers are mapped to 0; values greater than `n-1`\n      are mapped to `n-1`; and then the new array is constructed as above.\n\n    Parameters\n    ----------\n    a : int array\n        This array must contain integers in `[0, n-1]`, where `n` is the number\n        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any\n        integers are permissible.\n    choices : sequence of arrays\n        Choice arrays. `a` and all of the choices must be broadcastable to the\n        same shape.  If `choices` is itself an array (not recommended), then\n        its outermost dimension (i.e., the one corresponding to\n        ``choices.shape[0]``) is taken as defining the \"sequence\".\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype. Note that `out` is always\n        buffered if `mode='raise'`; use other modes for better performance.\n    mode : {'raise' (default), 'wrap', 'clip'}, optional\n        Specifies how indices outside `[0, n-1]` will be treated:\n\n          * 'raise' : an exception is raised\n          * 'wrap' : value becomes value mod `n`\n          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1\n\n    Returns\n    -------\n    merged_array : array\n        The merged result.\n\n    Raises\n    ------\n    ValueError: shape mismatch\n        If `a` and each choice array are not all broadcastable to the same\n        shape.\n\n    See Also\n    --------\n    ndarray.choose : equivalent method\n    numpy.take_along_axis : Preferable if `choices` is an array\n\n    Notes\n    -----\n    To reduce the chance of misinterpretation, even though the following\n    \"abuse\" is nominally supported, `choices` should neither be, nor be\n    thought of as, a single array, i.e., the outermost sequence-like container\n    should be either a list or a tuple.\n\n    Examples\n    --------\n\n    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n    ...   [20, 21, 22, 23], [30, 31, 32, 33]]\n    >>> np.choose([2, 3, 1, 0], choices\n    ... # the first element of the result will be the first element of the\n    ... # third (2+1) \"array\" in choices, namely, 20; the second element\n    ... # will be the second element of the fourth (3+1) choice array, i.e.,\n    ... # 31, etc.\n    ... )\n    array([20, 31, 12,  3])\n    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\n    array([20, 31, 12,  3])\n    >>> # because there are 4 choice arrays\n    >>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\n    array([20,  1, 12,  3])\n    >>> # i.e., 0\n\n    A couple examples illustrating how choose broadcasts:\n\n    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    >>> choices = [-10, 10]\n    >>> np.choose(a, choices)\n    array([[ 10, -10,  10],\n           [-10,  10, -10],\n           [ 10, -10,  10]])\n\n    >>> # With thanks to Anne Archibald\n    >>> a = np.array([0, 1]).reshape((2,1,1))\n    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))\n    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\n    array([[[ 1,  1,  1,  1,  1],\n            [ 2,  2,  2,  2,  2],\n            [ 3,  3,  3,  3,  3]],\n           [[-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5]]])\n\n    ","^0","^9"],["^ ","^7","irr","^8","\n    Return the Internal Rate of Return (IRR).\n\n    .. deprecated:: 1.18\n\n       `irr` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    This is the \"average\" periodically compounded rate of return\n    that gives a net present value of 0.0; for a more complete explanation,\n    see Notes below.\n\n    :class:`decimal.Decimal` type is not supported.\n\n    Parameters\n    ----------\n    values : array_like, shape(N,)\n        Input cash flows per time period.  By convention, net \"deposits\"\n        are negative and net \"withdrawals\" are positive.  Thus, for\n        example, at least the first element of `values`, which represents\n        the initial investment, will typically be negative.\n\n    Returns\n    -------\n    out : float\n        Internal Rate of Return for periodic input values.\n\n    Notes\n    -----\n    The IRR is perhaps best understood through an example (illustrated\n    using np.irr in the Examples section below).  Suppose one invests 100\n    units and then makes the following withdrawals at regular (fixed)\n    intervals: 39, 59, 55, 20.  Assuming the ending value is 0, one's 100\n    unit investment yields 173 units; however, due to the combination of\n    compounding and the periodic withdrawals, the \"average\" rate of return\n    is neither simply 0.73/4 nor (1.73)^0.25-1.  Rather, it is the solution\n    (for :math:`r`) of the equation:\n\n    .. math:: -100 + \\frac{39}{1+r} + \\frac{59}{(1+r)^2}\n     + \\frac{55}{(1+r)^3} + \\frac{20}{(1+r)^4} = 0\n\n    In general, for `values` :math:`= [v_0, v_1, ... v_M]`,\n    irr is the solution of the equation: [2]_\n\n    .. math:: \\sum_{t=0}^M{\\frac{v_t}{(1+irr)^{t}}} = 0\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    .. [2] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 348.\n\n    Examples\n    --------\n    >>> round(np.irr([-100, 39, 59, 55, 20]), 5)\n    0.28095\n    >>> round(np.irr([-100, 0, 0, 74]), 5)\n    -0.0955\n    >>> round(np.irr([-100, 100, 0, -7]), 5)\n    -0.0833\n    >>> round(np.irr([-100, 100, 0, 7]), 5)\n    0.06206\n    >>> round(np.irr([-5, 10.5, 1, -8, 1]), 5)\n    0.0886\n\n    ","^0","^9"],["^ ","^7","logspace","^8","\n    Return numbers spaced evenly on a log scale.\n\n    In linear space, the sequence starts at ``base ** start``\n    (`base` to the power of `start`) and ends with ``base ** stop``\n    (see `endpoint` below).\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        ``base ** start`` is the starting value of the sequence.\n    stop : array_like\n        ``base ** stop`` is the final value of the sequence, unless `endpoint`\n        is False.  In that case, ``num + 1`` values are spaced over the\n        interval in log-space, of which all but the last (a sequence of\n        length `num`) are returned.\n    num : integer, optional\n        Number of samples to generate.  Default is 50.\n    endpoint : boolean, optional\n        If true, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    base : float, optional\n        The base of the log space. The step size between the elements in\n        ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform.\n        Default is 10.0.\n    dtype : dtype\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n\n    Returns\n    -------\n    samples : ndarray\n        `num` samples, equally spaced on a log scale.\n\n    See Also\n    --------\n    arange : Similar to linspace, with the step size specified instead of the\n             number of samples. Note that, when used with a float endpoint, the\n             endpoint may or may not be included.\n    linspace : Similar to logspace, but with the samples uniformly distributed\n               in linear space, instead of log space.\n    geomspace : Similar to logspace, but with endpoints specified directly.\n\n    Notes\n    -----\n    Logspace is equivalent to the code\n\n    >>> y = np.linspace(start, stop, num=num, endpoint=endpoint)\n    ... # doctest: +SKIP\n    >>> power(base, y).astype(dtype)\n    ... # doctest: +SKIP\n\n    Examples\n    --------\n    >>> np.logspace(2.0, 3.0, num=4)\n    array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])\n    >>> np.logspace(2.0, 3.0, num=4, endpoint=False)\n    array([100.        ,  177.827941  ,  316.22776602,  562.34132519])\n    >>> np.logspace(2.0, 3.0, num=4, base=2.0)\n    array([4.        ,  5.0396842 ,  6.34960421,  8.        ])\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 10\n    >>> x1 = np.logspace(0.1, 1, N, endpoint=True)\n    >>> x2 = np.logspace(0.1, 1, N, endpoint=False)\n    >>> y = np.zeros(N)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","logical_not","^8","logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of NOT x element-wise.\n\nParameters\n----------\nx : array_like\n    Logical NOT is applied to the elements of `x`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : bool or ndarray of bool\n    Boolean result with the same shape as `x` of the NOT operation\n    on elements of `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlogical_and, logical_or, logical_xor\n\nExamples\n--------\n>>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_not(x<3)\narray([False, False, False,  True,  True])","^0","^;"],["^ ","^7","loads","^8",null,"^0","^9"],["^ ","^7","bincount","^8","\n    bincount(x, weights=None, minlength=0)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        A minimum number of bins for the output array.\n\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is negative.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=float))\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: array cannot be safely cast to required type\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n\n    ","^0","^9"],["^ ","^7","format_float_scientific","^8","\n    Format a floating-point scalar as a decimal string in scientific notation.\n\n    Provides control over rounding, trimming and padding. Uses and assumes\n    IEEE unbiased rounding. Uses the \"Dragon4\" algorithm.\n\n    Parameters\n    ----------\n    x : python float or numpy floating scalar\n        Value to format.\n    precision : non-negative integer or None, optional\n        Maximum number of digits to print. May be None if `unique` is\n        `True`, but must be an integer if unique is `False`.\n    unique : boolean, optional\n        If `True`, use a digit-generation strategy which gives the shortest\n        representation which uniquely identifies the floating-point number from\n        other values of the same type, by judicious rounding. If `precision`\n        was omitted, print all necessary digits, otherwise digit generation is\n        cut off after `precision` digits and the remaining value is rounded.\n        If `False`, digits are generated as if printing an infinite-precision\n        value and stopping after `precision` digits, rounding the remaining\n        value.\n    trim : one of 'k', '.', '0', '-', optional\n        Controls post-processing trimming of trailing digits, as follows:\n\n        * 'k' : keep trailing zeros, keep decimal point (no trimming)\n        * '.' : trim all trailing zeros, leave decimal point\n        * '0' : trim all but the zero before the decimal point. Insert the\n          zero if it is missing.\n        * '-' : trim trailing zeros and any trailing decimal point\n    sign : boolean, optional\n        Whether to show the sign for positive values.\n    pad_left : non-negative integer, optional\n        Pad the left side of the string with whitespace until at least that\n        many characters are to the left of the decimal point.\n    exp_digits : non-negative integer, optional\n        Pad the exponent with zeros until it contains at least this many digits.\n        If omitted, the exponent will be at least 2 digits.\n\n    Returns\n    -------\n    rep : string\n        The string representation of the floating point value\n\n    See Also\n    --------\n    format_float_positional\n\n    Examples\n    --------\n    >>> np.format_float_scientific(np.float32(np.pi))\n    '3.1415927e+00'\n    >>> s = np.float32(1.23e24)\n    >>> np.format_float_scientific(s, unique=False, precision=15)\n    '1.230000071797338e+24'\n    >>> np.format_float_scientific(s, exp_digits=4)\n    '1.23e+0024'\n    ","^0","^9"],["^ ","^7","tan","^8","tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute tangent element-wise.\n\nEquivalent to ``np.sin(x)/np.cos(x)`` element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding tangent values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.\n\nExamples\n--------\n>>> from math import pi\n>>> np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n>>>\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)","^0","^;"],["^ ","^7","int_","^8","Signed integer type, compatible with Python `int` anc C ``long``.\n    Character code: ``'l'``.\n    Canonical name: ``np.int_``.\n    Alias *on this platform*: ``np.int64``: 64-bit signed integer (-9223372036854775808 to 9223372036854775807).\n    Alias *on this platform*: ``np.intp``: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.","^0","^0"],["^ ","^7","recarray","^8","Construct an ndarray that allows field access using attributes.\n\n    Arrays may have a data-types containing fields, analogous\n    to columns in a spread sheet.  An example is ``[(x, int), (y, float)]``,\n    where each entry in the array is a pair of ``(int, float)``.  Normally,\n    these attributes are accessed using dictionary lookups such as ``arr['x']``\n    and ``arr['y']``.  Record arrays allow the fields to be accessed as members\n    of the array, using ``arr.x`` and ``arr.y``.\n\n    Parameters\n    ----------\n    shape : tuple\n        Shape of output array.\n    dtype : data-type, optional\n        The desired data-type.  By default, the data-type is determined\n        from `formats`, `names`, `titles`, `aligned` and `byteorder`.\n    formats : list of data-types, optional\n        A list containing the data-types for the different columns, e.g.\n        ``['i4', 'f8', 'i4']``.  `formats` does *not* support the new\n        convention of using types directly, i.e. ``(int, float, int)``.\n        Note that `formats` must be a list, not a tuple.\n        Given that `formats` is somewhat limited, we recommend specifying\n        `dtype` instead.\n    names : tuple of str, optional\n        The name of each column, e.g. ``('x', 'y', 'z')``.\n    buf : buffer, optional\n        By default, a new array is created of the given shape and data-type.\n        If `buf` is specified and is an object exposing the buffer interface,\n        the array will use the memory from the existing buffer.  In this case,\n        the `offset` and `strides` keywords are available.\n\n    Other Parameters\n    ----------------\n    titles : tuple of str, optional\n        Aliases for column names.  For example, if `names` were\n        ``('x', 'y', 'z')`` and `titles` is\n        ``('x_coordinate', 'y_coordinate', 'z_coordinate')``, then\n        ``arr['x']`` is equivalent to both ``arr.x`` and ``arr.x_coordinate``.\n    byteorder : {'<', '>', '='}, optional\n        Byte-order for all fields.\n    aligned : bool, optional\n        Align the fields in memory as the C-compiler would.\n    strides : tuple of ints, optional\n        Buffer (`buf`) is interpreted according to these strides (strides\n        define how many bytes each array element, row, column, etc.\n        occupy in memory).\n    offset : int, optional\n        Start reading buffer (`buf`) from this offset onwards.\n    order : {'C', 'F'}, optional\n        Row-major (C-style) or column-major (Fortran-style) order.\n\n    Returns\n    -------\n    rec : recarray\n        Empty array of the given shape and type.\n\n    See Also\n    --------\n    rec.fromrecords : Construct a record array from data.\n    record : fundamental data-type for `recarray`.\n    format_parser : determine a data-type from formats, names, titles.\n\n    Notes\n    -----\n    This constructor can be compared to ``empty``: it creates a new record\n    array but does not fill it with data.  To create a record array from data,\n    use one of the following methods:\n\n    1. Create a standard ndarray and convert it to a record array,\n       using ``arr.view(np.recarray)``\n    2. Use the `buf` keyword.\n    3. Use `np.rec.fromrecords`.\n\n    Examples\n    --------\n    Create an array with two fields, ``x`` and ``y``:\n\n    >>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '<f8'), ('y', '<i8')])\n    >>> x\n    array([(1., 2), (3., 4)], dtype=[('x', '<f8'), ('y', '<i8')])\n\n    >>> x['x']\n    array([1., 3.])\n\n    View the array as a record array:\n\n    >>> x = x.view(np.recarray)\n\n    >>> x.x\n    array([1., 3.])\n\n    >>> x.y\n    array([2, 4])\n\n    Create a new, empty record array:\n\n    >>> np.recarray((2,),\n    ... dtype=[('x', int), ('y', float), ('z', int)]) #doctest: +SKIP\n    rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),\n           (3471280, 1.2134086255804012e-316, 0)],\n          dtype=[('x', '<i4'), ('y', '<f8'), ('z', '<i4')])\n\n    ","^0","^0"],["^ ","^7","cos","^8","cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCosine element-wise.\n\nParameters\n----------\nx : array_like\n    Input array in radians.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding cosine values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.\n\nExamples\n--------\n>>> np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n>>>\n>>> # Example of providing the optional output parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)","^0","^;"],["^ ","^7","tensordot","^8","\n    Compute tensor dot product along specified axes.\n\n    Given two tensors, `a` and `b`, and an array_like object containing\n    two array_like objects, ``(a_axes, b_axes)``, sum the products of\n    `a`'s and `b`'s elements (components) over the axes specified by\n    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions\n    of `a` and the first ``N`` dimensions of `b` are summed over.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Tensors to \"dot\".\n\n    axes : int or (2,) array_like\n        * integer_like\n          If an int N, sum over the last N axes of `a` and the first N axes\n          of `b` in order. The sizes of the corresponding axes must match.\n        * (2,) array_like\n          Or, a list of axes to be summed over, first sequence applying to `a`,\n          second to `b`. Both elements array_like must be of the same length.\n\n    Returns\n    -------\n    output : ndarray\n        The tensor dot product of the input.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    Three common use cases are:\n        * ``axes = 0`` : tensor product :math:`a\\otimes b`\n        * ``axes = 1`` : tensor dot product :math:`a\\cdot b`\n        * ``axes = 2`` : (default) tensor double contraction :math:`a:b`\n\n    When `axes` is integer_like, the sequence for evaluation will be: first\n    the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and\n    Nth axis in `b` last.\n\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of `a` (`b`) - the argument `axes` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n\n    The shape of the result consists of the non-contracted axes of the\n    first tensor, followed by the non-contracted axes of the second.\n\n    Examples\n    --------\n    A \"traditional\" example:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[4400., 4730.],\n           [4532., 4874.],\n           [4664., 5018.],\n           [4796., 5162.],\n           [4928., 5306.]])\n    >>> # A slower but equivalent way of computing the same...\n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]])\n\n    An extended example taking advantage of the overloading of + and \\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([['a', 'b'],\n           ['c', 'd']], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2 for double-contraction\n    array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[['acc', 'bdd'],\n            ['aaacccc', 'bbbdddd']],\n           [['aaaaacccccc', 'bbbbbdddddd'],\n            ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)\n    array([[[[['a', 'b'],\n              ['c', 'd']],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[['abbbbb', 'cddddd'],\n            ['aabbbbbb', 'ccdddddd']],\n           [['aaabbbbbbb', 'cccddddddd'],\n            ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[['abb', 'cdd'],\n            ['aaabbbb', 'cccdddd']],\n           [['aaaaabbbbbb', 'cccccdddddd'],\n            ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\n\n    ","^0","^9"],["^ ","^7","DataSource","^8","\n    DataSource(destpath='.')\n\n    A generic data source file (file, http, ftp, ...).\n\n    DataSources can be local files or remote files/URLs.  The files may\n    also be compressed or uncompressed. DataSource hides some of the\n    low-level details of downloading the file, allowing you to simply pass\n    in a valid file path (or URL) and obtain a file object.\n\n    Parameters\n    ----------\n    destpath : str or None, optional\n        Path to the directory where the source file gets downloaded to for\n        use.  If `destpath` is None, a temporary directory will be created.\n        The default path is the current directory.\n\n    Notes\n    -----\n    URLs require a scheme string (``http://``) to be used, without it they\n    will fail::\n\n        >>> repos = np.DataSource()\n        >>> repos.exists('www.google.com/index.html')\n        False\n        >>> repos.exists('http://www.google.com/index.html')\n        True\n\n    Temporary directories are deleted when the DataSource is deleted.\n\n    Examples\n    --------\n    ::\n\n        >>> ds = np.DataSource('/home/guido')\n        >>> urlname = 'http://www.google.com/'\n        >>> gfile = ds.open('http://www.google.com/')\n        >>> ds.abspath(urlname)\n        '/home/guido/www.google.com/index.html'\n\n        >>> ds = np.DataSource(None)  # use with temporary file\n        >>> ds.open('/home/guido/foobar.txt')\n        <open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430>\n        >>> ds.abspath('/home/guido/foobar.txt')\n        '/tmp/.../home/guido/foobar.txt'\n\n    ","^0","^0"],["^ ","^7","argsort","^8","\n    Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort.  The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort under the covers and, in general, the\n        actual implementation will vary with data type. The 'mergesort' option\n        is retained for backwards compatibility.\n\n        .. versionchanged:: 1.15.0.\n           The 'stable' option was added.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified `axis`.\n        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.\n        More generally, ``np.take_along_axis(a, index_array, axis=axis)``\n        always yields the sorted `a`, irrespective of dimensionality.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n    argpartition : Indirect partial sort.\n    take_along_axis : Apply ``index_array`` from argsort \n                      to an array as if by calling sort.\n\n    Notes\n    -----\n    See `sort` for notes on the different sorting algorithms.\n\n    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing\n    nan values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n\n    >>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)\n    >>> ind\n    array([[0, 1],\n           [1, 0]])\n    >>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)\n    array([[0, 2],\n           [2, 3]])\n\n    >>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)\n    >>> ind\n    array([[0, 1],\n           [0, 1]])\n    >>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)\n    array([[0, 3],\n           [2, 2]])\n\n    Indices of the sorted elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)\n    >>> ind\n    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))\n    >>> x[ind]  # same as np.sort(x, axis=None)\n    array([0, 2, 2, 3])\n\n    Sorting with keys:\n\n    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])\n    >>> x\n    array([(1, 0), (0, 1)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    >>> np.argsort(x, order=('x','y'))\n    array([1, 0])\n\n    >>> np.argsort(x, order=('y','x'))\n    array([0, 1])\n\n    ","^0","^9"],["^ ","^7","trunc","^8","trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truncated value of the input, element-wise.\n\nThe truncated value of the scalar `x` is the nearest integer `i` which\nis closer to zero than `x` is. In short, the fractional part of the\nsigned number `x` is discarded.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The truncated value of each element in `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nceil, floor, rint\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])","^0","^;"],["^ ","^7","intersect1d","^8","\n    Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. Will be flattened if not already 1D.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n    return_indices : bool\n        If True, the indices which correspond to the intersection of the two\n        arrays are returned. The first instance of a value is used if there are\n        multiple. Default is False.\n\n        .. versionadded:: 1.15.0\n\n    Returns\n    -------\n    intersect1d : ndarray\n        Sorted 1D array of common and unique elements.\n    comm1 : ndarray\n        The indices of the first occurrences of the common values in `ar1`.\n        Only provided if `return_indices` is True.\n    comm2 : ndarray\n        The indices of the first occurrences of the common values in `ar2`.\n        Only provided if `return_indices` is True.\n\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\n    array([1, 3])\n\n    To intersect more than two arrays, use functools.reduce:\n\n    >>> from functools import reduce\n    >>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\n    array([3])\n\n    To return the indices of the values common to the input arrays\n    along with the intersected values:\n\n    >>> x = np.array([1, 1, 2, 3, 4])\n    >>> y = np.array([2, 1, 4, 6])\n    >>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)\n    >>> x_ind, y_ind\n    (array([0, 2, 4]), array([1, 0, 2]))\n    >>> xy, x[x_ind], y[y_ind]\n    (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))\n\n    ","^0","^9"],["^ ","^7","fill_diagonal","^8","Fill the main diagonal of the given array of any dimensionality.\n\n    For an array `a` with ``a.ndim >= 2``, the diagonal is the list of\n    locations with indices ``a[i, ..., i]`` all identical. This function\n    modifies the input array in-place, it does not return a value.\n\n    Parameters\n    ----------\n    a : array, at least 2-D.\n      Array whose diagonal is to be filled, it gets modified in-place.\n\n    val : scalar\n      Value to be written on the diagonal, its type must be compatible with\n      that of the array a.\n\n    wrap : bool\n      For tall matrices in NumPy version up to 1.6.2, the\n      diagonal \"wrapped\" after N columns. You can have this behavior\n      with this option. This affects only tall matrices.\n\n    See also\n    --------\n    diag_indices, diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    This functionality can be obtained via `diag_indices`, but internally\n    this version uses a much faster implementation that never constructs the\n    indices and uses simple slicing.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), int)\n    >>> np.fill_diagonal(a, 5)\n    >>> a\n    array([[5, 0, 0],\n           [0, 5, 0],\n           [0, 0, 5]])\n\n    The same function can operate on a 4-D array:\n\n    >>> a = np.zeros((3, 3, 3, 3), int)\n    >>> np.fill_diagonal(a, 4)\n\n    We only show a few blocks for clarity:\n\n    >>> a[0, 0]\n    array([[4, 0, 0],\n           [0, 0, 0],\n           [0, 0, 0]])\n    >>> a[1, 1]\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 0]])\n    >>> a[2, 2]\n    array([[0, 0, 0],\n           [0, 0, 0],\n           [0, 0, 4]])\n\n    The wrap option affects only tall matrices:\n\n    >>> # tall matrices no wrap\n    >>> a = np.zeros((5, 3), int)\n    >>> np.fill_diagonal(a, 4)\n    >>> a\n    array([[4, 0, 0],\n           [0, 4, 0],\n           [0, 0, 4],\n           [0, 0, 0],\n           [0, 0, 0]])\n\n    >>> # tall matrices wrap\n    >>> a = np.zeros((5, 3), int)\n    >>> np.fill_diagonal(a, 4, wrap=True)\n    >>> a\n    array([[4, 0, 0],\n           [0, 4, 0],\n           [0, 0, 4],\n           [0, 0, 0],\n           [4, 0, 0]])\n\n    >>> # wide matrices\n    >>> a = np.zeros((3, 5), int)\n    >>> np.fill_diagonal(a, 4, wrap=True)\n    >>> a\n    array([[4, 0, 0, 0, 0],\n           [0, 4, 0, 0, 0],\n           [0, 0, 4, 0, 0]])\n\n    The anti-diagonal can be filled by reversing the order of elements\n    using either `numpy.flipud` or `numpy.fliplr`.\n\n    >>> a = np.zeros((3, 3), int);\n    >>> np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip\n    >>> a\n    array([[0, 0, 1],\n           [0, 2, 0],\n           [3, 0, 0]])\n    >>> np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip\n    >>> a\n    array([[0, 0, 3],\n           [0, 2, 0],\n           [1, 0, 0]])\n\n    Note that the order in which the diagonal is filled varies depending\n    on the flip function.\n    ","^0","^9"],["^ ","^7","numpy.linalg","^8","\n``numpy.linalg``\n================\n\nThe NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient\nlow level implementations of standard linear algebra algorithms. Those\nlibraries may be provided by NumPy itself using C versions of a subset of their\nreference implementations but, when possible, highly optimized libraries that\ntake advantage of specialized processor functionality are preferred. Examples\nof such libraries are OpenBLAS, MKL (TM), and ATLAS. Because those libraries\nare multithreaded and processor dependent, environmental variables and external\npackages such as threadpoolctl may be needed to control the number of threads\nor specify the processor architecture.\n\n- OpenBLAS: https://www.openblas.net/\n- threadpoolctl: https://github.com/joblib/threadpoolctl\n\nPlease note that the most-used linear algebra functions in NumPy are present in\nthe main ``numpy`` namespace rather than in ``numpy.linalg``.  There are:\n``dot``, ``vdot``, ``inner``, ``outer``, ``matmul``, ``tensordot``, ``einsum``,\n``einsum_path`` and ``kron``.\n\nFunctions present in numpy.linalg are listed below.\n\n\nMatrix and vector products\n--------------------------\n\n   multi_dot\n   matrix_power\n\nDecompositions\n--------------\n\n   cholesky\n   qr\n   svd\n\nMatrix eigenvalues\n------------------\n\n   eig\n   eigh\n   eigvals\n   eigvalsh\n\nNorms and other numbers\n-----------------------\n\n   norm\n   cond\n   det\n   matrix_rank\n   slogdet\n\nSolving equations and inverting matrices\n----------------------------------------\n\n   solve\n   tensorsolve\n   lstsq\n   inv\n   pinv\n   tensorinv\n\nExceptions\n----------\n\n   LinAlgError\n\n","^0","^>"],["^ ","^7","triu_indices","^8","\n    Return the indices for the upper-triangle of an (n, m) array.\n\n    Parameters\n    ----------\n    n : int\n        The size of the arrays for which the returned indices will\n        be valid.\n    k : int, optional\n        Diagonal offset (see `triu` for details).\n    m : int, optional\n        .. versionadded:: 1.9.0\n\n        The column dimension of the arrays for which the returned\n        arrays will be valid.\n        By default `m` is taken equal to `n`.\n\n\n    Returns\n    -------\n    inds : tuple, shape(2) of ndarrays, shape(`n`)\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.  Can be used\n        to slice a ndarray of shape(`n`, `n`).\n\n    See also\n    --------\n    tril_indices : similar function, for lower-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    triu, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    upper triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> iu1 = np.triu_indices(4)\n    >>> iu2 = np.triu_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[iu1]\n    array([ 0,  1,  2, ..., 10, 11, 15])\n\n    And for assigning values:\n\n    >>> a[iu1] = -1\n    >>> a\n    array([[-1, -1, -1, -1],\n           [ 4, -1, -1, -1],\n           [ 8,  9, -1, -1],\n           [12, 13, 14, -1]])\n\n    These cover only a small part of the whole array (two diagonals right\n    of the main one):\n\n    >>> a[iu2] = -10\n    >>> a\n    array([[ -1,  -1, -10, -10],\n           [  4,  -1,  -1, -10],\n           [  8,   9,  -1,  -1],\n           [ 12,  13,  14,  -1]])\n\n    ","^0","^9"],["^ ","^7","mod","^8","remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor\n\nNotes\n-----\nReturns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\nintegers.\n``mod`` is an alias of ``remainder``.\n\nExamples\n--------\n>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])","^0","^;"],["^ ","^7","mirr","^8","\n    Modified internal rate of return.\n\n    .. deprecated:: 1.18\n\n       `mirr` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Parameters\n    ----------\n    values : array_like\n        Cash flows (must contain at least one positive and one negative\n        value) or nan is returned.  The first value is considered a sunk\n        cost at time zero.\n    finance_rate : scalar\n        Interest rate paid on the cash flows\n    reinvest_rate : scalar\n        Interest rate received on the cash flows upon reinvestment\n\n    Returns\n    -------\n    out : float\n        Modified internal rate of return\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    ","^0","^9"],["^ ","^7","broadcast_arrays","^8","\n    Broadcast any number of arrays against each other.\n\n    Parameters\n    ----------\n    `*args` : array_likes\n        The arrays to broadcast.\n\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned arrays will be forced to be a base-class array (default).\n\n    Returns\n    -------\n    broadcasted : list of arrays\n        These arrays are views on the original arrays.  They are typically\n        not contiguous.  Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location. If you need\n        to write to the arrays, make copies first. While you can set the\n        ``writable`` flag True, writing to a single output value may end up\n        changing more than one location in the output array.\n\n        .. deprecated:: 1.17\n            The output is currently marked so that if written to, a deprecation\n            warning will be emitted. A future version will set the\n            ``writable`` flag False so writing to it will raise an error.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> y = np.array([[4],[5]])\n    >>> np.broadcast_arrays(x, y)\n    [array([[1, 2, 3],\n           [1, 2, 3]]), array([[4, 4, 4],\n           [5, 5, 5]])]\n\n    Here is a useful idiom for getting contiguous copies instead of\n    non-contiguous views.\n\n    >>> [np.array(a) for a in np.broadcast_arrays(x, y)]\n    [array([[1, 2, 3],\n           [1, 2, 3]]), array([[4, 4, 4],\n           [5, 5, 5]])]\n\n    ","^0","^9"],["^ ","^7","integer","^8","Abstract base class of all integer scalar types.","^0","^0"],["^ ","^7","geterrobj","^8","geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in NumPy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [8192, 521, None]\n\n    >>> def err_handler(type, flag):\n    ...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide='raise')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [8192, 521, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all='ignore')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    '0'\n    >>> old_err = np.seterr(divide='warn', over='log', under='call',\n    ...                     invalid='print')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    '4351'","^0","^?"],["^ ","^7","printoptions","^8","Context manager for setting print options.\n\n    Set print options for the scope of the `with` block, and restore the old\n    options at the end. See `set_printoptions` for the full description of\n    available options.\n\n    Examples\n    --------\n\n    >>> from numpy.testing import assert_equal\n    >>> with np.printoptions(precision=2):\n    ...     np.array([2.0]) / 3\n    array([0.67])\n\n    The `as`-clause of the `with`-statement gives the current print options:\n\n    >>> with np.printoptions(precision=2) as opts:\n    ...      assert_equal(opts, np.get_printoptions())\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    ","^0","^9"],["^ ","^7","int8","^8","Signed integer type, compatible with C ``char``.\n    Character code: ``'b'``.\n    Canonical name: ``np.byte``.\n    Alias *on this platform*: ``np.int8``: 8-bit signed integer (-128 to 127).","^0","^0"],["^ ","^7","safe_eval","^8","\n    Protected string evaluation.\n\n    Evaluate a string containing a Python literal expression without\n    allowing the execution of arbitrary non-literal code.\n\n    Parameters\n    ----------\n    source : str\n        The string to evaluate.\n\n    Returns\n    -------\n    obj : object\n       The result of evaluating `source`.\n\n    Raises\n    ------\n    SyntaxError\n        If the code has invalid Python syntax, or if it contains\n        non-literal code.\n\n    Examples\n    --------\n    >>> np.safe_eval('1')\n    1\n    >>> np.safe_eval('[1, 2, 3]')\n    [1, 2, 3]\n    >>> np.safe_eval('{\"foo\": (\"bar\", 10.0)}')\n    {'foo': ('bar', 10.0)}\n\n    >>> np.safe_eval('import os')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: invalid syntax\n\n    >>> np.safe_eval('open(\"/home/user/.ssh/id_dsa\").read()')\n    Traceback (most recent call last):\n      ...\n    ValueError: malformed node or string: <_ast.Call object at 0x...>\n\n    ","^0","^9"],["^ ","^7","numpy.lib","^8","\n**Note:** almost all functions in the ``numpy.lib`` namespace\nare also present in the main ``numpy`` namespace.  Please use the\nfunctions as ``np.<funcname>`` where possible.\n\n``numpy.lib`` is mostly a space for implementing functions that don't\nbelong in core or in another NumPy submodule with a clear purpose\n(e.g. ``random``, ``fft``, ``linalg``, ``ma``).\n\nMost contains basic functions that are used by several submodules and are\nuseful to have in the main name-space.\n\n","^0","^>"],["^ ","^7","promote_types","^8","promote_types(type1, type2)\n\n    Returns the data type with the smallest size and smallest scalar\n    kind to which both ``type1`` and ``type2`` may be safely cast.\n    The returned data type is always in native byte order.\n\n    This function is symmetric, but rarely associative.\n\n    Parameters\n    ----------\n    type1 : dtype or dtype specifier\n        First data type.\n    type2 : dtype or dtype specifier\n        Second data type.\n\n    Returns\n    -------\n    out : dtype\n        The promoted data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Starting in NumPy 1.9, promote_types function now returns a valid string\n    length when given an integer or float dtype as one argument and a string\n    dtype as another argument. Previously it always returned the input string\n    dtype, even if it wasn't long enough to store the max integer/float value\n    converted to a string.\n\n    See Also\n    --------\n    result_type, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.promote_types('f4', 'f8')\n    dtype('float64')\n\n    >>> np.promote_types('i8', 'f4')\n    dtype('float64')\n\n    >>> np.promote_types('>i8', '<c8')\n    dtype('complex128')\n\n    >>> np.promote_types('i4', 'S8')\n    dtype('S11')\n\n    An example of a non-associative case:\n\n    >>> p = np.promote_types\n    >>> p('S', p('i1', 'u1'))\n    dtype('S6')\n    >>> p(p('S', 'i1'), 'u1')\n    dtype('S4')","^0","^?"],["^ ","^7","square","^8","square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the element-wise square of the input.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Element-wise `x*x`, of the same shape and dtype as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nnumpy.linalg.matrix_power\nsqrt\npower\n\nExamples\n--------\n>>> np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])","^0","^;"],["^ ","^7","ModuleDeprecationWarning","^8","Module deprecation warning.\n\n    The nose tester turns ordinary Deprecation warnings into test failures.\n    That makes it hard to deprecate whole modules, because they get\n    imported by default. So this is a special Deprecation warning that the\n    nose tester will let pass without making tests fail.\n\n    ","^0","^0"],["^ ","^7","may_share_memory","^8","\n    may_share_memory(a, b, max_work=None)\n\n    Determine if two arrays might share memory\n\n    A return of True does not necessarily mean that the two arrays\n    share any element.  It just means that they *might*.\n\n    Only the memory bounds of a and b are checked by default.\n\n    Parameters\n    ----------\n    a, b : ndarray\n        Input arrays\n    max_work : int, optional\n        Effort to spend on solving the overlap problem.  See\n        `shares_memory` for details.  Default for ``may_share_memory``\n        is to do a bounds check.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    shares_memory\n\n    Examples\n    --------\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n    >>> x = np.zeros([3, 4])\n    >>> np.may_share_memory(x[:,0], x[:,1])\n    True\n\n    ","^0","^9"],["^ ","^8","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^0","^@"],["^ ","^7","source","^8","\n    Print or write to a file the source code for a NumPy object.\n\n    The source code is only returned for objects written in Python. Many\n    functions and classes are defined in C and will therefore not return\n    useful information.\n\n    Parameters\n    ----------\n    object : numpy object\n        Input object. This can be any object (function, class, module,\n        ...).\n    output : file object, optional\n        If `output` not supplied then source code is printed to screen\n        (sys.stdout).  File object must be created with either write 'w' or\n        append 'a' modes.\n\n    See Also\n    --------\n    lookfor, info\n\n    Examples\n    --------\n    >>> np.source(np.interp)                        #doctest: +SKIP\n    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\n    def interp(x, xp, fp, left=None, right=None):\n        \"\"\".... (full docstring printed)\"\"\"\n        if isinstance(x, (float, int, number)):\n            return compiled_interp([x], xp, fp, left, right).item()\n        else:\n            return compiled_interp(x, xp, fp, left, right)\n\n    The source code is only returned for objects written in Python.\n\n    >>> np.source(np.array)                         #doctest: +SKIP\n    Not available for this object.\n\n    ","^0","^9"],["^ ","^7","swapaxes","^8","\n    Interchange two axes of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis1 : int\n        First axis.\n    axis2 : int\n        Second axis.\n\n    Returns\n    -------\n    a_swapped : ndarray\n        For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is\n        returned; otherwise a new array is created. For earlier NumPy\n        versions a view of `a` is returned only if the order of the\n        axes is changed, otherwise the input array is returned.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> np.swapaxes(x,0,1)\n    array([[1],\n           [2],\n           [3]])\n\n    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n\n    >>> np.swapaxes(x,0,2)\n    array([[[0, 4],\n            [2, 6]],\n           [[1, 5],\n            [3, 7]]])\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","sort_complex","^8","\n    Sort a complex array using the real part first, then the imaginary part.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n\n    Returns\n    -------\n    out : complex ndarray\n        Always returns a sorted complex array.\n\n    Examples\n    --------\n    >>> np.sort_complex([5, 3, 6, 2, 1])\n    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])\n\n    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\n    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n\n    ","^0","^9"],["^ ","^7","less","^8","less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 < x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngreater, less_equal, greater_equal, equal, not_equal\n\nExamples\n--------\n>>> np.less([1, 2], [2, 2])\narray([ True, False])","^0","^;"],["^ ","^7","complexfloating","^8","Abstract base class of all complex number scalar types that are made up of\n    floating-point numbers.","^0","^0"],["^ ","^7","unpackbits","^8","\n    unpackbits(a, axis=None, count=None, bitorder='big')\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `a` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is\n    either 1-D (if `axis` is ``None``) or the same shape as the input\n    array with unpacking done along the axis specified.\n\n    Parameters\n    ----------\n    a : ndarray, uint8 type\n       Input array.\n    axis : int, optional\n        The dimension over which bit-unpacking is done.\n        ``None`` implies unpacking the flattened array.\n    count : int or None, optional\n        The number of elements to unpack along `axis`, provided as a way\n        of undoing the effect of packing a size that is not a multiple\n        of eight. A non-negative number means to only unpack `count`\n        bits. A negative number means to trim off that many bits from\n        the end. ``None`` means to unpack the entire array (the\n        default). Counts larger than the available number of bits will\n        add zero padding to the output. Negative counts must not\n        exceed the available number of bits.\n\n        .. versionadded:: 1.17.0\n\n    bitorder : {'big', 'little'}, optional\n        The order of the returned bits. 'big' will mimic bin(val),\n        ``3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse\n        the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.\n        Defaults to 'big'.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    unpacked : ndarray, uint8 type\n       The elements are binary-valued (0 or 1).\n\n    See Also\n    --------\n    packbits : Packs the elements of a binary-valued array into bits in\n               a uint8 array.\n\n    Examples\n    --------\n    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n    >>> a\n    array([[ 2],\n           [ 7],\n           [23]], dtype=uint8)\n    >>> b = np.unpackbits(a, axis=1)\n    >>> b\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n    >>> c = np.unpackbits(a, axis=1, count=-3)\n    >>> c\n    array([[0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0]], dtype=uint8)\n\n    >>> p = np.packbits(b, axis=0)\n    >>> np.unpackbits(p, axis=0)\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n    >>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))\n    True\n\n    ","^0","^9"],["^ ","^7","union1d","^8","\n    Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. They are flattened if they are not already 1D.\n\n    Returns\n    -------\n    union1d : ndarray\n        Unique, sorted union of the input arrays.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.union1d([-1, 0, 1], [-2, 0, 2])\n    array([-2, -1,  0,  1,  2])\n\n    To find the union of more than two arrays, use functools.reduce:\n\n    >>> from functools import reduce\n    >>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\n    array([1, 2, 3, 4, 6])\n    ","^0","^9"],["^ ","^7","piecewise","^8","\n    Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.\n\n    Parameters\n    ----------\n    x : ndarray or scalar\n        The input domain.\n    condlist : list of bool arrays or bool scalars\n        Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) == len(condlist) + 1``, then that extra function\n        is the default value, used wherever all conditions are false.\n    funclist : list of callables, f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take a 1d array as input and give an 1d\n        array or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed.\n    args : tuple, optional\n        Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``.\n    kw : dict, optional\n        Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., alpha=1)``, then each function is called as\n        ``f(x, alpha=1)``.\n\n    Returns\n    -------\n    out : ndarray\n        The output is the same shape and type as x and is found by\n        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n        by any condition have a default value of 0.\n\n\n    See Also\n    --------\n    choose, select, where\n\n    Notes\n    -----\n    This is similar to choose or select, except that functions are\n    evaluated on elements of `x` that satisfy the corresponding condition from\n    `condlist`.\n\n    The result is::\n\n            |--\n            |funclist[0](x[condlist[0]])\n      out = |funclist[1](x[condlist[1]])\n            |...\n            |funclist[n2](x[condlist[n2]])\n            |--\n\n    Examples\n    --------\n    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n    >>> x = np.linspace(-2.5, 2.5, 6)\n    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\n    array([-1., -1., -1.,  1.,  1.,  1.])\n\n    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n    ``x >= 0``.\n\n    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\n    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n\n    Apply the same function to a scalar value.\n\n    >>> y = -2\n    >>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])\n    array(2)\n\n    ","^0","^9"],["^ ","^7","abs","^8","absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nabsolute : ndarray\n    An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\n\nPlot the function over ``[-10, 10]``:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\n\nPlot the function over the complex plane:\n\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()","^0","^;"],["^ ","^7","getbufsize","^8","\n    Return the size of the buffer used in ufuncs.\n\n    Returns\n    -------\n    getbufsize : int\n        Size of ufunc buffer in bytes.\n\n    ","^0","^9"],["^ ","^7","tril_indices_from","^8","\n    Return the indices for the lower-triangle of arr.\n\n    See `tril_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array_like\n        The indices will be valid for square arrays whose dimensions are\n        the same as arr.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    See Also\n    --------\n    tril_indices, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    ","^0","^9"],["^ ","^7","numpy._globals","^8","\nModule defining global singleton classes.\n\nThis module raises a RuntimeError if an attempt to reload it is made. In that\nway the identities of the classes defined here are fixed and will remain so\neven if numpy itself is reloaded. In particular, a function like the following\nwill still work correctly after numpy is reloaded::\n\n    def foo(arg=np._NoValue):\n        if arg is np._NoValue:\n            ...\n\nThat was not the case when the singleton classes were defined in the numpy\n``__init__.py`` file. See gh-7844 for a discussion of the reload problem that\nmotivated this module.\n\n","^0","^>"],["^ ","^7","conj","^8","conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the complex conjugate, element-wise.\n\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n----------\nx : array_like\n    Input value.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The complex conjugate of `x`, with same dtype as `y`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\n`conj` is an alias for `conjugate`:\n\n>>> np.conj is np.conjugate\nTrue\n\nExamples\n--------\n>>> np.conjugate(1+2j)\n(1-2j)\n\n>>> x = np.eye(2) + 1j * np.eye(2)\n>>> np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])","^0","^;"],["^ ","^7","argpartition","^8","\n    Perform an indirect partition along the given axis using the\n    algorithm specified by the `kind` keyword. It returns an array of\n    indices of the same shape as `a` that index data along the given\n    axis in partitioned order.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    kth : int or sequence of ints\n        Element index to partition by. The k-th element will be in its\n        final sorted position and all smaller elements will be moved\n        before it and all larger elements behind it. The order all\n        elements in the partitions is undefined. If provided with a\n        sequence of k-th it will partition all of them into their sorted\n        position at once.\n    axis : int or None, optional\n        Axis along which to sort. The default is -1 (the last axis). If\n        None, the flattened array is used.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument\n        specifies which fields to compare first, second, etc. A single\n        field can be specified as a string, and not all fields need be\n        specified, but unspecified fields will still be used, in the\n        order in which they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that partition `a` along the specified axis.\n        If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.\n        More generally, ``np.take_along_axis(a, index_array, axis=a)`` always\n        yields the partitioned `a`, irrespective of dimensionality.\n\n    See Also\n    --------\n    partition : Describes partition algorithms used.\n    ndarray.partition : Inplace partition.\n    argsort : Full indirect sort.\n    take_along_axis : Apply ``index_array`` from argpartition \n                      to an array as if by calling partition.\n\n    Notes\n    -----\n    See `partition` for notes on the different selection algorithms.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> x = np.array([3, 4, 2, 1])\n    >>> x[np.argpartition(x, 3)]\n    array([2, 1, 3, 4])\n    >>> x[np.argpartition(x, (1, 3))]\n    array([1, 2, 3, 4])\n\n    >>> x = [3, 4, 2, 1]\n    >>> np.array(x)[np.argpartition(x, 3)]\n    array([2, 1, 3, 4])\n\n    Multi-dimensional array:\n\n    >>> x = np.array([[3, 4, 2], [1, 3, 1]])\n    >>> index_array = np.argpartition(x, kth=1, axis=-1)\n    >>> np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)\n    array([[2, 3, 4],\n           [1, 1, 3]])\n\n    ","^0","^9"],["^ ","^7","show_config","^8",null,"^0","^9"],["^ ","^7","arange","^8","arange([start,] stop[, step,], dtype=None)\n\n    Return evenly spaced values within a given interval.\n\n    Values are generated within the half-open interval ``[start, stop)``\n    (in other words, the interval including `start` but excluding `stop`).\n    For integer arguments the function is equivalent to the Python built-in\n    `range` function, but returns an ndarray rather than a list.\n\n    When using a non-integer step, such as 0.1, the results will often not\n    be consistent.  It is better to use `numpy.linspace` for these cases.\n\n    Parameters\n    ----------\n    start : number, optional\n        Start of interval.  The interval includes this value.  The default\n        start value is 0.\n    stop : number\n        End of interval.  The interval does not include this value, except\n        in some cases where `step` is not an integer and floating point\n        round-off affects the length of `out`.\n    step : number, optional\n        Spacing between values.  For any output `out`, this is the distance\n        between two adjacent values, ``out[i+1] - out[i]``.  The default\n        step size is 1.  If `step` is specified as a position argument,\n        `start` must also be given.\n    dtype : dtype\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n    Returns\n    -------\n    arange : ndarray\n        Array of evenly spaced values.\n\n        For floating point arguments, the length of the result is\n        ``ceil((stop - start)/step)``.  Because of floating point overflow,\n        this rule may result in the last element of `out` being greater\n        than `stop`.\n\n    See Also\n    --------\n    numpy.linspace : Evenly spaced numbers with careful handling of endpoints.\n    numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.\n    numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.\n\n    Examples\n    --------\n    >>> np.arange(3)\n    array([0, 1, 2])\n    >>> np.arange(3.0)\n    array([ 0.,  1.,  2.])\n    >>> np.arange(3,7)\n    array([3, 4, 5, 6])\n    >>> np.arange(3,7,2)\n    array([3, 5])","^0","^?"],["^ ","^7","vander","^8","\n    Generate a Vandermonde matrix.\n\n    The columns of the output matrix are powers of the input vector. The\n    order of the powers is determined by the `increasing` boolean argument.\n    Specifically, when `increasing` is False, the `i`-th output column is\n    the input vector raised element-wise to the power of ``N - i - 1``. Such\n    a matrix with a geometric progression in each row is named for Alexandre-\n    Theophile Vandermonde.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D input array.\n    N : int, optional\n        Number of columns in the output.  If `N` is not specified, a square\n        array is returned (``N = len(x)``).\n    increasing : bool, optional\n        Order of the powers of the columns.  If True, the powers increase\n        from left to right, if False (the default) they are reversed.\n\n        .. versionadded:: 1.9.0\n\n    Returns\n    -------\n    out : ndarray\n        Vandermonde matrix.  If `increasing` is False, the first column is\n        ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is\n        True, the columns are ``x^0, x^1, ..., x^(N-1)``.\n\n    See Also\n    --------\n    polynomial.polynomial.polyvander\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3, 5])\n    >>> N = 3\n    >>> np.vander(x, N)\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> np.column_stack([x**(N-1-i) for i in range(N)])\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> x = np.array([1, 2, 3, 5])\n    >>> np.vander(x)\n    array([[  1,   1,   1,   1],\n           [  8,   4,   2,   1],\n           [ 27,   9,   3,   1],\n           [125,  25,   5,   1]])\n    >>> np.vander(x, increasing=True)\n    array([[  1,   1,   1,   1],\n           [  1,   2,   4,   8],\n           [  1,   3,   9,  27],\n           [  1,   5,  25, 125]])\n\n    The determinant of a square Vandermonde matrix is the product\n    of the differences between the values of the input vector:\n\n    >>> np.linalg.det(np.vander(x))\n    48.000000000000043 # may vary\n    >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n    48\n\n    ","^0","^9"],["^ ","^7","expm1","^8","expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate ``exp(x) - 1`` for all elements in the array.\n\nParameters\n----------\nx : array_like\n   Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Element-wise exponential minus one: ``out = exp(x) - 1``.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlog1p : ``log(1 + x)``, the inverse of expm1.\n\n\nNotes\n-----\nThis function provides greater precision than ``exp(x) - 1``\nfor small values of ``x``.\n\nExamples\n--------\nThe true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to\nabout 32 significant digits. This example shows the superiority of\nexpm1 in this case.\n\n>>> np.expm1(1e-10)\n1.00000000005e-10\n>>> np.exp(1e-10) - 1\n1.000000082740371e-10","^0","^;"],["^ ","^7","binary_repr","^8","\n    Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, or the length\n        of the two's complement if `num` is negative, provided that `width` is\n        at least a sufficient number of bits for `num` to be represented in the\n        designated form.\n\n        If the `width` value is insufficient, it will be ignored, and `num` will\n        be returned in binary (`num` > 0) or two's complement (`num` < 0) form\n        with its width equal to the minimum number of bits needed to represent\n        the number in the designated form. This behavior is deprecated and will\n        later raise an error.\n\n        .. deprecated:: 1.12.0\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n    bin: Python's built-in binary representation generator of an integer.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        https://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=3)\n    '101'\n    >>> np.binary_repr(-3, width=5)\n    '11101'\n\n    ","^0","^9"],["^ ","^7","double","^8","Double-precision floating-point number type, compatible with Python `float`\n    and C ``double``.\n    Character code: ``'d'``.\n    Canonical name: ``np.double``.\n    Alias: ``np.float_``.\n    Alias *on this platform*: ``np.float64``: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.","^0","^0"],["^ ","^7","vstack","^8","\n    Stack arrays in sequence vertically (row wise).\n\n    This is equivalent to concatenation along the first axis after 1-D arrays\n    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n    `vsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        The arrays must have the same shape along all but the first axis.\n        1-D arrays must have the same length.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays, will be at least 2-D.\n\n    See Also\n    --------\n    stack : Join a sequence of arrays along a new axis.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays along an existing axis.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n    block : Assemble arrays from blocks.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n\n    ","^0","^9"],["^ ","^7","numpy.version","^8",null,"^0","^>"],["^ ","^7","argwhere","^8","\n    Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : (N, a.ndim) ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n        This array will have shape ``(N, a.ndim)`` where ``N`` is the number of\n        non-zero items.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,\n    but produces a result of the correct shape for a 0D array.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``nonzero(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n\n    ","^0","^9"],["^ ","^7","iterable","^8","\n    Check whether or not an object can be iterated over.\n\n    Parameters\n    ----------\n    y : object\n      Input object.\n\n    Returns\n    -------\n    b : bool\n      Return ``True`` if the object has an iterator method or is a\n      sequence and ``False`` otherwise.\n\n\n    Examples\n    --------\n    >>> np.iterable([1, 2, 3])\n    True\n    >>> np.iterable(2)\n    False\n\n    ","^0","^9"],["^ ","^7","_add_newdoc_ufunc","^8","add_ufunc_docstring(ufunc, new_docstring)\n\n    Replace the docstring for a ufunc with new_docstring.\n    This method will only work if the current docstring for\n    the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)\n\n    Parameters\n    ----------\n    ufunc : numpy.ufunc\n        A ufunc whose current doc is NULL.\n    new_docstring : string\n        The new docstring for the ufunc.\n\n    Notes\n    -----\n    This method allocates memory for new_docstring on\n    the heap. Technically this creates a mempory leak, since this\n    memory will not be reclaimed until the end of the program\n    even if the ufunc itself is removed. However this will only\n    be a problem if the user is repeatedly creating ufuncs with\n    no documentation, adding documentation via add_newdoc_ufunc,\n    and then throwing away the ufunc.","^0","^?"],["^ ","^7","append","^8","\n    Append values to the end of an array.\n\n    Parameters\n    ----------\n    arr : array_like\n        Values are appended to a copy of this array.\n    values : array_like\n        These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If\n        `axis` is not specified, `values` can be any shape and will be\n        flattened before use.\n    axis : int, optional\n        The axis along which `values` are appended.  If `axis` is not\n        given, both `arr` and `values` are flattened before use.\n\n    Returns\n    -------\n    append : ndarray\n        A copy of `arr` with `values` appended to `axis`.  Note that\n        `append` does not occur in-place: a new array is allocated and\n        filled.  If `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\n    array([1, 2, 3, ..., 7, 8, 9])\n\n    When `axis` is specified, `values` must have the correct shape.\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\n    array([[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]])\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: all the input arrays must have same number of dimensions\n\n    ","^0","^9"],["^ ","^7","iinfo","^8","\n    iinfo(type)\n\n    Machine limits for integer types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    min : int\n        The smallest integer expressible by the type.\n    max : int\n        The largest integer expressible by the type.\n\n    Parameters\n    ----------\n    int_type : integer type, dtype, or instance\n        The kind of integer data type to get information about.\n\n    See Also\n    --------\n    finfo : The equivalent for floating point data types.\n\n    Examples\n    --------\n    With types:\n\n    >>> ii16 = np.iinfo(np.int16)\n    >>> ii16.min\n    -32768\n    >>> ii16.max\n    32767\n    >>> ii32 = np.iinfo(np.int32)\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    With instances:\n\n    >>> ii32 = np.iinfo(np.int32(10))\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    ","^0","^0"],["^ ","^7","ones_like","^8","\n    Return an array of ones with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n\n        .. versionadded:: 1.6.0\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n\n        .. versionadded:: 1.6.0\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of 'a', otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of ones with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    ones : Return a new array setting values to one.\n\n    Examples\n    --------\n    >>> x = np.arange(6)\n    >>> x = x.reshape((2, 3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.ones_like(x)\n    array([[1, 1, 1],\n           [1, 1, 1]])\n\n    >>> y = np.arange(3, dtype=float)\n    >>> y\n    array([0., 1., 2.])\n    >>> np.ones_like(y)\n    array([1.,  1.,  1.])\n\n    ","^0","^9"],["^ ","^7","full_like","^8","\n    Return a full array with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    fill_value : scalar\n        Fill value.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of 'a', otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of `fill_value` with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full : Return a new array of given shape filled with value.\n\n    Examples\n    --------\n    >>> x = np.arange(6, dtype=int)\n    >>> np.full_like(x, 1)\n    array([1, 1, 1, 1, 1, 1])\n    >>> np.full_like(x, 0.1)\n    array([0, 0, 0, 0, 0, 0])\n    >>> np.full_like(x, 0.1, dtype=np.double)\n    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n    >>> np.full_like(x, np.nan, dtype=np.double)\n    array([nan, nan, nan, nan, nan, nan])\n\n    >>> y = np.arange(6, dtype=np.double)\n    >>> np.full_like(y, 0.1)\n    array([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\n\n    ","^0","^9"],["^ ","^7","atleast_1d","^8","\n    Convert inputs to arrays with at least one dimension.\n\n    Scalar inputs are converted to 1-dimensional arrays, whilst\n    higher-dimensional inputs are preserved.\n\n    Parameters\n    ----------\n    arys1, arys2, ... : array_like\n        One or more input arrays.\n\n    Returns\n    -------\n    ret : ndarray\n        An array, or list of arrays, each with ``a.ndim >= 1``.\n        Copies are made only if necessary.\n\n    See Also\n    --------\n    atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_1d(1.0)\n    array([1.])\n\n    >>> x = np.arange(9.0).reshape(3,3)\n    >>> np.atleast_1d(x)\n    array([[0., 1., 2.],\n           [3., 4., 5.],\n           [6., 7., 8.]])\n    >>> np.atleast_1d(x) is x\n    True\n\n    >>> np.atleast_1d(1, [3, 4])\n    [array([1]), array([3, 4])]\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","asanyarray","^8","Convert the input to an ndarray, but pass ndarray subclasses through.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes scalars, lists, lists of tuples, tuples, tuples of tuples,\n        tuples of lists, and ndarrays.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major (C-style) or column-major\n        (Fortran-style) memory representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray or an ndarray subclass\n        Array interpretation of `a`.  If `a` is an ndarray or a subclass\n        of ndarray, it is returned as-is and no copy is performed.\n\n    See Also\n    --------\n    asarray : Similar function which always returns ndarrays.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    asarray_chkfinite : Similar function which checks input for NaNs and\n                        Infs.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array:\n\n    >>> a = [1, 2]\n    >>> np.asanyarray(a)\n    array([1, 2])\n\n    Instances of `ndarray` subclasses are passed through as-is:\n\n    >>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n    >>> np.asanyarray(a) is a\n    True\n\n    ","^0","^9"],["^ ","^7","lookfor","^8","\n    Do a keyword search on docstrings.\n\n    A list of objects that matched the search is displayed,\n    sorted by relevance. All given keywords need to be found in the\n    docstring for it to be returned as a result, but the order does\n    not matter.\n\n    Parameters\n    ----------\n    what : str\n        String containing words to look for.\n    module : str or list, optional\n        Name of module(s) whose docstrings to go through.\n    import_modules : bool, optional\n        Whether to import sub-modules in packages. Default is True.\n    regenerate : bool, optional\n        Whether to re-generate the docstring cache. Default is False.\n    output : file-like, optional\n        File-like object to write the output to. If omitted, use a pager.\n\n    See Also\n    --------\n    source, info\n\n    Notes\n    -----\n    Relevance is determined only roughly, by checking if the keywords occur\n    in the function name, at the start of a docstring, etc.\n\n    Examples\n    --------\n    >>> np.lookfor('binary representation') # doctest: +SKIP\n    Search results for 'binary representation'\n    ------------------------------------------\n    numpy.binary_repr\n        Return the binary representation of the input number as a string.\n    numpy.core.setup_common.long_double_representation\n        Given a binary dump as given by GNU od -b, look for long double\n    numpy.base_repr\n        Return a string representation of a number in the given base system.\n    ...\n\n    ","^0","^9"],["^ ","^7","divide","^8","true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns a true division of the inputs, element-wise.\n\nInstead of the Python traditional 'floor division', this returns a true\ndivision.  True division adjusts the output type to present the best\nanswer, regardless of input types.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nThe floor division operator ``//`` was added in Python 2.2 making\n``//`` and ``/`` equivalent operators.  The default floor division\noperation of ``/`` can be replaced by true division with ``from\n__future__ import division``.\n\nIn Python 3.0, ``//`` is the floor division operator and ``/`` the\ntrue division operator.  The ``true_divide(x1, x2)`` function is\nequivalent to true division in Python.\n\nExamples\n--------\n>>> x = np.arange(5)\n>>> np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n>>> x//4\narray([0, 0, 0, 0, 1])\n\n>>> from __future__ import division\n>>> x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n>>> x//4\narray([0, 0, 0, 0, 1])","^0","^;"],["^ ","^7","trim_zeros","^8","\n    Trim the leading and/or trailing zeros from a 1-D array or sequence.\n\n    Parameters\n    ----------\n    filt : 1-D array or sequence\n        Input array.\n    trim : str, optional\n        A string with 'f' representing trim from front and 'b' to trim from\n        back. Default is 'fb', trim zeros from both front and back of the\n        array.\n\n    Returns\n    -------\n    trimmed : 1-D array or sequence\n        The result of trimming the input. The input data type is preserved.\n\n    Examples\n    --------\n    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n    >>> np.trim_zeros(a)\n    array([1, 2, 3, 0, 2, 1])\n\n    >>> np.trim_zeros(a, 'b')\n    array([0, 0, 0, ..., 0, 2, 1])\n\n    The input data type is preserved, list/tuple in means list/tuple out.\n\n    >>> np.trim_zeros([0, 1, 2, 0])\n    [1, 2]\n\n    ","^0","^9"],["^ ","^7","insert","^8","\n    Insert values along the given axis before the given indices.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : int, slice or sequence of ints\n        Object that defines the index or indices before which `values` is\n        inserted.\n\n        .. versionadded:: 1.8.0\n\n        Support for multiple insertions when `obj` is a single scalar or a\n        sequence with one element (similar to calling insert multiple\n        times).\n    values : array_like\n        Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n        `values` should be shaped so that ``arr[...,obj,...] = values``\n        is legal.\n    axis : int, optional\n        Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` inserted.  Note that `insert`\n        does not occur in-place: a new array is returned. If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    append : Append elements at the end of an array.\n    concatenate : Join a sequence of arrays along an existing axis.\n    delete : Delete elements from an array.\n\n    Notes\n    -----\n    Note that for higher dimensional inserts `obj=0` behaves very different\n    from `obj=[0]` just like `arr[:,0,:] = values` is different from\n    `arr[:,[0],:] = values`.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 1], [2, 2], [3, 3]])\n    >>> a\n    array([[1, 1],\n           [2, 2],\n           [3, 3]])\n    >>> np.insert(a, 1, 5)\n    array([1, 5, 1, ..., 2, 3, 3])\n    >>> np.insert(a, 1, 5, axis=1)\n    array([[1, 5, 1],\n           [2, 5, 2],\n           [3, 5, 3]])\n\n    Difference between sequence and scalars:\n\n    >>> np.insert(a, [1], [[1],[2],[3]], axis=1)\n    array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])\n    >>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),\n    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))\n    True\n\n    >>> b = a.flatten()\n    >>> b\n    array([1, 1, 2, 2, 3, 3])\n    >>> np.insert(b, [2, 2], [5, 6])\n    array([1, 1, 5, ..., 2, 3, 3])\n\n    >>> np.insert(b, slice(2, 4), [5, 6])\n    array([1, 1, 5, ..., 2, 3, 3])\n\n    >>> np.insert(b, [2, 2], [7.13, False]) # type casting\n    array([1, 1, 7, ..., 2, 3, 3])\n\n    >>> x = np.arange(8).reshape(2, 4)\n    >>> idx = (1, 3)\n    >>> np.insert(x, idx, 999, axis=1)\n    array([[  0, 999,   1,   2, 999,   3],\n           [  4, 999,   5,   6, 999,   7]])\n\n    ","^0","^9"],["^ ","^8","","^0","^="],["^ ","^7","compare_chararrays","^8","compare_chararrays(a, b, cmp_op, rstrip)\n\n    Performs element-wise comparison of two string arrays using the\n    comparison operator specified by `cmp_op`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Arrays to be compared.\n    cmp_op : {\"<\", \"<=\", \"==\", \">=\", \">\", \"!=\"}\n        Type of comparison.\n    rstrip : Boolean\n        If True, the spaces at the end of Strings are removed before the comparison.\n\n    Returns\n    -------\n    out : ndarray\n        The output array of type Boolean with the same shape as a and b.\n\n    Raises\n    ------\n    ValueError\n        If `cmp_op` is not valid.\n    TypeError\n        If at least one of `a` or `b` is a non-string array\n\n    Examples\n    --------\n    >>> a = np.array([\"a\", \"b\", \"cde\"])\n    >>> b = np.array([\"a\", \"a\", \"dec\"])\n    >>> np.compare_chararrays(a, b, \">\", True)\n    array([False,  True, False])","^0","^?"],["^ ","^8","","^0","^="],["^ ","^7","array_repr","^8","\n    Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([0.000001,  0.      ,  2.      ,  3.      ])'\n\n    ","^0","^9"],["^ ","^7","issubsctype","^8","\n    Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype, obj2sctype\n\n    Examples\n    --------\n    >>> np.issubsctype('S8', str)\n    False\n    >>> np.issubsctype(np.array([1]), int)\n    True\n    >>> np.issubsctype(np.array([1]), float)\n    False\n\n    ","^0","^9"],["^ ","^8","","^0","^:"],["^ ","^8","Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.","^0","~:tuple"],["^ ","^7","dstack","^8","\n    Stack arrays in sequence depth wise (along third axis).\n\n    This is equivalent to concatenation along the third axis after 2-D arrays\n    of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape\n    `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by\n    `dsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    Parameters\n    ----------\n    tup : sequence of arrays\n        The arrays must have the same shape along all but the third axis.\n        1-D or 2-D arrays must have the same shape.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays, will be at least 3-D.\n\n    See Also\n    --------\n    stack : Join a sequence of arrays along a new axis.\n    vstack : Stack along first axis.\n    hstack : Stack along second axis.\n    concatenate : Join a sequence of arrays along an existing axis.\n    dsplit : Split array along third axis.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.dstack((a,b))\n    array([[[1, 2],\n            [2, 3],\n            [3, 4]]])\n\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.dstack((a,b))\n    array([[[1, 2]],\n           [[2, 3]],\n           [[3, 4]]])\n\n    ","^0","^9"],["^ ","^8","\n    `nd_grid` instance which returns an open multi-dimensional \"meshgrid\".\n\n    An instance of `numpy.lib.index_tricks.nd_grid` which returns an open\n    (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension\n    of each returned array is greater than 1.  The dimension and number of the\n    output arrays are equal to the number of indexing dimensions.  If the step\n    length is not a complex number, then the stop is not inclusive.\n\n    However, if the step length is a **complex number** (e.g. 5j), then\n    the integer part of its magnitude is interpreted as specifying the\n    number of points to create between the start and stop values, where\n    the stop value **is inclusive**.\n\n    Returns\n    -------\n    mesh-grid\n        `ndarrays` with only one dimension not equal to 1\n\n    See Also\n    --------\n    np.lib.index_tricks.nd_grid : class of `ogrid` and `mgrid` objects\n    mgrid : like `ogrid` but returns dense (or fleshed out) mesh grids\n    r_ : array concatenator\n\n    Examples\n    --------\n    >>> from numpy import ogrid\n    >>> ogrid[-1:1:5j]\n    array([-1. , -0.5,  0. ,  0.5,  1. ])\n    >>> ogrid[0:5,0:5]\n    [array([[0],\n            [1],\n            [2],\n            [3],\n            [4]]), array([[0, 1, 2, 3, 4]])]\n\n    ","^0","~:o-grid-class"],["^ ","^7","isposinf","^8","\n    Test element-wise for positive infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape as `x` to store the result.\n\n    Returns\n    -------\n    out : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input is\n        not positive infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as zeros\n        and ones, if the type is boolean then as False and True.\n        The return value `out` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, if first and second arguments have different shapes, or if the\n    first argument has complex values\n\n    Examples\n    --------\n    >>> np.isposinf(np.PINF)\n    True\n    >>> np.isposinf(np.inf)\n    True\n    >>> np.isposinf(np.NINF)\n    False\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True])\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n\n    ","^0","^9"],["^ ","^7","exp2","^8","exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate `2**p` for all `p` in the input array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Element-wise 2 to the power `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\npower\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\n\n\nExamples\n--------\n>>> np.exp2([2, 3])\narray([ 4.,  8.])","^0","^;"],["^ ","^7","roll","^8","\n    Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int or tuple of ints\n        The number of places by which elements are shifted.  If a tuple,\n        then `axis` must be a tuple of the same size, and each of the\n        given axes is shifted by the corresponding number.  If an int\n        while `axis` is a tuple of ints, then the same value is used for\n        all given axes.\n    axis : int or tuple of ints, optional\n        Axis or axes along which elements are shifted.  By default, the\n        array is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Notes\n    -----\n    .. versionadded:: 1.12.0\n\n    Supports rolling over multiple dimensions simultaneously.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n    >>> np.roll(x, -2)\n    array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n\n    >>> x2 = np.reshape(x, (2,5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, -1)\n    array([[1, 2, 3, 4, 5],\n           [6, 7, 8, 9, 0]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, -1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    >>> np.roll(x2, -1, axis=1)\n    array([[1, 2, 3, 4, 0],\n           [6, 7, 8, 9, 5]])\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","asarray","^8","Convert the input to an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major (C-style) or\n        column-major (Fortran-style) memory representation.\n        Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray with matching dtype and order.  If `a` is a\n        subclass of ndarray, a base class ndarray is returned.\n\n    See Also\n    --------\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    asarray_chkfinite : Similar function which checks input for NaNs and Infs.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array:\n\n    >>> a = [1, 2]\n    >>> np.asarray(a)\n    array([1, 2])\n\n    Existing arrays are not copied:\n\n    >>> a = np.array([1, 2])\n    >>> np.asarray(a) is a\n    True\n\n    If `dtype` is set, array is copied only if dtype does not match:\n\n    >>> a = np.array([1, 2], dtype=np.float32)\n    >>> np.asarray(a, dtype=np.float32) is a\n    True\n    >>> np.asarray(a, dtype=np.float64) is a\n    False\n\n    Contrary to `asanyarray`, ndarray subclasses are not passed through:\n\n    >>> issubclass(np.recarray, np.ndarray)\n    True\n    >>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n    >>> np.asarray(a) is a\n    False\n    >>> np.asanyarray(a) is a\n    True\n\n    ","^0","^9"],["^ ","^7","fastCopyAndTranspose","^8","_fastCopyAndTranspose(a)","^0","^?"],["^ ","^8","","^0","^="],["^ ","^7","isclose","^8","\n    Returns a boolean array where two arrays are element-wise equal within a\n    tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 that are much smaller than one (see Notes).\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n    Returns\n    -------\n    y : array_like\n        Returns a boolean array of where `a` and `b` are equal within the\n        given tolerance. If both `a` and `b` are scalars, returns a single\n        boolean value.\n\n    See Also\n    --------\n    allclose\n\n    Notes\n    -----\n    .. versionadded:: 1.7.0\n\n    For finite values, isclose uses the following equation to test whether\n    two floating point values are equivalent.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    Unlike the built-in `math.isclose`, the above equation is not symmetric\n    in `a` and `b` -- it assumes `b` is the reference value -- so that\n    `isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,\n    the default value of atol is not zero, and is used to determine what\n    small values should be considered close to zero. The default value is\n    appropriate for expected values of order unity: if the expected values\n    are significantly smaller than one, it can result in false positives.\n    `atol` should be carefully selected for the use case at hand. A zero value\n    for `atol` will result in `False` if either `a` or `b` is zero.\n\n    Examples\n    --------\n    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\n    array([ True, False])\n    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\n    array([ True, True])\n    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\n    array([False,  True])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan])\n    array([ True, False])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    array([ True, True])\n    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])\n    array([ True, False])\n    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\n    array([False, False])\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])\n    array([ True,  True])\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\n    array([False,  True])\n    ","^0","^9"],["^ ","^7","bitwise_not","^8","invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``~``.\n\nFor signed integer inputs, the two's complement is returned.  In a\ntwo's-complement system negative numbers are represented by the two's\ncomplement of the absolute value. This is the most common method of\nrepresenting signed integers on computers [1]_. A N-bit\ntwo's-complement system can represent every integer in the range\n:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\nParameters\n----------\nx : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nbitwise_and, bitwise_or, bitwise_xor\nlogical_not\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nNotes\n-----\n`bitwise_not` is an alias for `invert`:\n\n>>> np.bitwise_not is np.invert\nTrue\n\nReferences\n----------\n.. [1] Wikipedia, \"Two's complement\",\n    https://en.wikipedia.org/wiki/Two's_complement\n\nExamples\n--------\nWe've seen that 13 is represented by ``00001101``.\nThe invert or bit-wise NOT of 13 is then:\n\n>>> x = np.invert(np.array(13, dtype=np.uint8))\n>>> x\n242\n>>> np.binary_repr(x, width=8)\n'11110010'\n\nThe result depends on the bit-width:\n\n>>> x = np.invert(np.array(13, dtype=np.uint16))\n>>> x\n65522\n>>> np.binary_repr(x, width=16)\n'1111111111110010'\n\nWhen using signed integer types the result is the two's complement of\nthe result for the unsigned type:\n\n>>> np.invert(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n>>> np.binary_repr(-14, width=8)\n'11110010'\n\nBooleans are accepted as well:\n\n>>> np.invert(np.array([True, False]))\narray([False,  True])","^0","^;"],["^ ","^7","int0","^8","Signed integer type, compatible with Python `int` anc C ``long``.\n    Character code: ``'l'``.\n    Canonical name: ``np.int_``.\n    Alias *on this platform*: ``np.int64``: 64-bit signed integer (-9223372036854775808 to 9223372036854775807).\n    Alias *on this platform*: ``np.intp``: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.","^0","^0"],["^ ","^7","ldexp","^8","ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns x1 * 2**x2, element-wise.\n\nThe mantissas `x1` and twos exponents `x2` are used to construct\nfloating point numbers ``x1 * 2**x2``.\n\nParameters\n----------\nx1 : array_like\n    Array of multipliers.\nx2 : array_like, int\n    Array of twos exponents. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The result of ``x1 * 2**x2``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfrexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.\n\nNotes\n-----\nComplex dtypes are not supported, they will raise a TypeError.\n\n`ldexp` is useful as the inverse of `frexp`, if used by itself it is\nmore clear to simply use the expression ``x1 * 2**x2``.\n\nExamples\n--------\n>>> np.ldexp(5, np.arange(4))\narray([ 5., 10., 20., 40.], dtype=float16)\n\n>>> x = np.arange(6)\n>>> np.ldexp(*np.frexp(x))\narray([ 0.,  1.,  2.,  3.,  4.,  5.])","^0","^;"],["^ ","^7","around","^8","\n    Evenly round to the given number of decimals.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    decimals : int, optional\n        Number of decimal places to round to (default: 0).  If\n        decimals is negative, it specifies the number of positions to\n        the left of the decimal point.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary. See `ufuncs-output-type` for more\n        details.\n\n    Returns\n    -------\n    rounded_array : ndarray\n        An array of the same type as `a`, containing the rounded values.\n        Unless `out` was specified, a new array is created.  A reference to\n        the result is returned.\n\n        The real and imaginary parts of complex numbers are rounded\n        separately.  The result of rounding a float is a float.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n\n    ceil, fix, floor, rint, trunc\n\n\n    Notes\n    -----\n    For values exactly halfway between rounded decimal values, NumPy\n    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n    -0.5 and 0.5 round to 0.0, etc.\n\n    ``np.around`` uses a fast but sometimes inexact algorithm to round\n    floating-point datatypes. For positive `decimals` it is equivalent to\n    ``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has\n    error due to the inexact representation of decimal fractions in the IEEE\n    floating point standard [1]_ and errors introduced when scaling by powers\n    of ten. For instance, note the extra \"1\" in the following:\n\n        >>> np.round(56294995342131.5, 3)\n        56294995342131.51\n\n    If your goal is to print such values with a fixed number of decimals, it is\n    preferable to use numpy's float printing routines to limit the number of\n    printed decimals:\n\n        >>> np.format_float_positional(56294995342131.5, precision=3)\n        '56294995342131.5'\n\n    The float printing routines use an accurate but much more computationally\n    demanding algorithm to compute the number of digits after the decimal\n    point.\n\n    Alternatively, Python's builtin `round` function uses a more accurate\n    but slower algorithm for 64-bit floating point values:\n\n        >>> round(56294995342131.5, 3)\n        56294995342131.5\n        >>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997\n        (16.06, 16.05)\n\n\n    References\n    ----------\n    .. [1] \"Lecture Notes on the Status of IEEE 754\", William Kahan,\n           https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n    .. [2] \"How Futile are Mindless Assessments of\n           Roundoff in Floating-Point Computation?\", William Kahan,\n           https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf\n\n    Examples\n    --------\n    >>> np.around([0.37, 1.64])\n    array([0.,  2.])\n    >>> np.around([0.37, 1.64], decimals=1)\n    array([0.4,  1.6])\n    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\n    array([0.,  2.,  2.,  4.,  4.])\n    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\n    array([ 1,  2,  3, 11])\n    >>> np.around([1,2,3,11], decimals=-1)\n    array([ 0,  0,  0, 10])\n\n    ","^0","^9"],["^ ","^7","convolve","^8","\n    Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    If `v` is longer than `a`, the arrays are swapped before computation.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode 'same' returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode 'valid' returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n    polymul : Polynomial multiplication. Same output as convolve, but also\n              accepts poly1d objects as input.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (a * v)[n] = \\sum_{m = -\\infty}^{\\infty} a[m] v[n - m]\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\",\n        https://en.wikipedia.org/wiki/Convolution\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([0. , 1. , 2.5, 4. , 1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([2.5])\n\n    ","^0","^9"],["^ ","^7","round_","^8","\n    Round an array to the given number of decimals.\n\n    See Also\n    --------\n    around : equivalent function; see for details.\n    ","^0","^9"],["^ ","^7","add","^8","add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nAdd arguments element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nadd : ndarray or scalar\n    The sum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nEquivalent to `x1` + `x2` in terms of array broadcasting.\n\nExamples\n--------\n>>> np.add(1.0, 4.0)\n5.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])","^0","^;"],["^ ","^7","base_repr","^8","\n    Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Positive and negative values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n\n    ","^0","^9"],["^ ","^7","mafromtxt","^8","\n    Load ASCII data stored in a text file and return a masked array.\n\n    .. deprecated:: 1.17\n        np.mafromtxt is a deprecated alias of `genfromtxt` which\n        overwrites the ``usemask`` argument with `True` even when\n        explicitly called as ``mafromtxt(..., usemask=False)``.\n        Use `genfromtxt` instead.\n\n    Parameters\n    ----------\n    fname, kwargs : For a description of input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function to load ASCII data.\n\n    ","^0","^9"],["^ ","^7","nanstd","^8","\n    Compute the standard deviation along the specified axis, while\n    ignoring NaNs.\n\n    Returns the standard deviation, a measure of the spread of a\n    distribution, of the non-NaN array elements. The standard deviation is\n    computed for the flattened array by default, otherwise over the\n    specified axis.\n\n    For all-NaN slices or slices with zero degrees of freedom, NaN is\n    returned and a `RuntimeWarning` is raised.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of the non-NaN values.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the standard deviation is computed. The default is\n        to compute the standard deviation of the flattened array.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it\n        is the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the\n        calculated values) will be cast if necessary.\n    ddof : int, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of non-NaN\n        elements.  By default `ddof` is zero.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If this value is anything but the default it is passed through\n        as-is to the relevant functions of the sub-classes.  If these\n        functions do not have a `keepdims` kwarg, a RuntimeError will\n        be raised.\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard\n        deviation, otherwise return a reference to the output array. If\n        ddof is >= the number of non-NaN elements in a slice or the slice\n        contains only NaNs, then the result for that slice is NaN.\n\n    See Also\n    --------\n    var, mean, std\n    nanvar, nanmean\n    ufuncs-output-type\n\n    Notes\n    -----\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.\n\n    The average squared deviation is normally calculated as\n    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is\n    specified, the divisor ``N - ddof`` is used instead. In standard\n    statistical practice, ``ddof=1`` provides an unbiased estimator of the\n    variance of the infinite population. ``ddof=0`` provides a maximum\n    likelihood estimate of the variance for normally distributed variables.\n    The standard deviation computed in this function is the square root of\n    the estimated variance, so even with ``ddof=1``, it will not be an\n    unbiased estimate of the standard deviation per se.\n\n    Note that, for complex numbers, `std` takes the absolute value before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the *std* is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example\n    below).  Specifying a higher-accuracy accumulator using the `dtype`\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, np.nan], [3, 4]])\n    >>> np.nanstd(a)\n    1.247219128924647\n    >>> np.nanstd(a, axis=0)\n    array([1., 0.])\n    >>> np.nanstd(a, axis=1)\n    array([0.,  0.5]) # may vary\n\n    ","^0","^9"],["^ ","^7","single","^8","Single-precision floating-point number type, compatible with C ``float``.\n    Character code: ``'f'``.\n    Canonical name: ``np.single``.\n    Alias *on this platform*: ``np.float32``: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.","^0","^0"],["^ ","^7","inner","^8","\n    inner(a, b)\n\n    Inner product of two arrays.\n\n    Ordinary inner product of vectors for 1-D arrays (without complex\n    conjugation), in higher dimensions a sum product over the last axes.\n\n    Parameters\n    ----------\n    a, b : array_like\n        If `a` and `b` are nonscalar, their last dimensions must match.\n\n    Returns\n    -------\n    out : ndarray\n        `out.shape = a.shape[:-1] + b.shape[:-1]`\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` and `b` has different size.\n\n    See Also\n    --------\n    tensordot : Sum products over arbitrary axes.\n    dot : Generalised matrix product, using second last dimension of `b`.\n    einsum : Einstein summation convention.\n\n    Notes\n    -----\n    For vectors (1-D arrays) it computes the ordinary inner-product::\n\n        np.inner(a, b) = sum(a[:]*b[:])\n\n    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::\n\n        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n    or explicitly::\n\n        np.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n             = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n    In addition `a` or `b` may be scalars, in which case::\n\n       np.inner(a,b) = a*b\n\n    Examples\n    --------\n    Ordinary inner product for vectors:\n\n    >>> a = np.array([1,2,3])\n    >>> b = np.array([0,1,0])\n    >>> np.inner(a, b)\n    2\n\n    A multidimensional example:\n\n    >>> a = np.arange(24).reshape((2,3,4))\n    >>> b = np.arange(4)\n    >>> np.inner(a, b)\n    array([[ 14,  38,  62],\n           [ 86, 110, 134]])\n\n    An example where `b` is a scalar:\n\n    >>> np.inner(np.eye(2), 7)\n    array([[7., 0.],\n           [0., 7.]])\n\n    ","^0","^9"],["^ ","^7","column_stack","^8","\n    Stack 1-D arrays as columns into a 2-D array.\n\n    Take a sequence of 1-D arrays and stack them as columns\n    to make a single 2-D array. 2-D arrays are stacked as-is,\n    just like with `hstack`.  1-D arrays are turned into 2-D columns\n    first.\n\n    Parameters\n    ----------\n    tup : sequence of 1-D or 2-D arrays.\n        Arrays to stack. All of them must have the same first dimension.\n\n    Returns\n    -------\n    stacked : 2-D array\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    stack, hstack, vstack, concatenate\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.column_stack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n\n    ","^0","^9"],["^ ","^7","cov","^8","\n    Estimate a covariance matrix, given data and weights.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    See the notes for an outline of the algorithm.\n\n    Parameters\n    ----------\n    m : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same form\n        as that of `m`.\n    rowvar : bool, optional\n        If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : bool, optional\n        Default normalization (False) is by ``(N - 1)``, where ``N`` is the\n        number of observations given (unbiased estimate). If `bias` is True,\n        then normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : int, optional\n        If not ``None`` the default value implied by `bias` is overridden.\n        Note that ``ddof=1`` will return the unbiased estimate, even if both\n        `fweights` and `aweights` are specified, and ``ddof=0`` will return\n        the simple average. See the notes for the details. The default value\n        is ``None``.\n\n        .. versionadded:: 1.5\n    fweights : array_like, int, optional\n        1-D array of integer frequency weights; the number of times each\n        observation vector should be repeated.\n\n        .. versionadded:: 1.10\n    aweights : array_like, optional\n        1-D array of observation vector weights. These relative weights are\n        typically large for observations considered \"important\" and smaller for\n        observations considered less \"important\". If ``ddof=0`` the array of\n        weights can be used to assign probabilities to observation vectors.\n\n        .. versionadded:: 1.10\n\n    Returns\n    -------\n    out : ndarray\n        The covariance matrix of the variables.\n\n    See Also\n    --------\n    corrcoef : Normalized covariance matrix\n\n    Notes\n    -----\n    Assume that the observations are in the columns of the observation\n    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The\n    steps to compute the weighted covariance are as follows::\n\n        >>> m = np.arange(10, dtype=np.float64)\n        >>> f = np.arange(10) * 2\n        >>> a = np.arange(10) ** 2.\n        >>> ddof = 1\n        >>> w = f * a\n        >>> v1 = np.sum(w)\n        >>> v2 = np.sum(w * a)\n        >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1\n        >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)\n\n    Note that when ``a == 1``, the normalization factor\n    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``\n    as it should.\n\n    Examples\n    --------\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n    >>> x\n    array([[0, 1, 2],\n           [2, 1, 0]])\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> np.cov(x)\n    array([[ 1., -1.],\n           [-1.,  1.]])\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = [-2.1, -1,  4.3]\n    >>> y = [3,  1.1,  0.12]\n    >>> X = np.stack((x, y), axis=0)\n    >>> np.cov(X)\n    array([[11.71      , -4.286     ], # may vary\n           [-4.286     ,  2.144133]])\n    >>> np.cov(x, y)\n    array([[11.71      , -4.286     ], # may vary\n           [-4.286     ,  2.144133]])\n    >>> np.cov(x)\n    array(11.71)\n\n    ","^0","^9"],["^ ","^7","geterrcall","^8","\n    Return the current callback function used on floating-point errors.\n\n    When the error handling for a floating-point error (one of \"divide\",\n    \"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\n    that is called or the log instance that is written to is returned by\n    `geterrcall`. This function or log instance has been set with\n    `seterrcall`.\n\n    Returns\n    -------\n    errobj : callable, log instance or None\n        The current error handler. If no handler was set through `seterrcall`,\n        ``None`` is returned.\n\n    See Also\n    --------\n    seterrcall, seterr, geterr\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrcall()  # we did not yet set a handler, returns None\n\n    >>> oldsettings = np.seterr(all='call')\n    >>> def err_handler(type, flag):\n    ...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n    >>> oldhandler = np.seterrcall(err_handler)\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([inf, inf, inf])\n\n    >>> cur_handler = np.geterrcall()\n    >>> cur_handler is err_handler\n    True\n\n    ","^0","^9"],["^ ","^7","signbit","^8","signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns element-wise True where signbit is set (less than zero).\n\nParameters\n----------\nx : array_like\n    The input value(s).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nresult : ndarray of bool\n    Output array, or reference to `out` if that was supplied.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.signbit(-1.2)\nTrue\n>>> np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False])","^0","^;"],["^ ","^7","amax","^8","\n    Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to operate.  By default, flattened input is\n        used.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, the maximum is selected over multiple axes,\n        instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `amax` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    initial : scalar, optional\n        The minimum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        Elements to compare for the maximum. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    amin :\n        The minimum value of an array along a given axis, propagating any NaNs.\n    nanmax :\n        The maximum value of an array along a given axis, ignoring any NaNs.\n    maximum :\n        Element-wise maximum of two arrays, propagating any NaNs.\n    fmax :\n        Element-wise maximum of two arrays, ignoring any NaNs.\n    argmax :\n        Return the indices of the maximum values.\n\n    nanmin, minimum, fmin\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well. To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Don't use `amax` for element-wise comparison of 2 arrays; when\n    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than\n    ``amax(a, axis=0)``.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)           # Maximum of the flattened array\n    3\n    >>> np.amax(a, axis=0)   # Maxima along the first axis\n    array([2, 3])\n    >>> np.amax(a, axis=1)   # Maxima along the second axis\n    array([1, 3])\n    >>> np.amax(a, where=[False, True], initial=-1, axis=0)\n    array([-1,  3])\n    >>> b = np.arange(5, dtype=float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.amax(b, where=~np.isnan(b), initial=-1)\n    4.0\n    >>> np.nanmax(b)\n    4.0\n\n    You can use an initial value to compute the maximum of an empty slice, or\n    to initialize it to a different value:\n\n    >>> np.max([[-50], [10]], axis=-1, initial=0)\n    array([ 0, 10])\n\n    Notice that the initial value is used as one of the elements for which the\n    maximum is determined, unlike for the default argument Python's max\n    function, which is only used for empty iterables.\n\n    >>> np.max([5], initial=6)\n    6\n    >>> max([5], default=6)\n    5\n    ","^0","^9"],["^ ","^7","all","^8","\n    Test whether all array elements along a given axis evaluate to True.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a logical AND reduction is performed.\n        The default (``axis=None``) is to perform a logical AND over all\n        the dimensions of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's). See `ufuncs-output-type` for more\n        details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `all` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.all : equivalent method\n\n    any : Test whether any element along a given axis evaluates to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.all([[True,False],[True,True]])\n    False\n\n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False])\n\n    >>> np.all([-1, 4, 5])\n    True\n\n    >>> np.all([1.0, np.nan])\n    True\n\n    >>> o=np.array(False)\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z\n    (28293632, 28293632, array(True)) # may vary\n\n    ","^0","^9"],["^ ","^7","sys","^8","This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nbuiltin_module_names -- tuple of module names built into this interpreter\ncopyright -- copyright notice pertaining to this interpreter\nexec_prefix -- prefix used to find the machine-specific Python library\nexecutable -- absolute path of the executable binary of the Python interpreter\nfloat_info -- a named tuple with information about the float implementation.\nfloat_repr_style -- string indicating the style of repr() output for floats\nhash_info -- a named tuple with information about the hash algorithm.\nhexversion -- version information encoded as a single integer\nimplementation -- Python implementation information.\nint_info -- a named tuple with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the value of the largest Unicode code point\nplatform -- platform identifier\nprefix -- prefix used to find the Python library\nthread_info -- a named tuple with information about the thread implementation.\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function\n","^0","^>"],["^ ","^7","true_divide","^8","true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns a true division of the inputs, element-wise.\n\nInstead of the Python traditional 'floor division', this returns a true\ndivision.  True division adjusts the output type to present the best\nanswer, regardless of input types.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nThe floor division operator ``//`` was added in Python 2.2 making\n``//`` and ``/`` equivalent operators.  The default floor division\noperation of ``/`` can be replaced by true division with ``from\n__future__ import division``.\n\nIn Python 3.0, ``//`` is the floor division operator and ``/`` the\ntrue division operator.  The ``true_divide(x1, x2)`` function is\nequivalent to true division in Python.\n\nExamples\n--------\n>>> x = np.arange(5)\n>>> np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n>>> x//4\narray([0, 0, 0, 0, 1])\n\n>>> from __future__ import division\n>>> x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n>>> x//4\narray([0, 0, 0, 0, 1])","^0","^;"],["^ ","^8","","^0","^:"],["^ ","^8","","^0","^<"],["^ ","^7","hanning","^8","\n    Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray, shape(M,)\n        The window, with the maximum value normalized to one (the value\n        one appears only if `M` is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, kaiser\n\n    Notes\n    -----\n    The Hanning window is defined as\n\n    .. math::  w(n) = 0.5 - 0.5cos\\left(\\frac{2\\pi{n}}{M-1}\\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hanning was named for Julius von Hann, an Austrian meteorologist.\n    It is also known as the Cosine Bell. Some authors prefer that it be\n    called a Hann window, to help avoid confusion with the very similar\n    Hamming window.\n\n    Most references to the Hanning window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 106-108.\n    .. [3] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> np.hanning(12)\n    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n           0.07937323, 0.        ])\n\n    Plot the window and its frequency response:\n\n    >>> import matplotlib.pyplot as plt\n    >>> from numpy.fft import fft, fftshift\n    >>> window = np.hanning(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hann window\")\n    Text(0.5, 1.0, 'Hann window')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"Sample\")\n    Text(0.5, 0, 'Sample')\n    >>> plt.show()\n\n    >>> plt.figure()\n    <Figure size 640x480 with 0 Axes>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> with np.errstate(divide='ignore', invalid='ignore'):\n    ...     response = 20 * np.log10(mag)\n    ...\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of the Hann window\")\n    Text(0.5, 1.0, 'Frequency response of the Hann window')\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    Text(0, 0.5, 'Magnitude [dB]')\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    Text(0.5, 0, 'Normalized frequency [cycles per sample]')\n    >>> plt.axis('tight')\n    ...\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","warnings","^8","Python part of the warnings subsystem.","^0","^>"],["^ ","^7","uintc","^8","Unsigned integer type, compatible with C ``unsigned int``.\n    Character code: ``'I'``.\n    Canonical name: ``np.uintc``.\n    Alias *on this platform*: ``np.uint32``: 32-bit unsigned integer (0 to 4294967295).","^0","^0"],["^ ","^7","resize","^8","\n    Return a new array with the specified shape.\n\n    If the new array is larger than the original array, then the new\n    array is filled with repeated copies of `a`.  Note that this behavior\n    is different from a.resize(new_shape) which fills with zeros instead\n    of repeated copies of `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be resized.\n\n    new_shape : int or tuple of int\n        Shape of resized array.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        The new array is formed from the data in the old array, repeated\n        if necessary to fill out the required number of elements.  The\n        data are repeated in the order that they are stored in memory.\n\n    See Also\n    --------\n    ndarray.resize : resize an array in-place.\n\n    Notes\n    -----\n    Warning: This functionality does **not** consider axes separately,\n    i.e. it does not apply interpolation/extrapolation.\n    It fills the return array with the required number of elements, taken\n    from `a` as they are laid out in memory, disregarding strides and axes.\n    (This is in case the new shape is smaller. For larger, see above.)\n    This functionality is therefore not suitable to resize images,\n    or data where each axis represents a separate and distinct entity.\n\n    Examples\n    --------\n    >>> a=np.array([[0,1],[2,3]])\n    >>> np.resize(a,(2,3))\n    array([[0, 1, 2],\n           [3, 0, 1]])\n    >>> np.resize(a,(1,4))\n    array([[0, 1, 2, 3]])\n    >>> np.resize(a,(2,4))\n    array([[0, 1, 2, 3],\n           [0, 1, 2, 3]])\n\n    ","^0","^9"],["^ ","^7","size","^8","\n    Return the number of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which the elements are counted.  By default, give\n        the total number of elements.\n\n    Returns\n    -------\n    element_count : int\n        Number of elements along the specified axis.\n\n    See Also\n    --------\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n    ndarray.size : number of elements in array\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3],[4,5,6]])\n    >>> np.size(a)\n    6\n    >>> np.size(a,1)\n    3\n    >>> np.size(a,0)\n    2\n\n    ","^0","^9"],["^ ","^7","unsignedinteger","^8","Abstract base class of all unsigned integer scalar types.","^0","^0"],["^ ","^7","float_power","^8","float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nFirst array elements raised to powers from second array, element-wise.\n\nRaise each base in `x1` to the positionally-corresponding power in `x2`.\n`x1` and `x2` must be broadcastable to the same shape. This differs from\nthe power function in that integers, float16, and float32  are promoted to\nfloats with a minimum precision of float64 so that the result is always\ninexact.  The intent is that the function will return a usable result for\nnegative powers and seldom overflow for positive powers.\n\n.. versionadded:: 1.12.0\n\nParameters\n----------\nx1 : array_like\n    The bases.\nx2 : array_like\n    The exponents. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The bases in `x1` raised to the exponents in `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\npower : power function that preserves type\n\nExamples\n--------\nCube each element in a list.\n\n>>> x1 = range(6)\n>>> x1\n[0, 1, 2, 3, 4, 5]\n>>> np.float_power(x1, 3)\narray([   0.,    1.,    8.,   27.,   64.,  125.])\n\nRaise the bases to different exponents.\n\n>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n>>> np.float_power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\nThe effect of broadcasting.\n\n>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n>>> x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n>>> np.float_power(x1, x2)\narray([[  0.,   1.,   8.,  27.,  16.,   5.],\n       [  0.,   1.,   8.,  27.,  16.,   5.]])","^0","^;"],["^ ","^7","logical_xor","^8","logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 XOR x2, element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Logical XOR is applied to the elements of `x1` and `x2`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : bool or ndarray of bool\n    Boolean result of the logical XOR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_and, logical_or, logical_not, bitwise_xor\n\nExamples\n--------\n>>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_xor(x < 1, x > 3)\narray([ True, False, False, False,  True])\n\nSimple example showing support of broadcasting\n\n>>> np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])","^0","^;"],["^ ","^7","set_string_function","^8","\n    Set a Python function to be used when pretty printing arrays.\n\n    Parameters\n    ----------\n    f : function or None\n        Function to be used to pretty print arrays. The function should expect\n        a single array argument and return a string of the representation of\n        the array. If None, the function is reset to the default NumPy function\n        to print arrays.\n    repr : bool, optional\n        If True (default), the function for pretty printing (``__repr__``)\n        is set, if False the function that returns the default string\n        representation (``__str__``) is set.\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    Examples\n    --------\n    >>> def pprint(arr):\n    ...     return 'HA! - What are you going to do now?'\n    ...\n    >>> np.set_string_function(pprint)\n    >>> a = np.arange(10)\n    >>> a\n    HA! - What are you going to do now?\n    >>> _ = a\n    >>> # [0 1 2 3 4 5 6 7 8 9]\n\n    We can reset the function to the default:\n\n    >>> np.set_string_function(None)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    `repr` affects either pretty printing or normal string representation.\n    Note that ``__repr__`` is still affected by setting ``__str__``\n    because the width of each array element in the returned string becomes\n    equal to the length of the result of ``__str__()``.\n\n    >>> x = np.arange(4)\n    >>> np.set_string_function(lambda x:'random', repr=False)\n    >>> x.__str__()\n    'random'\n    >>> x.__repr__()\n    'array([0, 1, 2, 3])'\n\n    ","^0","^9"],["^ ","^7","allclose","^8","\n    Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    NaNs are treated as equal if they are in the same place and if\n    ``equal_nan=True``.  Infs are treated as equal if they are in the same\n    place and of the same sign in both arrays.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n        .. versionadded:: 1.10.0\n\n    Returns\n    -------\n    allclose : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise.\n\n    See Also\n    --------\n    isclose, all, any, equal\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in\n    some rare cases.\n\n    The comparison of `a` and `b` uses standard broadcasting, which\n    means that `a` and `b` need not have the same shape in order for\n    ``allclose(a, b)`` to evaluate to True.  The same is true for\n    `equal` but not `array_equal`.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    True\n\n    ","^0","^9"],["^ ","^8","","^0","^:"],["^ ","^7","cumproduct","^8","\n    Return the cumulative product over the given axis.\n\n    See Also\n    --------\n    cumprod : equivalent function; see for details.\n    ","^0","^9"],["^ ","^7","amin","^8","\n    Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to operate.  By default, flattened input is\n        used.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, the minimum is selected over multiple axes,\n        instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `amin` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    initial : scalar, optional\n        The maximum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        Elements to compare for the minimum. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    amin : ndarray or scalar\n        Minimum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    amax :\n        The maximum value of an array along a given axis, propagating any NaNs.\n    nanmin :\n        The minimum value of an array along a given axis, ignoring any NaNs.\n    minimum :\n        Element-wise minimum of two arrays, propagating any NaNs.\n    fmin :\n        Element-wise minimum of two arrays, ignoring any NaNs.\n    argmin :\n        Return the indices of the minimum values.\n\n    nanmax, maximum, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding min value will be NaN as well. To ignore NaN values\n    (MATLAB behavior), please use nanmin.\n\n    Don't use `amin` for element-wise comparison of 2 arrays; when\n    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than\n    ``amin(a, axis=0)``.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)   # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)   # Minima along the second axis\n    array([0, 2])\n    >>> np.amin(a, where=[False, True], initial=10, axis=0)\n    array([10,  1])\n\n    >>> b = np.arange(5, dtype=float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.amin(b, where=~np.isnan(b), initial=10)\n    0.0\n    >>> np.nanmin(b)\n    0.0\n\n    >>> np.min([[-50], [10]], axis=-1, initial=0)\n    array([-50,   0])\n\n    Notice that the initial value is used as one of the elements for which the\n    minimum is determined, unlike for the default argument Python's max\n    function, which is only used for empty iterables.\n\n    Notice that this isn't the same as Python's ``default`` argument.\n\n    >>> np.min([6], initial=5)\n    5\n    >>> min([6], default=5)\n    6\n    ","^0","^9"],["^ ","^7","nan_to_num","^8","\n    Replace NaN with zero and infinity with large finite numbers (default\n    behaviour) or with the numbers defined by the user using the `nan`, \n    `posinf` and/or `neginf` keywords.\n\n    If `x` is inexact, NaN is replaced by zero or by the user defined value in\n    `nan` keyword, infinity is replaced by the largest finite floating point \n    values representable by ``x.dtype`` or by the user defined value in \n    `posinf` keyword and -infinity is replaced by the most negative finite \n    floating point values representable by ``x.dtype`` or by the user defined \n    value in `neginf` keyword.\n\n    For complex dtypes, the above is applied to each of the real and\n    imaginary components of `x` separately.\n\n    If `x` is not inexact, then no replacements are made.\n\n    Parameters\n    ----------\n    x : scalar or array_like\n        Input data.\n    copy : bool, optional\n        Whether to create a copy of `x` (True) or to replace values\n        in-place (False). The in-place operation only occurs if\n        casting to an array does not require a copy.\n        Default is True.\n        \n        .. versionadded:: 1.13\n    nan : int, float, optional\n        Value to be used to fill NaN values. If no value is passed \n        then NaN values will be replaced with 0.0.\n        \n        .. versionadded:: 1.17\n    posinf : int, float, optional\n        Value to be used to fill positive infinity values. If no value is \n        passed then positive infinity values will be replaced with a very\n        large number.\n        \n        .. versionadded:: 1.17\n    neginf : int, float, optional\n        Value to be used to fill negative infinity values. If no value is \n        passed then negative infinity values will be replaced with a very\n        small (or negative) number.\n        \n        .. versionadded:: 1.17\n\n        \n\n    Returns\n    -------\n    out : ndarray\n        `x`, with the non-finite values replaced. If `copy` is False, this may\n        be `x` itself.\n\n    See Also\n    --------\n    isinf : Shows which elements are positive or negative infinity.\n    isneginf : Shows which elements are negative infinity.\n    isposinf : Shows which elements are positive infinity.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite : Shows which elements are finite (not NaN, not infinity)\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n    Examples\n    --------\n    >>> np.nan_to_num(np.inf)\n    1.7976931348623157e+308\n    >>> np.nan_to_num(-np.inf)\n    -1.7976931348623157e+308\n    >>> np.nan_to_num(np.nan)\n    0.0\n    >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n    >>> np.nan_to_num(x)\n    array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary\n           -1.28000000e+002,  1.28000000e+002])\n    >>> np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)\n    array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, \n           -1.2800000e+02,  1.2800000e+02])\n    >>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])\n    array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary\n         -1.28000000e+002,   1.28000000e+002])\n    >>> np.nan_to_num(y)\n    array([  1.79769313e+308 +0.00000000e+000j, # may vary\n             0.00000000e+000 +0.00000000e+000j,\n             0.00000000e+000 +1.79769313e+308j])\n    >>> np.nan_to_num(y, nan=111111, posinf=222222)\n    array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])\n    ","^0","^9"],["^ ","^7","diag_indices","^8","\n    Return the indices to access the main diagonal of an array.\n\n    This returns a tuple of indices that can be used to access the main\n    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\n    for ``i = [0..n-1]``.\n\n    Parameters\n    ----------\n    n : int\n      The size, along each dimension, of the arrays for which the returned\n      indices can be used.\n\n    ndim : int, optional\n      The number of dimensions.\n\n    See also\n    --------\n    diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Create a set of indices to access the diagonal of a (4, 4) array:\n\n    >>> di = np.diag_indices(4)\n    >>> di\n    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> a[di] = 100\n    >>> a\n    array([[100,   1,   2,   3],\n           [  4, 100,   6,   7],\n           [  8,   9, 100,  11],\n           [ 12,  13,  14, 100]])\n\n    Now, we create indices to manipulate a 3-D array:\n\n    >>> d3 = np.diag_indices(2, 3)\n    >>> d3\n    (array([0, 1]), array([0, 1]), array([0, 1]))\n\n    And use it to set the diagonal of an array of zeros to 1:\n\n    >>> a = np.zeros((2, 2, 2), dtype=int)\n    >>> a[d3] = 1\n    >>> a\n    array([[[1, 0],\n            [0, 0]],\n           [[0, 0],\n            [0, 1]]])\n\n    ","^0","^9"],["^ ","^7","sometrue","^8","\n    Check whether some values are true.\n\n    Refer to `any` for full documentation.\n\n    See Also\n    --------\n    any : equivalent function; see for details.\n    ","^0","^9"],["^ ","^7","str_","^8",null,"^0","^0"],["^ ","^7","singlecomplex","^8","Complex number type composed of two single-precision floating-point\n    numbers.\n    Character code: ``'F'``.\n    Canonical name: ``np.csingle``.\n    Alias: ``np.singlecomplex``.\n    Alias *on this platform*: ``np.complex64``: Complex number type composed of 2 32-bit-precision floating-point numbers.","^0","^0"],["^ ","^7","get_printoptions","^8","\n    Return the current print options.\n\n    Returns\n    -------\n    print_opts : dict\n        Dictionary of current print options with keys\n\n          - precision : int\n          - threshold : int\n          - edgeitems : int\n          - linewidth : int\n          - suppress : bool\n          - nanstr : str\n          - infstr : str\n          - formatter : dict of callables\n          - sign : str\n\n        For a full description of these options, see `set_printoptions`.\n\n    See Also\n    --------\n    set_printoptions, printoptions, set_string_function\n\n    ","^0","^9"],["^ ","^7","sinh","^8","sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic sine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or\n``-1j * np.sin(1j*x)``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding hyperbolic sine values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.\n\nExamples\n--------\n>>> np.sinh(0)\n0.0\n>>> np.sinh(np.pi*1j/2)\n1j\n>>> np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n>>> # Discrepancy due to vagaries of floating point arithmetic.\n\n>>> # Example of providing the optional output parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.sinh([0.1], out1)\n>>> out2 is out1\nTrue\n\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)","^0","^;"],["^ ","^7","triu_indices_from","^8","\n    Return the indices for the upper-triangle of arr.\n\n    See `triu_indices` for full details.\n\n    Parameters\n    ----------\n    arr : ndarray, shape(N, N)\n        The indices will be valid for square arrays.\n    k : int, optional\n        Diagonal offset (see `triu` for details).\n\n    Returns\n    -------\n    triu_indices_from : tuple, shape(2) of ndarray, shape(N)\n        Indices for the upper-triangle of `arr`.\n\n    See Also\n    --------\n    triu_indices, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    ","^0","^9"],["^ ","^8","","^0","^="],["^ ","^7","rot90","^8","\n    Rotate an array by 90 degrees in the plane specified by axes.\n\n    Rotation direction is from the first towards the second axis.\n\n    Parameters\n    ----------\n    m : array_like\n        Array of two or more dimensions.\n    k : integer\n        Number of times the array is rotated by 90 degrees.\n    axes: (2,) array_like\n        The array is rotated in the plane defined by the axes.\n        Axes must be different.\n\n        .. versionadded:: 1.12.0\n\n    Returns\n    -------\n    y : ndarray\n        A rotated view of `m`.\n\n    See Also\n    --------\n    flip : Reverse the order of elements in an array along the given axis.\n    fliplr : Flip an array horizontally.\n    flipud : Flip an array vertically.\n\n    Notes\n    -----\n    rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))\n    rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))\n\n    Examples\n    --------\n    >>> m = np.array([[1,2],[3,4]], int)\n    >>> m\n    array([[1, 2],\n           [3, 4]])\n    >>> np.rot90(m)\n    array([[2, 4],\n           [1, 3]])\n    >>> np.rot90(m, 2)\n    array([[4, 3],\n           [2, 1]])\n    >>> m = np.arange(8).reshape((2,2,2))\n    >>> np.rot90(m, 1, (1,2))\n    array([[[1, 3],\n            [0, 2]],\n           [[5, 7],\n            [4, 6]]])\n\n    ","^0","^9"],["^ ","^7","dsplit","^8","\n    Split array into multiple sub-arrays along the 3rd axis (depth).\n\n    Please refer to the `split` documentation.  `dsplit` is equivalent\n    to `split` with ``axis=2``, the array is always split along the third\n    axis provided the array dimension is greater than or equal to 3.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(2, 2, 4)\n    >>> x\n    array([[[ 0.,   1.,   2.,   3.],\n            [ 4.,   5.,   6.,   7.]],\n           [[ 8.,   9.,  10.,  11.],\n            [12.,  13.,  14.,  15.]]])\n    >>> np.dsplit(x, 2)\n    [array([[[ 0.,  1.],\n            [ 4.,  5.]],\n           [[ 8.,  9.],\n            [12., 13.]]]), array([[[ 2.,  3.],\n            [ 6.,  7.]],\n           [[10., 11.],\n            [14., 15.]]])]\n    >>> np.dsplit(x, np.array([3, 6]))\n    [array([[[ 0.,   1.,   2.],\n            [ 4.,   5.,   6.]],\n           [[ 8.,   9.,  10.],\n            [12.,  13.,  14.]]]),\n     array([[[ 3.],\n            [ 7.]],\n           [[11.],\n            [15.]]]),\n    array([], shape=(2, 2, 0), dtype=float64)]\n    ","^0","^9"],["^ ","^7","equal","^8","equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 == x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nnot_equal, greater_equal, less_equal, greater, less\n\nExamples\n--------\n>>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n\nWhat is compared are values, not types. So an int (1) and an array of\nlength one can evaluate as True:\n\n>>> np.equal(1, np.ones(1))\narray([ True])","^0","^;"],["^ ","^8","","^0","^<"],["^ ","^7","broadcast_to","^8","Broadcast an array to a new shape.\n\n    Parameters\n    ----------\n    array : array_like\n        The array to broadcast.\n    shape : tuple\n        The shape of the desired array.\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n\n    Returns\n    -------\n    broadcast : array\n        A readonly view on the original array with the given shape. It is\n        typically not contiguous. Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location.\n\n    Raises\n    ------\n    ValueError\n        If the array is not compatible with the new shape according to NumPy's\n        broadcasting rules.\n\n    Notes\n    -----\n    .. versionadded:: 1.10.0\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> np.broadcast_to(x, (3, 3))\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    ","^0","^9"],["^ "],["^ ","^7","einsum","^8","\n    einsum(subscripts, *operands, out=None, dtype=None, order='K',\n           casting='safe', optimize=False)\n\n    Evaluates the Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common multi-dimensional,\n    linear algebraic array operations can be represented in a simple fashion.\n    In *implicit* mode `einsum` computes these values.\n\n    In *explicit* mode, `einsum` provides further flexibility to compute\n    other array operations that might not be considered classical Einstein\n    summation operations, by disabling, or forcing summation over specified\n    subscript labels.\n\n    See the notes and examples for clarification.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation as comma separated list of\n        subscript labels. An implicit (classical Einstein summation)\n        calculation is performed unless the explicit indicator '->' is\n        included as well as subscript labels of the precise output form.\n    operands : list of array_like\n        These are the arrays for the operation.\n    out : ndarray, optional\n        If provided, the calculation is done into this array.\n    dtype : {data-type, None}, optional\n        If provided, forces the calculation to use the data type specified.\n        Note that you may have to also give a more liberal `casting`\n        parameter to allow the conversions. Default is None.\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the memory layout of the output. 'C' means it should\n        be C contiguous. 'F' means it should be Fortran contiguous,\n        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.\n        'K' means it should be as close to the layout as the inputs as\n        is possible, including arbitrarily permuted axes.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.  Setting this to\n        'unsafe' is not recommended, as it can adversely affect accumulations.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n        Default is 'safe'.\n    optimize : {False, True, 'greedy', 'optimal'}, optional\n        Controls if intermediate optimization should occur. No optimization\n        will occur if False and True will default to the 'greedy' algorithm.\n        Also accepts an explicit contraction list from the ``np.einsum_path``\n        function. See ``np.einsum_path`` for more details. Defaults to False.\n\n    Returns\n    -------\n    output : ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    einsum_path, dot, inner, outer, tensordot, linalg.multi_dot\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The Einstein summation convention can be used to compute\n    many multi-dimensional, linear algebraic array operations. `einsum`\n    provides a succinct way of representing these.\n\n    A non-exhaustive list of these operations,\n    which can be computed by `einsum`, is shown below along with examples:\n\n    * Trace of an array, :py:func:`numpy.trace`.\n    * Return a diagonal, :py:func:`numpy.diag`.\n    * Array axis summations, :py:func:`numpy.sum`.\n    * Transpositions and permutations, :py:func:`numpy.transpose`.\n    * Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.\n    * Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.\n    * Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.\n    * Tensor contractions, :py:func:`numpy.tensordot`.\n    * Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.\n\n    The subscripts string is a comma-separated list of subscript labels,\n    where each label refers to a dimension of the corresponding operand.\n    Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``\n    is equivalent to :py:func:`np.inner(a,b) <numpy.inner>`. If a label\n    appears only once, it is not summed, so ``np.einsum('i', a)`` produces a\n    view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``\n    describes traditional matrix multiplication and is equivalent to\n    :py:func:`np.matmul(a,b) <numpy.matmul>`. Repeated subscript labels in one\n    operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent\n    to :py:func:`np.trace(a) <numpy.trace>`.\n\n    In *implicit mode*, the chosen subscripts are important\n    since the axes of the output are reordered alphabetically.  This\n    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while\n    ``np.einsum('ji', a)`` takes its transpose. Additionally,\n    ``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,\n    ``np.einsum('ij,jh', a, b)`` returns the transpose of the\n    multiplication since subscript 'h' precedes subscript 'i'.\n\n    In *explicit mode* the output can be directly controlled by\n    specifying output subscript labels.  This requires the\n    identifier '->' as well as the list of output subscript labels.\n    This feature increases the flexibility of the function since\n    summing can be disabled or forced when required. The call\n    ``np.einsum('i->', a)`` is like :py:func:`np.sum(a, axis=-1) <numpy.sum>`,\n    and ``np.einsum('ii->i', a)`` is like :py:func:`np.diag(a) <numpy.diag>`.\n    The difference is that `einsum` does not allow broadcasting by default.\n    Additionally ``np.einsum('ij,jh->ih', a, b)`` directly specifies the\n    order of the output subscript labels and therefore returns matrix\n    multiplication, unlike the example above in implicit mode.\n\n    To enable and control broadcasting, use an ellipsis.  Default\n    NumPy-style broadcasting is done by adding an ellipsis\n    to the left of each term, like ``np.einsum('...ii->...i', a)``.\n    To take the trace along the first and last axes,\n    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix\n    product with the left-most indices instead of rightmost, one can do\n    ``np.einsum('ij...,jk...->ik...', a, b)``.\n\n    When there is only one operand, no axes are summed, and no output\n    parameter is provided, a view into the operand is returned instead\n    of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``\n    produces a view (changed in version 1.10.0).\n\n    `einsum` also provides an alternative way to provide the subscripts\n    and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.\n    If the output shape is not provided in this format `einsum` will be\n    calculated in implicit mode, otherwise it will be performed explicitly.\n    The examples below have corresponding `einsum` calls with the two\n    parameter methods.\n\n    .. versionadded:: 1.10.0\n\n    Views returned from einsum are now writeable whenever the input array\n    is writeable. For example, ``np.einsum('ijk...->kji...', a)`` will now\n    have the same effect as :py:func:`np.swapaxes(a, 0, 2) <numpy.swapaxes>`\n    and ``np.einsum('ii->i', a)`` will return a writeable view of the diagonal\n    of a 2D array.\n\n    .. versionadded:: 1.12.0\n\n    Added the ``optimize`` argument which will optimize the contraction order\n    of an einsum expression. For a contraction with three or more operands this\n    can greatly increase the computational efficiency at the cost of a larger\n    memory footprint during computation.\n\n    Typically a 'greedy' algorithm is applied which empirical tests have shown\n    returns the optimal path in the majority of cases. In some cases 'optimal'\n    will return the superlative path through a more expensive, exhaustive search.\n    For iterative calculations it may be advisable to calculate the optimal path\n    once and reuse that path by supplying it as an argument. An example is given\n    below.\n\n    See :py:func:`numpy.einsum_path` for more details.\n\n    Examples\n    --------\n    >>> a = np.arange(25).reshape(5,5)\n    >>> b = np.arange(5)\n    >>> c = np.arange(6).reshape(2,3)\n\n    Trace of a matrix:\n\n    >>> np.einsum('ii', a)\n    60\n    >>> np.einsum(a, [0,0])\n    60\n    >>> np.trace(a)\n    60\n\n    Extract the diagonal (requires explicit form):\n\n    >>> np.einsum('ii->i', a)\n    array([ 0,  6, 12, 18, 24])\n    >>> np.einsum(a, [0,0], [0])\n    array([ 0,  6, 12, 18, 24])\n    >>> np.diag(a)\n    array([ 0,  6, 12, 18, 24])\n\n    Sum over an axis (requires explicit form):\n\n    >>> np.einsum('ij->i', a)\n    array([ 10,  35,  60,  85, 110])\n    >>> np.einsum(a, [0,1], [0])\n    array([ 10,  35,  60,  85, 110])\n    >>> np.sum(a, axis=1)\n    array([ 10,  35,  60,  85, 110])\n\n    For higher dimensional arrays summing a single axis can be done with ellipsis:\n\n    >>> np.einsum('...j->...', a)\n    array([ 10,  35,  60,  85, 110])\n    >>> np.einsum(a, [Ellipsis,1], [Ellipsis])\n    array([ 10,  35,  60,  85, 110])\n\n    Compute a matrix transpose, or reorder any number of axes:\n\n    >>> np.einsum('ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum('ij->ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum(c, [1,0])\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.transpose(c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n\n    Vector inner products:\n\n    >>> np.einsum('i,i', b, b)\n    30\n    >>> np.einsum(b, [0], b, [0])\n    30\n    >>> np.inner(b,b)\n    30\n\n    Matrix vector multiplication:\n\n    >>> np.einsum('ij,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum(a, [0,1], b, [1])\n    array([ 30,  80, 130, 180, 230])\n    >>> np.dot(a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum('...j,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n\n    Broadcasting and scalar multiplication:\n\n    >>> np.einsum('..., ...', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(',ij', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(3, [Ellipsis], c, [Ellipsis])\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.multiply(3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n\n    Vector outer product:\n\n    >>> np.einsum('i,j', np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.einsum(np.arange(2)+1, [0], b, [1])\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.outer(np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n\n    Tensor contraction:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> np.einsum('ijk,jil->kl', a, b)\n    array([[4400., 4730.],\n           [4532., 4874.],\n           [4664., 5018.],\n           [4796., 5162.],\n           [4928., 5306.]])\n    >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\n    array([[4400., 4730.],\n           [4532., 4874.],\n           [4664., 5018.],\n           [4796., 5162.],\n           [4928., 5306.]])\n    >>> np.tensordot(a,b, axes=([1,0],[0,1]))\n    array([[4400., 4730.],\n           [4532., 4874.],\n           [4664., 5018.],\n           [4796., 5162.],\n           [4928., 5306.]])\n\n    Writeable returned arrays (since version 1.10.0):\n\n    >>> a = np.zeros((3, 3))\n    >>> np.einsum('ii->i', a)[:] = 1\n    >>> a\n    array([[1., 0., 0.],\n           [0., 1., 0.],\n           [0., 0., 1.]])\n\n    Example of ellipsis use:\n\n    >>> a = np.arange(6).reshape((3,2))\n    >>> b = np.arange(12).reshape((4,3))\n    >>> np.einsum('ki,jk->ij', a, b)\n    array([[10, 28, 46, 64],\n           [13, 40, 67, 94]])\n    >>> np.einsum('ki,...k->i...', a, b)\n    array([[10, 28, 46, 64],\n           [13, 40, 67, 94]])\n    >>> np.einsum('k...,jk', a, b)\n    array([[10, 28, 46, 64],\n           [13, 40, 67, 94]])\n\n    Chained array operations. For more complicated contractions, speed ups\n    might be achieved by repeatedly computing a 'greedy' path or pre-computing the\n    'optimal' path and repeatedly applying it, using an\n    `einsum_path` insertion (since version 1.12.0). Performance improvements can be\n    particularly significant with larger arrays:\n\n    >>> a = np.ones(64).reshape(2,4,8)\n\n    Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)\n\n    >>> for iteration in range(500):\n    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)\n\n    Sub-optimal `einsum` (due to repeated path calculation time): ~330ms\n\n    >>> for iteration in range(500):\n    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')\n\n    Greedy `einsum` (faster optimal path approximation): ~160ms\n\n    >>> for iteration in range(500):\n    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')\n\n    Optimal `einsum` (best usage pattern in some use cases): ~110ms\n\n    >>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0]\n    >>> for iteration in range(500):\n    ...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)\n\n    ","^0","^9"],["^ ","^8","","^0","^="],["^ ","^7","bytes0","^8",null,"^0","^0"],["^ ","^8","","^0","^J"],["^ ","^7","VisibleDeprecationWarning","^8","Visible deprecation warning.\n\n    By default, python will not show deprecation warnings, so this class\n    can be used when a very visible warning is helpful, for example because\n    the usage is most likely a user bug.\n\n    ","^0","^0"],["^ "],["^ ","^7","AxisError","^8"," Axis supplied was invalid. ","^0","^0"],["^ ","^7","apply_along_axis","^8","\n    Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`\n    is a 1-D slice of `arr` along `axis`.\n\n    This is equivalent to (but faster than) the following use of `ndindex` and\n    `s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                f = func1d(arr[ii + s_[:,] + kk])\n                Nj = f.shape\n                for jj in ndindex(Nj):\n                    out[ii + jj + kk] = f[jj]\n\n    Equivalently, eliminating the inner loop, this can be expressed as::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])\n\n    Parameters\n    ----------\n    func1d : function (M,) -> (Nj...)\n        This function should accept 1-D arrays. It is applied to 1-D\n        slices of `arr` along the specified axis.\n    axis : integer\n        Axis along which `arr` is sliced.\n    arr : ndarray (Ni..., M, Nk...)\n        Input array.\n    args : any\n        Additional arguments to `func1d`.\n    kwargs : any\n        Additional named arguments to `func1d`.\n\n        .. versionadded:: 1.9.0\n\n\n    Returns\n    -------\n    out : ndarray  (Ni..., Nj..., Nk...)\n        The output array. The shape of `out` is identical to the shape of\n        `arr`, except along the `axis` dimension. This axis is removed, and\n        replaced with new dimensions equal to the shape of the return value\n        of `func1d`. So if `func1d` returns a scalar `out` will have one\n        fewer dimensions than `arr`.\n\n    See Also\n    --------\n    apply_over_axes : Apply a function repeatedly over multiple axes.\n\n    Examples\n    --------\n    >>> def my_func(a):\n    ...     \"\"\"Average first and last element of a 1-D array\"\"\"\n    ...     return (a[0] + a[-1]) * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(my_func, 0, b)\n    array([4., 5., 6.])\n    >>> np.apply_along_axis(my_func, 1, b)\n    array([2.,  5.,  8.])\n\n    For a function that returns a 1D array, the number of dimensions in\n    `outarr` is the same as `arr`.\n\n    >>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n    >>> np.apply_along_axis(sorted, 1, b)\n    array([[1, 7, 8],\n           [3, 4, 9],\n           [2, 5, 6]])\n\n    For a function that returns a higher dimensional array, those dimensions\n    are inserted in place of the `axis` dimension.\n\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(np.diag, -1, b)\n    array([[[1, 0, 0],\n            [0, 2, 0],\n            [0, 0, 3]],\n           [[4, 0, 0],\n            [0, 5, 0],\n            [0, 0, 6]],\n           [[7, 0, 0],\n            [0, 8, 0],\n            [0, 0, 9]]])\n    ","^0","^9"],["^ ","^7","nextafter","^8","nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the next floating-point value after x1 towards x2, element-wise.\n\nParameters\n----------\nx1 : array_like\n    Values to find the next representable value of.\nx2 : array_like\n    The direction where to look for the next representable value of `x1`.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The next representable values of `x1` in the direction of `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nExamples\n--------\n>>> eps = np.finfo(np.float64).eps\n>>> np.nextafter(1, 2) == eps + 1\nTrue\n>>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]\narray([ True,  True])","^0","^;"],["^ ","^7","cumsum","^8","\n    Return the cumulative sum of the elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See `ufuncs-output-type` for\n        more details.\n\n    Returns\n    -------\n    cumsum_along_axis : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to `out` is returned. The\n        result has the same size as `a`, and the same shape as `a` if\n        `axis` is not None or `a` is a 1-d array.\n\n\n    See Also\n    --------\n    sum : Sum array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    diff :  Calculate the n-th discrete difference along given axis.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n\n    ","^0","^9"],["^ ","^7","bartlett","^8","\n    Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : array\n        The triangular window, with the maximum value normalized to one\n        (the value one appears only if the number of samples is odd), with\n        the first and last samples equal to zero.\n\n    See Also\n    --------\n    blackman, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Bartlett window is defined as\n\n    .. math:: w(n) = \\frac{2}{M-1} \\left(\n              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|\n              \\right)\n\n    Most references to the Bartlett window come from the signal\n    processing literature, where it is used as one of many windowing\n    functions for smoothing values.  Note that convolution with this\n    window produces linear interpolation.  It is also known as an\n    apodization (which means\"removing the foot\", i.e. smoothing\n    discontinuities at the beginning and end of the sampled signal) or\n    tapering function. The fourier transform of the Bartlett is the product\n    of two sinc functions.\n    Note the excellent discussion in Kanasewich.\n\n    References\n    ----------\n    .. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n           Biometrika 37, 1-16, 1950.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 109-110.\n    .. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n           Processing\", Prentice-Hall, 1999, pp. 468-471.\n    .. [4] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> np.bartlett(12)\n    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n            0.18181818,  0.        ])\n\n    Plot the window and its frequency response (requires SciPy and matplotlib):\n\n    >>> from numpy.fft import fft, fftshift\n    >>> window = np.bartlett(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Bartlett window\")\n    Text(0.5, 1.0, 'Bartlett window')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"Sample\")\n    Text(0.5, 0, 'Sample')\n    >>> plt.show()\n\n    >>> plt.figure()\n    <Figure size 640x480 with 0 Axes>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> with np.errstate(divide='ignore', invalid='ignore'):\n    ...     response = 20 * np.log10(mag)\n    ...\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Bartlett window\")\n    Text(0.5, 1.0, 'Frequency response of Bartlett window')\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    Text(0, 0.5, 'Magnitude [dB]')\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    Text(0.5, 0, 'Normalized frequency [cycles per sample]')\n    >>> _ = plt.axis('tight')\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","bool8","^8","Boolean type (True or False), stored as a byte.\n    Character code: ``'?'``.\n    Alias: ``np.bool8``.","^0","^0"],["^ ","^7","nanmean","^8","\n    Compute the arithmetic mean along the specified axis, ignoring NaNs.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the means are computed. The default is to compute\n        the mean of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for inexact inputs, it is the same as the input\n        dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        `ufuncs-output-type` for more details.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `mean` or `sum` methods\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned. Nan is\n        returned for slices that contain only NaNs.\n\n    See Also\n    --------\n    average : Weighted average\n    mean : Arithmetic mean taken while not ignoring NaNs\n    var, nanvar\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the non-NaN elements along the axis\n    divided by the number of non-NaN elements.\n\n    Note that for floating-point input, the mean is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32`.  Specifying a\n    higher-precision accumulator using the `dtype` keyword can alleviate\n    this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, np.nan], [3, 4]])\n    >>> np.nanmean(a)\n    2.6666666666666665\n    >>> np.nanmean(a, axis=0)\n    array([2.,  4.])\n    >>> np.nanmean(a, axis=1)\n    array([1.,  3.5]) # may vary\n\n    ","^0","^9"],["^ ","^7","dtype","^8","dtype(obj, align=False, copy=False)\n\n    Create a data type object.\n\n    A numpy array is homogeneous, and contains elements described by a\n    dtype object. A dtype object can be constructed from different\n    combinations of fundamental numeric types.\n\n    Parameters\n    ----------\n    obj\n        Object to be converted to a data type object.\n    align : bool, optional\n        Add padding to the fields to match what a C compiler would output\n        for a similar C-struct. Can be ``True`` only if `obj` is a dictionary\n        or a comma-separated string. If a struct dtype is being created,\n        this also sets a sticky alignment flag ``isalignedstruct``.\n    copy : bool, optional\n        Make a new copy of the data-type object. If ``False``, the result\n        may just be a reference to a built-in data-type object.\n\n    See also\n    --------\n    result_type\n\n    Examples\n    --------\n    Using array-scalar type:\n\n    >>> np.dtype(np.int16)\n    dtype('int16')\n\n    Structured type, one field name 'f1', containing int16:\n\n    >>> np.dtype([('f1', np.int16)])\n    dtype([('f1', '<i2')])\n\n    Structured type, one field named 'f1', in itself containing a structured\n    type with one field:\n\n    >>> np.dtype([('f1', [('f1', np.int16)])])\n    dtype([('f1', [('f1', '<i2')])])\n\n    Structured type, two fields: the first field contains an unsigned int, the\n    second an int32:\n\n    >>> np.dtype([('f1', np.uint64), ('f2', np.int32)])\n    dtype([('f1', '<u8'), ('f2', '<i4')])\n\n    Using array-protocol type strings:\n\n    >>> np.dtype([('a','f8'),('b','S10')])\n    dtype([('a', '<f8'), ('b', 'S10')])\n\n    Using comma-separated field formats.  The shape is (2,3):\n\n    >>> np.dtype(\"i4, (2,3)f8\")\n    dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])\n\n    Using tuples.  ``int`` is a fixed type, 3 the field's shape.  ``void``\n    is a flexible type, here of size 10:\n\n    >>> np.dtype([('hello',(np.int64,3)),('world',np.void,10)])\n    dtype([('hello', '<i8', (3,)), ('world', 'V10')])\n\n    Subdivide ``int16`` into 2 ``int8``'s, called x and y.  0 and 1 are\n    the offsets in bytes:\n\n    >>> np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))\n    dtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))\n\n    Using dictionaries.  Two fields named 'gender' and 'age':\n\n    >>> np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})\n    dtype([('gender', 'S1'), ('age', 'u1')])\n\n    Offsets in bytes, here 0 and 25:\n\n    >>> np.dtype({'surname':('S25',0),'age':(np.uint8,25)})\n    dtype([('surname', 'S25'), ('age', 'u1')])","^0","^0"],["^ ","^7","geomspace","^8","\n    Return numbers spaced evenly on a log scale (a geometric progression).\n\n    This is similar to `logspace`, but with endpoints specified directly.\n    Each output sample is a constant multiple of the previous.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The final value of the sequence, unless `endpoint` is False.\n        In that case, ``num + 1`` values are spaced over the\n        interval in log-space, of which all but the last (a sequence of\n        length `num`) are returned.\n    num : integer, optional\n        Number of samples to generate.  Default is 50.\n    endpoint : boolean, optional\n        If true, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    dtype : dtype\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        `num` samples, equally spaced on a log scale.\n\n    See Also\n    --------\n    logspace : Similar to geomspace, but with endpoints specified using log\n               and base.\n    linspace : Similar to geomspace, but with arithmetic instead of geometric\n               progression.\n    arange : Similar to linspace, with the step size specified instead of the\n             number of samples.\n\n    Notes\n    -----\n    If the inputs or dtype are complex, the output will follow a logarithmic\n    spiral in the complex plane.  (There are an infinite number of spirals\n    passing through two points; the output will follow the shortest such path.)\n\n    Examples\n    --------\n    >>> np.geomspace(1, 1000, num=4)\n    array([    1.,    10.,   100.,  1000.])\n    >>> np.geomspace(1, 1000, num=3, endpoint=False)\n    array([   1.,   10.,  100.])\n    >>> np.geomspace(1, 1000, num=4, endpoint=False)\n    array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n    >>> np.geomspace(1, 256, num=9)\n    array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\n\n    Note that the above may not produce exact integers:\n\n    >>> np.geomspace(1, 256, num=9, dtype=int)\n    array([  1,   2,   4,   7,  16,  32,  63, 127, 256])\n    >>> np.around(np.geomspace(1, 256, num=9)).astype(int)\n    array([  1,   2,   4,   8,  16,  32,  64, 128, 256])\n\n    Negative, decreasing, and complex inputs are allowed:\n\n    >>> np.geomspace(1000, 1, num=4)\n    array([1000.,  100.,   10.,    1.])\n    >>> np.geomspace(-1000, -1, num=4)\n    array([-1000.,  -100.,   -10.,    -1.])\n    >>> np.geomspace(1j, 1000j, num=4)  # Straight line\n    array([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])\n    >>> np.geomspace(-1+0j, 1+0j, num=5)  # Circle\n    array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,\n            6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,\n            1.00000000e+00+0.00000000e+00j])\n\n    Graphical illustration of ``endpoint`` parameter:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 10\n    >>> y = np.zeros(N)\n    >>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.axis([0.5, 2000, 0, 3])\n    [0.5, 2000, 0, 3]\n    >>> plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","round","^8","\n    Round an array to the given number of decimals.\n\n    See Also\n    --------\n    around : equivalent function; see for details.\n    ","^0","^9"],["^ ","^7","uintp","^8","Unsigned integer type, compatible with C ``unsigned long``.\n    Character code: ``'L'``.\n    Canonical name: ``np.uint``.\n    Alias *on this platform*: ``np.uint64``: 64-bit unsigned integer (0 to 18446744073709551615).\n    Alias *on this platform*: ``np.uintp``: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.","^0","^0"],["^ ","^7","ubyte","^8","Unsigned integer type, compatible with C ``unsigned char``.\n    Character code: ``'B'``.\n    Canonical name: ``np.ubyte``.\n    Alias *on this platform*: ``np.uint8``: 8-bit unsigned integer (0 to 255).","^0","^0"],["^ ","^7","triu","^8","\n    Upper triangle of an array.\n\n    Return a copy of a matrix with the elements below the `k`-th diagonal\n    zeroed.\n\n    Please refer to the documentation for `tril` for further details.\n\n    See Also\n    --------\n    tril : lower triangle of an array\n\n    Examples\n    --------\n    >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 0,  8,  9],\n           [ 0,  0, 12]])\n\n    ","^0","^9"],["^ ","^7","diagflat","^8","\n    Create a two-dimensional array with the flattened input as a diagonal.\n\n    Parameters\n    ----------\n    v : array_like\n        Input data, which is flattened and set as the `k`-th\n        diagonal of the output.\n    k : int, optional\n        Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n        a positive (negative) `k` giving the number of the diagonal above\n        (below) the main.\n\n    Returns\n    -------\n    out : ndarray\n        The 2-D output array.\n\n    See Also\n    --------\n    diag : MATLAB work-alike for 1-D and 2-D arrays.\n    diagonal : Return specified diagonals.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> np.diagflat([[1,2], [3,4]])\n    array([[1, 0, 0, 0],\n           [0, 2, 0, 0],\n           [0, 0, 3, 0],\n           [0, 0, 0, 4]])\n\n    >>> np.diagflat([1,2], 1)\n    array([[0, 1, 0],\n           [0, 0, 2],\n           [0, 0, 0]])\n\n    ","^0","^9"],["^ ","^7","complex","^8","Create a complex number from a real part and an optional imaginary part.\n\nThis is equivalent to (real + imag*1j) where imag defaults to 0.","^0","^0"],["^ ","^7","object_","^8","Any Python object.\n    Character code: ``'O'``.","^0","^0"],["^ ","^7","isrealobj","^8","\n    Return True if x is a not complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, False if `x` is of a complex type.\n\n    See Also\n    --------\n    iscomplexobj, isreal\n\n    Examples\n    --------\n    >>> np.isrealobj(1)\n    True\n    >>> np.isrealobj(1+0j)\n    False\n    >>> np.isrealobj([3, 1+0j, True])\n    False\n\n    ","^0","^9"],["^ ","^8","","^0","^="],["^ ","^7","numpy.core.records","^8","\nRecord Arrays\n=============\nRecord arrays expose the fields of structured arrays as properties.\n\nMost commonly, ndarrays contain elements of a single type, e.g. floats,\nintegers, bools etc.  However, it is possible for elements to be combinations\nof these using structured types, such as::\n\n  >>> a = np.array([(1, 2.0), (1, 2.0)], dtype=[('x', np.int64), ('y', np.float64)])\n  >>> a\n  array([(1, 2.), (1, 2.)], dtype=[('x', '<i8'), ('y', '<f8')])\n\nHere, each element consists of two fields: x (and int), and y (a float).\nThis is known as a structured array.  The different fields are analogous\nto columns in a spread-sheet.  The different fields can be accessed as\none would a dictionary::\n\n  >>> a['x']\n  array([1, 1])\n\n  >>> a['y']\n  array([2., 2.])\n\nRecord arrays allow us to access fields as properties::\n\n  >>> ar = np.rec.array(a)\n\n  >>> ar.x\n  array([1, 1])\n\n  >>> ar.y\n  array([2., 2.])\n\n","^0","^>"],["^ ","^8","","^0","^:"],["^ ","^7","cfloat","^8","Complex number type composed of two double-precision floating-point\n    numbers, compatible with Python `complex`.\n    Character code: ``'D'``.\n    Canonical name: ``np.cdouble``.\n    Alias: ``np.cfloat``.\n    Alias: ``np.complex_``.\n    Alias *on this platform*: ``np.complex128``: Complex number type composed of 2 64-bit-precision floating-point numbers.","^0","^0"],["^ ","^7","hstack","^8","\n    Stack arrays in sequence horizontally (column wise).\n\n    This is equivalent to concatenation along the second axis, except for 1-D\n    arrays where it concatenates along the first axis. Rebuilds arrays divided\n    by `hsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        The arrays must have the same shape along all but the second axis,\n        except 1-D arrays which can be any length.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    stack : Join a sequence of arrays along a new axis.\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    concatenate : Join a sequence of arrays along an existing axis.\n    hsplit : Split array along second axis.\n    block : Assemble arrays from blocks.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.hstack((a,b))\n    array([1, 2, 3, 2, 3, 4])\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.hstack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n\n    ","^0","^9"],["^ ","^8","\n    Base object for a dictionary for look-up with any alias for an array dtype.\n\n    Instances of `_typedict` can not be used as dictionaries directly,\n    first they have to be populated.\n\n    ","^0","^D"],["^ ","^7","nanmedian","^8","\n    Compute the median along the specified axis, while ignoring NaNs.\n\n    Returns the median of the array elements.\n\n    .. versionadded:: 1.9.0\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {int, sequence of int, None}, optional\n        Axis or axes along which the medians are computed. The default\n        is to compute the median along a flattened version of the array.\n        A sequence of axes is supported since version 1.9.0.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       `median`. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. If `overwrite_input` is ``True`` and `a` is not already an\n       `ndarray`, an error will be raised.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If this is anything but the default value it will be passed\n        through (in the special case of an empty array) to the\n        `mean` function of the underlying array.  If the array is\n        a sub-class and `mean` does not have the kwarg `keepdims` this\n        will raise a RuntimeError.\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result. If the input contains integers\n        or floats smaller than ``float64``, then the output data-type is\n        ``np.float64``.  Otherwise, the data-type of the output is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean, median, percentile\n\n    Notes\n    -----\n    Given a vector ``V`` of length ``N``, the median of ``V`` is the\n    middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,\n    ``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two\n    middle values of ``V_sorted`` when ``N`` is even.\n\n    Examples\n    --------\n    >>> a = np.array([[10.0, 7, 4], [3, 2, 1]])\n    >>> a[0, 1] = np.nan\n    >>> a\n    array([[10., nan,  4.],\n           [ 3.,  2.,  1.]])\n    >>> np.median(a)\n    nan\n    >>> np.nanmedian(a)\n    3.0\n    >>> np.nanmedian(a, axis=0)\n    array([6.5, 2. , 2.5])\n    >>> np.median(a, axis=1)\n    array([nan,  2.])\n    >>> b = a.copy()\n    >>> np.nanmedian(b, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.nanmedian(b, axis=None, overwrite_input=True)\n    3.0\n    >>> assert not np.all(a==b)\n\n    ","^0","^9"],["^ ","^7","sign","^8","sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns an element-wise indication of the sign of a number.\n\nThe `sign` function returns ``-1 if x < 0, 0 if x==0, 1 if x > 0``.  nan\nis returned for nan inputs.\n\nFor complex inputs, the `sign` function returns\n``sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j``.\n\ncomplex(nan, 0) is returned for complex nan inputs.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The sign of `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nThere is more than one definition of sign in common use for complex\nnumbers.  The definition used here is equivalent to :math:`x/\\sqrt{x*x}`\nwhich is different from a common alternative, :math:`x/|x|`.\n\nExamples\n--------\n>>> np.sign([-5., 4.5])\narray([-1.,  1.])\n>>> np.sign(0)\n0\n>>> np.sign(5-2j)\n(1+0j)","^0","^;"],["^ ","^7","numpy.fft","^8","\nDiscrete Fourier Transform (:mod:`numpy.fft`)\n=============================================\n\n.. currentmodule:: numpy.fft\n\nStandard FFTs\n-------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fft       Discrete Fourier transform.\n   ifft      Inverse discrete Fourier transform.\n   fft2      Discrete Fourier transform in two dimensions.\n   ifft2     Inverse discrete Fourier transform in two dimensions.\n   fftn      Discrete Fourier transform in N-dimensions.\n   ifftn     Inverse discrete Fourier transform in N dimensions.\n\nReal FFTs\n---------\n\n.. autosummary::\n   :toctree: generated/\n\n   rfft      Real discrete Fourier transform.\n   irfft     Inverse real discrete Fourier transform.\n   rfft2     Real discrete Fourier transform in two dimensions.\n   irfft2    Inverse real discrete Fourier transform in two dimensions.\n   rfftn     Real discrete Fourier transform in N dimensions.\n   irfftn    Inverse real discrete Fourier transform in N dimensions.\n\nHermitian FFTs\n--------------\n\n.. autosummary::\n   :toctree: generated/\n\n   hfft      Hermitian discrete Fourier transform.\n   ihfft     Inverse Hermitian discrete Fourier transform.\n\nHelper routines\n---------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fftfreq   Discrete Fourier Transform sample frequencies.\n   rfftfreq  DFT sample frequencies (for usage with rfft, irfft).\n   fftshift  Shift zero-frequency component to center of spectrum.\n   ifftshift Inverse of fftshift.\n\n\nBackground information\n----------------------\n\nFourier analysis is fundamentally a method for expressing a function as a\nsum of periodic components, and for recovering the function from those\ncomponents.  When both the function and its Fourier transform are\nreplaced with discretized counterparts, it is called the discrete Fourier\ntransform (DFT).  The DFT has become a mainstay of numerical computing in\npart because of a very fast algorithm for computing it, called the Fast\nFourier Transform (FFT), which was known to Gauss (1805) and was brought\nto light in its current form by Cooley and Tukey [CT]_.  Press et al. [NR]_\nprovide an accessible introduction to Fourier analysis and its\napplications.\n\nBecause the discrete Fourier transform separates its input into\ncomponents that contribute at discrete frequencies, it has a great number\nof applications in digital signal processing, e.g., for filtering, and in\nthis context the discretized input to the transform is customarily\nreferred to as a *signal*, which exists in the *time domain*.  The output\nis called a *spectrum* or *transform* and exists in the *frequency\ndomain*.\n\nImplementation details\n----------------------\n\nThere are many ways to define the DFT, varying in the sign of the\nexponent, normalization, etc.  In this implementation, the DFT is defined\nas\n\n.. math::\n   A_k =  \\sum_{m=0}^{n-1} a_m \\exp\\left\\{-2\\pi i{mk \\over n}\\right\\}\n   \\qquad k = 0,\\ldots,n-1.\n\nThe DFT is in general defined for complex inputs and outputs, and a\nsingle-frequency component at linear frequency :math:`f` is\nrepresented by a complex exponential\n:math:`a_m = \\exp\\{2\\pi i\\,f m\\Delta t\\}`, where :math:`\\Delta t`\nis the sampling interval.\n\nThe values in the result follow so-called \"standard\" order: If ``A =\nfft(a, n)``, then ``A[0]`` contains the zero-frequency term (the sum of\nthe signal), which is always purely real for real inputs. Then ``A[1:n/2]``\ncontains the positive-frequency terms, and ``A[n/2+1:]`` contains the\nnegative-frequency terms, in order of decreasingly negative frequency.\nFor an even number of input points, ``A[n/2]`` represents both positive and\nnegative Nyquist frequency, and is also purely real for real input.  For\nan odd number of input points, ``A[(n-1)/2]`` contains the largest positive\nfrequency, while ``A[(n+1)/2]`` contains the largest negative frequency.\nThe routine ``np.fft.fftfreq(n)`` returns an array giving the frequencies\nof corresponding elements in the output.  The routine\n``np.fft.fftshift(A)`` shifts transforms and their frequencies to put the\nzero-frequency components in the middle, and ``np.fft.ifftshift(A)`` undoes\nthat shift.\n\nWhen the input `a` is a time-domain signal and ``A = fft(a)``, ``np.abs(A)``\nis its amplitude spectrum and ``np.abs(A)**2`` is its power spectrum.\nThe phase spectrum is obtained by ``np.angle(A)``.\n\nThe inverse DFT is defined as\n\n.. math::\n   a_m = \\frac{1}{n}\\sum_{k=0}^{n-1}A_k\\exp\\left\\{2\\pi i{mk\\over n}\\right\\}\n   \\qquad m = 0,\\ldots,n-1.\n\nIt differs from the forward transform by the sign of the exponential\nargument and the default normalization by :math:`1/n`.\n\nType Promotion\n--------------\n\n`numpy.fft` promotes ``float32`` and ``complex64`` arrays to ``float64`` and\n``complex128`` arrays respectively. For an FFT implementation that does not\npromote input arrays, see `scipy.fftpack`.\n\nNormalization\n-------------\n\nThe default normalization has the direct transforms unscaled and the inverse\ntransforms are scaled by :math:`1/n`. It is possible to obtain unitary\ntransforms by setting the keyword argument ``norm`` to ``\"ortho\"`` (default is\n`None`) so that both direct and inverse transforms will be scaled by\n:math:`1/\\sqrt{n}`.\n\nReal and Hermitian transforms\n-----------------------------\n\nWhen the input is purely real, its transform is Hermitian, i.e., the\ncomponent at frequency :math:`f_k` is the complex conjugate of the\ncomponent at frequency :math:`-f_k`, which means that for real\ninputs there is no information in the negative frequency components that\nis not already available from the positive frequency components.\nThe family of `rfft` functions is\ndesigned to operate on real inputs, and exploits this symmetry by\ncomputing only the positive frequency components, up to and including the\nNyquist frequency.  Thus, ``n`` input points produce ``n/2+1`` complex\noutput points.  The inverses of this family assumes the same symmetry of\nits input, and for an output of ``n`` points uses ``n/2+1`` input points.\n\nCorrespondingly, when the spectrum is purely real, the signal is\nHermitian.  The `hfft` family of functions exploits this symmetry by\nusing ``n/2+1`` complex points in the input (time) domain for ``n`` real\npoints in the frequency domain.\n\nIn higher dimensions, FFTs are used, e.g., for image analysis and\nfiltering.  The computational efficiency of the FFT means that it can\nalso be a faster way to compute large convolutions, using the property\nthat a convolution in the time domain is equivalent to a point-by-point\nmultiplication in the frequency domain.\n\nHigher dimensions\n-----------------\n\nIn two dimensions, the DFT is defined as\n\n.. math::\n   A_{kl} =  \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1}\n   a_{mn}\\exp\\left\\{-2\\pi i \\left({mk\\over M}+{nl\\over N}\\right)\\right\\}\n   \\qquad k = 0, \\ldots, M-1;\\quad l = 0, \\ldots, N-1,\n\nwhich extends in the obvious way to higher dimensions, and the inverses\nin higher dimensions also extend in the same way.\n\nReferences\n----------\n\n.. [CT] Cooley, James W., and John W. Tukey, 1965, \"An algorithm for the\n        machine calculation of complex Fourier series,\" *Math. Comput.*\n        19: 297-301.\n\n.. [NR] Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P.,\n        2007, *Numerical Recipes: The Art of Scientific Computing*, ch.\n        12-13.  Cambridge Univ. Press, Cambridge, UK.\n\nExamples\n--------\n\nFor examples, see the various functions.\n\n","^0","^>"],["^ ","^7","finfo","^8","\n    finfo(dtype)\n\n    Machine limits for floating point types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    eps : float\n        The smallest representable positive number such that\n        ``1.0 + eps != 1.0``.  Type of `eps` is an appropriate floating\n        point type.\n    epsneg : floating point number of the appropriate type\n        The smallest representable positive number such that\n        ``1.0 - epsneg != 1.0``.\n    iexp : int\n        The number of bits in the exponent portion of the floating point\n        representation.\n    machar : MachAr\n        The object which calculated these parameters and holds more\n        detailed information.\n    machep : int\n        The exponent that yields `eps`.\n    max : floating point number of the appropriate type\n        The largest representable number.\n    maxexp : int\n        The smallest positive power of the base (2) that causes overflow.\n    min : floating point number of the appropriate type\n        The smallest representable number, typically ``-max``.\n    minexp : int\n        The most negative power of the base (2) consistent with there\n        being no leading 0's in the mantissa.\n    negep : int\n        The exponent that yields `epsneg`.\n    nexp : int\n        The number of bits in the exponent including its sign and bias.\n    nmant : int\n        The number of bits in the mantissa.\n    precision : int\n        The approximate number of decimal digits to which this kind of\n        float is precise.\n    resolution : floating point number of the appropriate type\n        The approximate decimal resolution of this type, i.e.,\n        ``10**-precision``.\n    tiny : float\n        The smallest positive usable number.  Type of `tiny` is an\n        appropriate floating point type.\n\n    Parameters\n    ----------\n    dtype : float, dtype, or instance\n        Kind of floating point data-type about which to get information.\n\n    See Also\n    --------\n    MachAr : The implementation of the tests that produce this information.\n    iinfo : The equivalent for integer data types.\n\n    Notes\n    -----\n    For developers of NumPy: do not instantiate this at the module level.\n    The initial calculation of these parameters is expensive and negatively\n    impacts import times.  These objects are cached, so calling ``finfo()``\n    repeatedly inside your functions is not a problem.\n\n    ","^0","^0"],["^ ","^7","issubdtype","^8","\n    Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        dtype or string representing a typecode.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubsctype, issubclass_\n    numpy.core.numerictypes : Overview of numpy type hierarchy.\n\n    Examples\n    --------\n    >>> np.issubdtype('S1', np.string_)\n    True\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n\n    ","^0","^9"],["^ ","^7","array","^8","array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)\n\n    Create an array.\n\n    Parameters\n    ----------\n    object : array_like\n        An array, any object exposing the array interface, an object whose\n        __array__ method returns an array, or any (nested) sequence.\n    dtype : data-type, optional\n        The desired data-type for the array.  If not given, then the type will\n        be determined as the minimum type required to hold the objects in the\n        sequence.\n    copy : bool, optional\n        If true (default), then the object is copied.  Otherwise, a copy will\n        only be made if __array__ returns a copy, if obj is a nested sequence,\n        or if a copy is needed to satisfy any of the other requirements\n        (`dtype`, `order`, etc.).\n    order : {'K', 'A', 'C', 'F'}, optional\n        Specify the memory layout of the array. If object is not an array, the\n        newly created array will be in C order (row major) unless 'F' is\n        specified, in which case it will be in Fortran order (column major).\n        If object is an array the following holds.\n\n        ===== ========= ===================================================\n        order  no copy                     copy=True\n        ===== ========= ===================================================\n        'K'   unchanged F & C order preserved, otherwise most similar order\n        'A'   unchanged F order if input is F and not C, otherwise C order\n        'C'   C order   C order\n        'F'   F order   F order\n        ===== ========= ===================================================\n\n        When ``copy=False`` and a copy is made for other reasons, the result is\n        the same as if ``copy=True``, with some exceptions for `A`, see the\n        Notes section. The default order is 'K'.\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n    ndmin : int, optional\n        Specifies the minimum number of dimensions that the resulting\n        array should have.  Ones will be pre-pended to the shape as\n        needed to meet this requirement.\n\n    Returns\n    -------\n    out : ndarray\n        An array object satisfying the specified requirements.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n\n    Notes\n    -----\n    When order is 'A' and `object` is an array in neither 'C' nor 'F' order,\n    and a copy is forced by a change in dtype, then the order of the result is\n    not necessarily 'C' as expected. This is likely a bug.\n\n    Examples\n    --------\n    >>> np.array([1, 2, 3])\n    array([1, 2, 3])\n\n    Upcasting:\n\n    >>> np.array([1, 2, 3.0])\n    array([ 1.,  2.,  3.])\n\n    More than one dimension:\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1, 2],\n           [3, 4]])\n\n    Minimum dimensions 2:\n\n    >>> np.array([1, 2, 3], ndmin=2)\n    array([[1, 2, 3]])\n\n    Type provided:\n\n    >>> np.array([1, 2, 3], dtype=complex)\n    array([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n    Data-type consisting of more than one element:\n\n    >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])\n    >>> x['a']\n    array([1, 3])\n\n    Creating an array from sub-classes:\n\n    >>> np.array(np.mat('1 2; 3 4'))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> np.array(np.mat('1 2; 3 4'), subok=True)\n    matrix([[1, 2],\n            [3, 4]])","^0","^?"],["^ ","^7","logaddexp2","^8","logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nLogarithm of the sum of exponentiations of the inputs in base-2.\n\nCalculates ``log2(2**x1 + 2**x2)``. This function is useful in machine\nlearning when the calculated probabilities of events may be so small as\nto exceed the range of normal floating point numbers.  In such cases\nthe base-2 logarithm of the calculated probability can be used instead.\nThis function allows adding probabilities stored in such a fashion.\n\nParameters\n----------\nx1, x2 : array_like\n    Input values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nresult : ndarray\n    Base-2 logarithm of ``2**x1 + 2**x2``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogaddexp: Logarithm of the sum of exponentiations of the inputs.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nExamples\n--------\n>>> prob1 = np.log2(1e-50)\n>>> prob2 = np.log2(2.5e-50)\n>>> prob12 = np.logaddexp2(prob1, prob2)\n>>> prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n>>> 2**prob12\n3.4999999999999914e-50","^0","^;"],["^ ","^7","transpose","^8","\n    Permute the dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axes : list of ints, optional\n        By default, reverse the dimensions, otherwise permute the axes\n        according to the values given.\n\n    Returns\n    -------\n    p : ndarray\n        `a` with its axes permuted.  A view is returned whenever\n        possible.\n\n    See Also\n    --------\n    moveaxis\n    argsort\n\n    Notes\n    -----\n    Use `transpose(a, argsort(axes))` to invert the transposition of tensors\n    when using the `axes` keyword argument.\n\n    Transposing a 1-D array returns an unchanged view of the original array.\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.transpose(x)\n    array([[0, 2],\n           [1, 3]])\n\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)\n\n    ","^0","^9"],["^ ","^7","tril_indices","^8","\n    Return the indices for the lower-triangle of an (n, m) array.\n\n    Parameters\n    ----------\n    n : int\n        The row dimension of the arrays for which the returned\n        indices will be valid.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n    m : int, optional\n        .. versionadded:: 1.9.0\n\n        The column dimension of the arrays for which the returned\n        arrays will be valid.\n        By default `m` is taken equal to `n`.\n\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    triu_indices : similar function, for upper-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    tril, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    lower triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> il1 = np.tril_indices(4)\n    >>> il2 = np.tril_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[il1]\n    array([ 0,  4,  5, ..., 13, 14, 15])\n\n    And for assigning values:\n\n    >>> a[il1] = -1\n    >>> a\n    array([[-1,  1,  2,  3],\n           [-1, -1,  6,  7],\n           [-1, -1, -1, 11],\n           [-1, -1, -1, -1]])\n\n    These cover almost the whole array (two diagonals right of the main one):\n\n    >>> a[il2] = -10\n    >>> a\n    array([[-10, -10, -10,   3],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10]])\n\n    ","^0","^9"],["^ ","^7","asarray_chkfinite","^8","Convert the input to an array, checking for NaNs or Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.  Success requires no NaNs or Infs.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n         Whether to use row-major (C-style) or\n         column-major (Fortran-style) memory representation.\n         Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray.  If `a` is a subclass of ndarray, a base\n        class ndarray is returned.\n\n    Raises\n    ------\n    ValueError\n        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\n    See Also\n    --------\n    asarray : Create and array.\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array.  If all elements are finite\n    ``asarray_chkfinite`` is identical to ``asarray``.\n\n    >>> a = [1, 2]\n    >>> np.asarray_chkfinite(a, dtype=float)\n    array([1., 2.])\n\n    Raises ValueError if array_like contains Nans or Infs.\n\n    >>> a = [1, 2, np.inf]\n    >>> try:\n    ...     np.asarray_chkfinite(a)\n    ... except ValueError:\n    ...     print('ValueError')\n    ...\n    ValueError\n\n    ","^0","^9"],["^ ","^7","arccos","^8","arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse cosine, element-wise.\n\nThe inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.\n\nParameters\n----------\nx : array_like\n    `x`-coordinate on the unit circle.\n    For real arguments, the domain is [-1, 1].\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nangle : ndarray\n    The angle of the ray intersecting the unit circle at the given\n    `x`-coordinate in radians [0, pi].\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\ncos, arctan, arcsin, emath.arccos\n\nNotes\n-----\n`arccos` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `cos(z) = x`. The convention is to return\nthe angle `z` whose real part lies in `[0, pi]`.\n\nFor real-valued input data types, `arccos` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccos` is a complex analytic function that\nhas branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\n\nThe inverse `cos` is also known as `acos` or cos^-1.\n\nReferences\n----------\nM. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/\n\nExamples\n--------\nWe expect the arccos of 1 to be 0, and of -1 to be pi:\n\n>>> np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n\nPlot arccos:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-1, 1, num=100)\n>>> plt.plot(x, np.arccos(x))\n>>> plt.axis('tight')\n>>> plt.show()","^0","^;"],["^ ","^8","\n    A nicer way to build up index tuples for arrays.\n\n    .. note::\n       Use one of the two predefined instances `index_exp` or `s_`\n       rather than directly using `IndexExpression`.\n\n    For any index combination, including slicing and axis insertion,\n    ``a[indices]`` is the same as ``a[np.index_exp[indices]]`` for any\n    array `a`. However, ``np.index_exp[indices]`` can be used anywhere\n    in Python code and returns a tuple of slice objects that can be\n    used in the construction of complex index expressions.\n\n    Parameters\n    ----------\n    maketuple : bool\n        If True, always returns a tuple.\n\n    See Also\n    --------\n    index_exp : Predefined instance that always returns a tuple:\n       `index_exp = IndexExpression(maketuple=True)`.\n    s_ : Predefined instance without tuple conversion:\n       `s_ = IndexExpression(maketuple=False)`.\n\n    Notes\n    -----\n    You can do all this with `slice()` plus a few special objects,\n    but there's a lot to remember and this version is simpler because\n    it uses the standard array indexing syntax.\n\n    Examples\n    --------\n    >>> np.s_[2::2]\n    slice(2, None, 2)\n    >>> np.index_exp[2::2]\n    (slice(2, None, 2),)\n\n    >>> np.array([0, 1, 2, 3, 4])[np.s_[2::2]]\n    array([2, 4])\n\n    ","^0","^M"],["^ ","^7","numpy.core","^8","\nContains the core of NumPy: ndarray, ufuncs, dtypes, etc.\n\nPlease note that this module is private.  All functions and objects\nare available in the main ``numpy`` namespace - use that instead.\n\n","^0","^>"],["^ ","^7","complex64","^8","Complex number type composed of two single-precision floating-point\n    numbers.\n    Character code: ``'F'``.\n    Canonical name: ``np.csingle``.\n    Alias: ``np.singlecomplex``.\n    Alias *on this platform*: ``np.complex64``: Complex number type composed of 2 32-bit-precision floating-point numbers.","^0","^0"],["^ ","^7","arccosh","^8","arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic cosine, element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\narccosh : ndarray\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\n\ncosh, arcsinh, sinh, arctanh, tanh\n\nNotes\n-----\n`arccosh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `cosh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi, pi]` and the real part in\n``[0, inf]``.\n\nFor real-valued input data types, `arccosh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccosh` is a complex analytical function that\nhas a branch cut `[-inf, 1]` and is continuous from above on it.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\n       https://en.wikipedia.org/wiki/Arccosh\n\nExamples\n--------\n>>> np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n>>> np.arccosh(1)\n0.0","^0","^;"],["^ ","^7","apply_over_axes","^8","\n    Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.\n\n    Parameters\n    ----------\n    func : function\n        This function must take two arguments, `func(a, axis)`.\n    a : array_like\n        Input array.\n    axes : array_like\n        Axes over which `func` is applied; the elements must be integers.\n\n    Returns\n    -------\n    apply_over_axis : ndarray\n        The output array.  The number of dimensions is the same as `a`,\n        but the shape can be different.  This depends on whether `func`\n        changes the shape of its output with respect to its input.\n\n    See Also\n    --------\n    apply_along_axis :\n        Apply a function to 1-D slices of an array along the given axis.\n\n    Notes\n    ------\n    This function is equivalent to tuple axis arguments to reorderable ufuncs\n    with keepdims=True. Tuple axis arguments to ufuncs have been available since\n    version 1.7.0.\n\n    Examples\n    --------\n    >>> a = np.arange(24).reshape(2,3,4)\n    >>> a\n    array([[[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]],\n           [[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]])\n\n    Sum over axes 0 and 2. The result has same number of dimensions\n    as the original array:\n\n    >>> np.apply_over_axes(np.sum, a, [0,2])\n    array([[[ 60],\n            [ 92],\n            [124]]])\n\n    Tuple axis arguments to ufuncs are equivalent:\n\n    >>> np.sum(a, axis=(0,2), keepdims=True)\n    array([[[ 60],\n            [ 92],\n            [124]]])\n\n    ","^0","^9"],["^ ","^7","tanh","^8","tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute hyperbolic tangent element-wise.\n\nEquivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding hyperbolic tangent values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\n.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n       New York, NY: Dover, 1972, pg. 83.\n       http://www.math.sfu.ca/~cbm/aands/\n\n.. [2] Wikipedia, \"Hyperbolic function\",\n       https://en.wikipedia.org/wiki/Hyperbolic_function\n\nExamples\n--------\n>>> np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.tanh([0.1], out1)\n>>> out2 is out1\nTrue\n\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)","^0","^;"],["^ ","^7","frompyfunc","^8","frompyfunc(func, nin, nout)\n\n    Takes an arbitrary Python function and returns a NumPy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a NumPy universal function (``ufunc``) object.\n\n    See Also\n    --------\n    vectorize : Evaluates pyfunc over input arrays using broadcasting rules of numpy.\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array(['0o12', '0o36', '0o144'], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['0o12', '0o36', '0o144'], dtype='<U5')","^0","^?"],["^ ","^7","complex256","^8","Complex number type composed of two extended-precision floating-point\n    numbers.\n    Character code: ``'G'``.\n    Canonical name: ``np.clongdouble``.\n    Alias: ``np.clongfloat``.\n    Alias: ``np.longcomplex``.\n    Alias *on this platform*: ``np.complex256``: Complex number type composed of 2 128-bit extended-precision floating-point numbers.","^0","^0"],["^ ","^8","","^0","^<"],["^ ","^7","expand_dims","^8","\n    Expand the shape of an array.\n\n    Insert a new axis that will appear at the `axis` position in the expanded\n    array shape.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int or tuple of ints\n        Position in the expanded axes where the new axis (or axes) is placed.\n\n        .. deprecated:: 1.13.0\n            Passing an axis where ``axis > a.ndim`` will be treated as\n            ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will\n            be treated as ``axis == 0``. This behavior is deprecated.\n\n        .. versionchanged:: 1.18.0\n            A tuple of axes is now supported.  Out of range axes as\n            described above are now forbidden and raise an `AxisError`.\n\n    Returns\n    -------\n    result : ndarray\n        View of `a` with the number of dimensions increased.\n\n    See Also\n    --------\n    squeeze : The inverse operation, removing singleton dimensions\n    reshape : Insert, remove, and combine dimensions, and resize existing ones\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> x = np.array([1, 2])\n    >>> x.shape\n    (2,)\n\n    The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:\n\n    >>> y = np.expand_dims(x, axis=0)\n    >>> y\n    array([[1, 2]])\n    >>> y.shape\n    (1, 2)\n\n    The following is equivalent to ``x[:, np.newaxis]``:\n\n    >>> y = np.expand_dims(x, axis=1)\n    >>> y\n    array([[1],\n           [2]])\n    >>> y.shape\n    (2, 1)\n\n    ``axis`` may also be a tuple:\n\n    >>> y = np.expand_dims(x, axis=(0, 1))\n    >>> y\n    array([[[1, 2]]])\n\n    >>> y = np.expand_dims(x, axis=(2, 0))\n    >>> y\n    array([[[1],\n            [2]]])\n\n    Note that some examples may use ``None`` instead of ``np.newaxis``.  These\n    are the same objects:\n\n    >>> np.newaxis is None\n    True\n\n    ","^0","^9"],["^ ","^7","fliplr","^8","\n    Flip array in the left/right direction.\n\n    Flip the entries in each row in the left/right direction.\n    Columns are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array, must be at least 2-D.\n\n    Returns\n    -------\n    f : ndarray\n        A view of `m` with the columns reversed.  Since a view\n        is returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    flipud : Flip array in the up/down direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to m[:,::-1]. Requires the array to be at least 2-D.\n\n    Examples\n    --------\n    >>> A = np.diag([1.,2.,3.])\n    >>> A\n    array([[1.,  0.,  0.],\n           [0.,  2.,  0.],\n           [0.,  0.,  3.]])\n    >>> np.fliplr(A)\n    array([[0.,  0.,  1.],\n           [0.,  2.,  0.],\n           [3.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.fliplr(A) == A[:,::-1,...])\n    True\n\n    ","^0","^9"],["^ ","^7","tri","^8","\n    An array with ones at and below the given diagonal and zeros elsewhere.\n\n    Parameters\n    ----------\n    N : int\n        Number of rows in the array.\n    M : int, optional\n        Number of columns in the array.\n        By default, `M` is taken equal to `N`.\n    k : int, optional\n        The sub-diagonal at and below which the array is filled.\n        `k` = 0 is the main diagonal, while `k` < 0 is below it,\n        and `k` > 0 is above.  The default is 0.\n    dtype : dtype, optional\n        Data type of the returned array.  The default is float.\n\n    Returns\n    -------\n    tri : ndarray of shape (N, M)\n        Array with its lower triangle filled with ones and zero elsewhere;\n        in other words ``T[i,j] == 1`` for ``j <= i + k``, 0 otherwise.\n\n    Examples\n    --------\n    >>> np.tri(3, 5, 2, dtype=int)\n    array([[1, 1, 1, 0, 0],\n           [1, 1, 1, 1, 0],\n           [1, 1, 1, 1, 1]])\n\n    >>> np.tri(3, 5, -1)\n    array([[0.,  0.,  0.,  0.,  0.],\n           [1.,  0.,  0.,  0.,  0.],\n           [1.,  1.,  0.,  0.,  0.]])\n\n    ","^0","^9"],["^ ","^7","absolute","^8","absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nabsolute : ndarray\n    An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\n\nPlot the function over ``[-10, 10]``:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\n\nPlot the function over the complex plane:\n\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()","^0","^;"],["^ ","^7","pv","^8","\n    Compute the present value.\n\n    .. deprecated:: 1.18\n\n       `pv` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Given:\n     * a future value, `fv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value now\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray, float\n        Present value of a series of payments or investments.\n\n    Notes\n    -----\n    The present value is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n    or, when ``rate = 0``::\n\n     fv + pv + pmt * nper = 0\n\n    for `pv`, which is then returned.\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the present value (e.g., the initial investment)\n    of an investment that needs to total $15692.93\n    after 10 years of saving $100 every month?  Assume the\n    interest rate is 5% (annually) compounded monthly.\n\n    >>> np.pv(0.05/12, 10*12, -100, 15692.93)\n    -100.00067131625819\n\n    By convention, the negative sign represents cash flow out\n    (i.e., money not available today).  Thus, to end up with\n    $15,692.93 in 10 years saving $100 a month at 5% annual\n    interest, one's initial deposit should also be $100.\n\n    If any input is array_like, ``pv`` returns an array of equal shape.\n    Let's compare different interest rates in the example above:\n\n    >>> a = np.array((0.05, 0.04, 0.03))/12\n    >>> np.pv(a, 10*12, -100, 15692.93)\n    array([ -100.00067132,  -649.26771385, -1273.78633713]) # may vary\n\n    So, to end up with the same $15692.93 under the same $100 per month\n    \"savings plan,\" for annual interest rates of 4% and 3%, one would\n    need initial investments of $649.27 and $1273.79, respectively.\n\n    ","^0","^9"],["^ ","^7","hsplit","^8","\n    Split an array into multiple sub-arrays horizontally (column-wise).\n\n    Please refer to the `split` documentation.  `hsplit` is equivalent\n    to `split` with ``axis=1``, the array is always split along the second\n    axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[ 0.,   1.,   2.,   3.],\n           [ 4.,   5.,   6.,   7.],\n           [ 8.,   9.,  10.,  11.],\n           [12.,  13.,  14.,  15.]])\n    >>> np.hsplit(x, 2)\n    [array([[  0.,   1.],\n           [  4.,   5.],\n           [  8.,   9.],\n           [12.,  13.]]),\n     array([[  2.,   3.],\n           [  6.,   7.],\n           [10.,  11.],\n           [14.,  15.]])]\n    >>> np.hsplit(x, np.array([3, 6]))\n    [array([[ 0.,   1.,   2.],\n           [ 4.,   5.,   6.],\n           [ 8.,   9.,  10.],\n           [12.,  13.,  14.]]),\n     array([[ 3.],\n           [ 7.],\n           [11.],\n           [15.]]),\n     array([], shape=(4, 0), dtype=float64)]\n\n    With a higher dimensional array the split is still along the second axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[0.,  1.],\n            [2.,  3.]],\n           [[4.,  5.],\n            [6.,  7.]]])\n    >>> np.hsplit(x, 2)\n    [array([[[0.,  1.]],\n           [[4.,  5.]]]),\n     array([[[2.,  3.]],\n           [[6.,  7.]]])]\n\n    ","^0","^9"],["^ ","^7","pmt","^8","\n    Compute the payment against loan principal plus interest.\n\n    .. deprecated:: 1.18\n\n       `pmt` is deprecated; for details, see NEP 32 [1]_.\n       Use the corresponding function in the numpy-financial library,\n       https://pypi.org/project/numpy-financial.\n\n    Given:\n     * a present value, `pv` (e.g., an amount borrowed)\n     * a future value, `fv` (e.g., 0)\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * and (optional) specification of whether payment is made\n       at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the (fixed) periodic payment.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like,  optional\n        Future value (default = 0)\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray\n        Payment against loan plus interest.  If all input is scalar, returns a\n        scalar float.  If any input is array_like, returns payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    Notes\n    -----\n    The payment is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n      fv + pv + pmt * nper == 0\n\n    for ``pmt``.\n\n    Note that computing a monthly mortgage payment is only\n    one use for this function.  For example, pmt returns the\n    periodic deposit one must make to achieve a specified\n    future balance given an initial deposit, a fixed,\n    periodically compounded interest rate, and the total\n    number of periods.\n\n    References\n    ----------\n    .. [1] NumPy Enhancement Proposal (NEP) 32,\n       https://numpy.org/neps/nep-0032-remove-financial-functions.html\n    .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php\n       ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the monthly payment needed to pay off a $200,000 loan in 15\n    years at an annual interest rate of 7.5%?\n\n    >>> np.pmt(0.075/12, 12*15, 200000)\n    -1854.0247200054619\n\n    In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\n    today, a monthly payment of $1,854.02 would be required.  Note that this\n    example illustrates usage of `fv` having a default value of 0.\n\n    ","^0","^9"],["^ ","^7","byte","^8","Signed integer type, compatible with C ``char``.\n    Character code: ``'b'``.\n    Canonical name: ``np.byte``.\n    Alias *on this platform*: ``np.int8``: 8-bit signed integer (-128 to 127).","^0","^0"],["^ ","^7","seterrobj","^8","seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in NumPy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [8192, 521, None]\n\n    >>> def err_handler(type, flag):\n    ...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n    '14'\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n    >>> np.geterrcall() is err_handler\n    True","^0","^?"],["^ ","^7","log2","^8","log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nBase-2 logarithm of `x`.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    Base-2 logarithm of `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlog, log10, log1p, emath.log2\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `2**z = x`. The convention is to return the `z`\nwhose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log2` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log2` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log2`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\n\nExamples\n--------\n>>> x = np.array([0, 1, 2, 2**4])\n>>> np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n\n>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n>>> np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])","^0","^;"],["^ ","^7","left_shift","^8","left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nShift the bits of an integer to the left.\n\nBits are shifted to the left by appending `x2` 0s at the right of `x1`.\nSince the internal representation of numbers is in binary format, this\noperation is equivalent to multiplying `x1` by ``2**x2``.\n\nParameters\n----------\nx1 : array_like of integer type\n    Input values.\nx2 : array_like of integer type\n    Number of zeros to append to `x1`. Has to be non-negative.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : array of integer type\n    Return `x1` with bits shifted `x2` times to the left.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nright_shift : Shift the bits of an integer to the right.\nbinary_repr : Return the binary representation of the input number\n    as a string.\n\nExamples\n--------\n>>> np.binary_repr(5)\n'101'\n>>> np.left_shift(5, 2)\n20\n>>> np.binary_repr(20)\n'10100'\n\n>>> np.left_shift(5, [1,2,3])\narray([10, 20, 40])","^0","^;"],["^ ","^7","ascontiguousarray","^8","\n    Return a contiguous array (ndim >= 1) in memory (C order).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        Data-type of returned array.\n\n    Returns\n    -------\n    out : ndarray\n        Contiguous array of same shape and content as `a`, with type `dtype`\n        if specified.\n\n    See Also\n    --------\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> np.ascontiguousarray(x, dtype=np.float32)\n    array([[0., 1., 2.],\n           [3., 4., 5.]], dtype=float32)\n    >>> x.flags['C_CONTIGUOUS']\n    True\n\n    Note: This function returns an array with at least one-dimension (1-d) \n    so it will not preserve 0-d arrays.  \n\n    ","^0","^9"],["^ ","^7","row_stack","^8","\n    Stack arrays in sequence vertically (row wise).\n\n    This is equivalent to concatenation along the first axis after 1-D arrays\n    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n    `vsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        The arrays must have the same shape along all but the first axis.\n        1-D arrays must have the same length.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays, will be at least 2-D.\n\n    See Also\n    --------\n    stack : Join a sequence of arrays along a new axis.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays along an existing axis.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n    block : Assemble arrays from blocks.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n\n    ","^0","^9"],["^ ","^7","savez","^8","Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    If arguments are passed in with no keywords, the corresponding variable\n    names, in the ``.npz`` file, are 'arr_0', 'arr_1', etc. If keyword\n    arguments are given, the corresponding variable names, in the ``.npz``\n    file will match the keyword names.\n\n    Parameters\n    ----------\n    file : str or file\n        Either the filename (string) or an open file (file-like object)\n        where the data will be saved. If file is a string or a Path, the\n        ``.npz`` extension will be appended to the filename if it is not\n        already there.\n    args : Arguments, optional\n        Arrays to save to the file. Since it is not possible for Python to\n        know the names of the arrays outside `savez`, the arrays will be saved\n        with names \"arr_0\", \"arr_1\", and so on. These arguments can be any\n        expression.\n    kwds : Keyword arguments, optional\n        Arrays to save to the file. Arrays will be saved in the file with the\n        keyword names.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    save : Save a single array to a binary file in NumPy format.\n    savetxt : Save an array to a file as plain text.\n    savez_compressed : Save several arrays into a compressed ``.npz`` archive\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is not compressed and each file\n    in the archive contains one variable in ``.npy`` format. For a\n    description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.\n\n    When opening the saved ``.npz`` file with `load` a `NpzFile` object is\n    returned. This is a dictionary-like object which can be queried for\n    its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    When saving dictionaries, the dictionary keys become filenames\n    inside the ZIP archive. Therefore, keys should be valid filenames.\n    E.g., avoid keys that begin with ``/`` or contain ``.``.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n    >>> x = np.arange(10)\n    >>> y = np.sin(x)\n\n    Using `savez` with \\*args, the arrays are saved with default names.\n\n    >>> np.savez(outfile, x, y)\n    >>> _ = outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['arr_0', 'arr_1']\n    >>> npzfile['arr_0']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    Using `savez` with \\**kwds, the arrays are saved with the keyword names.\n\n    >>> outfile = TemporaryFile()\n    >>> np.savez(outfile, x=x, y=y)\n    >>> _ = outfile.seek(0)\n    >>> npzfile = np.load(outfile)\n    >>> sorted(npzfile.files)\n    ['x', 'y']\n    >>> npzfile['x']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    ","^0","^9"],["^ ","^7","typename","^8","\n    Return a description for the given data type code.\n\n    Parameters\n    ----------\n    char : str\n        Data type code.\n\n    Returns\n    -------\n    out : str\n        Description of the input data type code.\n\n    See Also\n    --------\n    dtype, typecodes\n\n    Examples\n    --------\n    >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n    ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n    >>> for typechar in typechars:\n    ...     print(typechar, ' : ', np.typename(typechar))\n    ...\n    S1  :  character\n    ?  :  bool\n    B  :  unsigned char\n    D  :  complex double precision\n    G  :  complex long double precision\n    F  :  complex single precision\n    I  :  unsigned integer\n    H  :  unsigned short\n    L  :  unsigned long integer\n    O  :  object\n    Q  :  unsigned long long integer\n    S  :  string\n    U  :  unicode\n    V  :  void\n    b  :  signed char\n    d  :  double precision\n    g  :  long precision\n    f  :  single precision\n    i  :  integer\n    h  :  short\n    l  :  long integer\n    q  :  long long integer\n\n    ","^0","^9"],["^ ","^7","test","^8","\n    Pytest test runner.\n\n    A test function is typically added to a package's __init__.py like so::\n\n      from numpy._pytesttester import PytestTester\n      test = PytestTester(__name__).test\n      del PytestTester\n\n    Calling this test function finds and runs all tests associated with the\n    module and all its sub-modules.\n\n    Attributes\n    ----------\n    module_name : str\n        Full path to the package to test.\n\n    Parameters\n    ----------\n    module_name : module name\n        The name of the module to test.\n\n    Notes\n    -----\n    Unlike the previous ``nose``-based implementation, this class is not\n    publicly exposed as it performs some ``numpy``-specific warning\n    suppression.\n\n    ","^0","~:pytest-tester"],["^ ","^8","","^0","^="],["^ ","^7","array_equiv","^8","\n    Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n\n    ","^0","^9"],["^ ","^7","stack","^8","\n    Join a sequence of arrays along a new axis.\n\n    The ``axis`` parameter specifies the index of the new axis in the\n    dimensions of the result. For example, if ``axis=0`` it will be the first\n    dimension and if ``axis=-1`` it will be the last dimension.\n\n    .. versionadded:: 1.10.0\n\n    Parameters\n    ----------\n    arrays : sequence of array_like\n        Each array must have the same shape.\n\n    axis : int, optional\n        The axis in the result array along which the input arrays are stacked.\n\n    out : ndarray, optional\n        If provided, the destination to place the result. The shape must be\n        correct, matching that of what stack would have returned if no\n        out argument were specified.\n\n    Returns\n    -------\n    stacked : ndarray\n        The stacked array has one more dimension than the input arrays.\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays along an existing axis.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    block : Assemble arrays from blocks.\n\n    Examples\n    --------\n    >>> arrays = [np.random.randn(3, 4) for _ in range(10)]\n    >>> np.stack(arrays, axis=0).shape\n    (10, 3, 4)\n\n    >>> np.stack(arrays, axis=1).shape\n    (3, 10, 4)\n\n    >>> np.stack(arrays, axis=2).shape\n    (3, 4, 10)\n\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.stack((a, b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> np.stack((a, b), axis=-1)\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n\n    ","^0","^9"],["^ ","^7","right_shift","^8","right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nShift the bits of an integer to the right.\n\nBits are shifted to the right `x2`.  Because the internal\nrepresentation of numbers is in binary format, this operation is\nequivalent to dividing `x1` by ``2**x2``.\n\nParameters\n----------\nx1 : array_like, int\n    Input values.\nx2 : array_like, int\n    Number of bits to remove at the right of `x1`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray, int\n    Return `x1` with bits shifted `x2` times to the right.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nleft_shift : Shift the bits of an integer to the left.\nbinary_repr : Return the binary representation of the input number\n    as a string.\n\nExamples\n--------\n>>> np.binary_repr(10)\n'1010'\n>>> np.right_shift(10, 1)\n5\n>>> np.binary_repr(5)\n'101'\n\n>>> np.right_shift(10, [1,2,3])\narray([5, 2, 1])","^0","^;"],["^ ","^7","nanvar","^8","\n    Compute the variance along the specified axis, while ignoring NaNs.\n\n    Returns the variance of the array elements, a measure of the spread of\n    a distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    For all-NaN slices or slices with zero degrees of freedom, NaN is\n    returned and a `RuntimeWarning` is raised.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the variance is computed.  The default is to compute\n        the variance of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : int, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of non-NaN\n        elements. By default `ddof` is zero.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If `out` is None, return a new array containing the variance,\n        otherwise return a reference to the output array. If ddof is >= the\n        number of non-NaN elements in a slice or the slice contains only\n        NaNs, then the result for that slice is NaN.\n\n    See Also\n    --------\n    std : Standard deviation\n    mean : Average\n    var : Variance while not ignoring NaNs\n    nanstd, nanmean\n    ufuncs-output-type\n\n    Notes\n    -----\n    The variance is the average of the squared deviations from the mean,\n    i.e.,  ``var = mean(abs(x - x.mean())**2)``.\n\n    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.\n    If, however, `ddof` is specified, the divisor ``N - ddof`` is used\n    instead.  In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of the variance of a hypothetical infinite\n    population.  ``ddof=0`` provides a maximum likelihood estimate of the\n    variance for normally distributed variables.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    For this function to work on sub-classes of ndarray, they must define\n    `sum` with the kwarg `keepdims`\n\n    Examples\n    --------\n    >>> a = np.array([[1, np.nan], [3, 4]])\n    >>> np.nanvar(a)\n    1.5555555555555554\n    >>> np.nanvar(a, axis=0)\n    array([1.,  0.])\n    >>> np.nanvar(a, axis=1)\n    array([0.,  0.25])  # may vary\n\n    ","^0","^9"],["^ ","^7","numpy.polynomial","^8","\nA sub-package for efficiently dealing with polynomials.\n\nWithin the documentation for this sub-package, a \"finite power series,\"\ni.e., a polynomial (also referred to simply as a \"series\") is represented\nby a 1-D numpy array of the polynomial's coefficients, ordered from lowest\norder term to highest.  For example, array([1,2,3]) represents\n``P_0 + 2*P_1 + 3*P_2``, where P_n is the n-th order basis polynomial\napplicable to the specific module in question, e.g., `polynomial` (which\n\"wraps\" the \"standard\" basis) or `chebyshev`.  For optimal performance,\nall operations on polynomials, including evaluation at an argument, are\nimplemented as operations on the coefficients.  Additional (module-specific)\ninformation can be found in the docstring for the module of interest.\n\n","^0","^>"],["^ ","^7","polyder","^8","\n    Return the derivative of the specified order of a polynomial.\n\n    Parameters\n    ----------\n    p : poly1d or sequence\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of differentiation (default: 1)\n\n    Returns\n    -------\n    der : poly1d\n        A new polynomial representing the derivative.\n\n    See Also\n    --------\n    polyint : Anti-derivative of a polynomial.\n    poly1d : Class for one-dimensional polynomials.\n\n    Examples\n    --------\n    The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:\n\n    >>> p = np.poly1d([1,1,1,1])\n    >>> p2 = np.polyder(p)\n    >>> p2\n    poly1d([3, 2, 1])\n\n    which evaluates to:\n\n    >>> p2(2.)\n    17.0\n\n    We can verify this, approximating the derivative with\n    ``(f(x + h) - f(x))/h``:\n\n    >>> (p(2. + 0.001) - p(2.)) / 0.001\n    17.007000999997857\n\n    The fourth-order derivative of a 3rd-order polynomial is zero:\n\n    >>> np.polyder(p, 2)\n    poly1d([6, 2])\n    >>> np.polyder(p, 3)\n    poly1d([6])\n    >>> np.polyder(p, 4)\n    poly1d([0.])\n\n    ","^0","^9"],["^ ","^7","moveaxis","^8","\n    Move axes of an array to new positions.\n\n    Other axes remain in their original order.\n\n    .. versionadded:: 1.11.0\n\n    Parameters\n    ----------\n    a : np.ndarray\n        The array whose axes should be reordered.\n    source : int or sequence of int\n        Original positions of the axes to move. These must be unique.\n    destination : int or sequence of int\n        Destination positions for each of the original axes. These must also be\n        unique.\n\n    Returns\n    -------\n    result : np.ndarray\n        Array with moved axes. This array is a view of the input array.\n\n    See Also\n    --------\n    transpose: Permute the dimensions of an array.\n    swapaxes: Interchange two axes of an array.\n\n    Examples\n    --------\n\n    >>> x = np.zeros((3, 4, 5))\n    >>> np.moveaxis(x, 0, -1).shape\n    (4, 5, 3)\n    >>> np.moveaxis(x, -1, 0).shape\n    (5, 3, 4)\n\n    These all achieve the same result:\n\n    >>> np.transpose(x).shape\n    (5, 4, 3)\n    >>> np.swapaxes(x, 0, -1).shape\n    (5, 4, 3)\n    >>> np.moveaxis(x, [0, 1], [-1, -2]).shape\n    (5, 4, 3)\n    >>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\n    (5, 4, 3)\n\n    ","^0","^9"],["^ ","^7","concatenate","^8","\n    concatenate((a1, a2, ...), axis=0, out=None)\n\n    Join a sequence of arrays along an existing axis.\n\n    Parameters\n    ----------\n    a1, a2, ... : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined.  If axis is None,\n        arrays are flattened before use.  Default is 0.\n    out : ndarray, optional\n        If provided, the destination to place the result. The shape must be\n        correct, matching that of what concatenate would have returned if no\n        out argument were specified.\n\n    Returns\n    -------\n    res : ndarray\n        The concatenated array.\n\n    See Also\n    --------\n    ma.concatenate : Concatenate function that preserves input masks.\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    hsplit : Split array into multiple sub-arrays horizontally (column wise)\n    vsplit : Split array into multiple sub-arrays vertically (row wise)\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    stack : Stack a sequence of arrays along a new axis.\n    hstack : Stack arrays in sequence horizontally (column wise)\n    vstack : Stack arrays in sequence vertically (row wise)\n    dstack : Stack arrays in sequence depth wise (along third dimension)\n    block : Assemble arrays from blocks.\n\n    Notes\n    -----\n    When one or more of the arrays to be concatenated is a MaskedArray,\n    this function will return a MaskedArray object instead of an ndarray,\n    but the input masks are *not* preserved. In cases where a MaskedArray\n    is expected as input, use the ma.concatenate function from the masked\n    array module instead.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1, 2, 5],\n           [3, 4, 6]])\n    >>> np.concatenate((a, b), axis=None)\n    array([1, 2, 3, 4, 5, 6])\n\n    This function will not preserve masking of MaskedArray inputs.\n\n    >>> a = np.ma.arange(3)\n    >>> a[1] = np.ma.masked\n    >>> b = np.arange(2, 5)\n    >>> a\n    masked_array(data=[0, --, 2],\n                 mask=[False,  True, False],\n           fill_value=999999)\n    >>> b\n    array([2, 3, 4])\n    >>> np.concatenate([a, b])\n    masked_array(data=[0, 1, 2, 2, 3, 4],\n                 mask=False,\n           fill_value=999999)\n    >>> np.ma.concatenate([a, b])\n    masked_array(data=[0, --, 2, 2, 3, 4],\n                 mask=[False,  True, False, False, False, False],\n           fill_value=999999)\n\n    ","^0","^9"],["^ ","^7","zeros_like","^8","\n    Return an array of zeros with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n\n        .. versionadded:: 1.6.0\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n\n        .. versionadded:: 1.6.0\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of 'a', otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of zeros with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    zeros : Return a new array setting values to zero.\n\n    Examples\n    --------\n    >>> x = np.arange(6)\n    >>> x = x.reshape((2, 3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.zeros_like(x)\n    array([[0, 0, 0],\n           [0, 0, 0]])\n\n    >>> y = np.arange(3, dtype=float)\n    >>> y\n    array([0., 1., 2.])\n    >>> np.zeros_like(y)\n    array([0.,  0.,  0.])\n\n    ","^0","^9"],["^ ","^7","rint","^8","rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nRound elements of the array to the nearest integer.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array is same shape and type as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nceil, floor, trunc\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])","^0","^;"],["^ ","^7","arcsin","^8","arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse sine, element-wise.\n\nParameters\n----------\nx : array_like\n    `y`-coordinate on the unit circle.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nangle : ndarray\n    The inverse sine of each element in `x`, in radians and in the\n    closed interval ``[-pi/2, pi/2]``.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nsin, cos, arccos, tan, arctan, arctan2, emath.arcsin\n\nNotes\n-----\n`arcsin` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that :math:`sin(z) = x`.  The convention is to\nreturn the angle `z` whose real part lies in [-pi/2, pi/2].\n\nFor real-valued input data types, *arcsin* always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arcsin` is a complex analytic function that\nhas, by convention, the branch cuts [-inf, -1] and [1, inf]  and is\ncontinuous from above on the former and from below on the latter.\n\nThe inverse sine is also known as `asin` or sin^{-1}.\n\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79ff.\nhttp://www.math.sfu.ca/~cbm/aands/\n\nExamples\n--------\n>>> np.arcsin(1)     # pi/2\n1.5707963267948966\n>>> np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n>>> np.arcsin(0)\n0.0","^0","^;"],["^ ","^7","byte_bounds","^8","\n    Returns pointers to the end-points of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array. It must conform to the Python-side of the array\n        interface.\n\n    Returns\n    -------\n    (low, high) : tuple of 2 integers\n        The first integer is the first byte of the array, the second\n        integer is just past the last byte of the array.  If `a` is not\n        contiguous it will not use every byte between the (`low`, `high`)\n        values.\n\n    Examples\n    --------\n    >>> I = np.eye(2, dtype='f'); I.dtype\n    dtype('float32')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    >>> I = np.eye(2); I.dtype\n    dtype('float64')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n\n    ","^0","^9"],["^ ","^7","indices","^8","\n    Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0, 1, ...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n    sparse : boolean, optional\n        Return a sparse representation of the grid instead of a dense\n        representation. Default is False.\n\n        .. versionadded:: 1.17\n\n    Returns\n    -------\n    grid : one ndarray or tuple of ndarrays\n        If sparse is False:\n            Returns one array of grid indices,\n            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n        If sparse is True:\n            Returns a tuple of arrays, with\n            ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with\n            dimensions[i] in the ith place\n\n    See Also\n    --------\n    mgrid, ogrid, meshgrid\n\n    Notes\n    -----\n    The output shape in the dense case is obtained by prepending the number\n    of dimensions in front of the tuple of dimensions, i.e. if `dimensions`\n    is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N, r0, ..., rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k, i0, i1, ..., iN-1] = ik\n\n    Examples\n    --------\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n\n    If sparse is set to true, the grid will be returned in a sparse\n    representation.\n\n    >>> i, j = np.indices((2, 3), sparse=True)\n    >>> i.shape\n    (2, 1)\n    >>> j.shape\n    (1, 3)\n    >>> i        # row indices\n    array([[0],\n           [1]])\n    >>> j        # column indices\n    array([[0, 1, 2]])\n\n    ","^0","^9"],["^ ","^7","meshgrid","^8","\n    Return coordinate matrices from coordinate vectors.\n\n    Make N-D coordinate arrays for vectorized evaluations of\n    N-D scalar/vector fields over N-D grids, given\n    one-dimensional coordinate arrays x1, x2,..., xn.\n\n    .. versionchanged:: 1.9\n       1-D and 0-D cases are allowed.\n\n    Parameters\n    ----------\n    x1, x2,..., xn : array_like\n        1-D arrays representing the coordinates of a grid.\n    indexing : {'xy', 'ij'}, optional\n        Cartesian ('xy', default) or matrix ('ij') indexing of output.\n        See Notes for more details.\n\n        .. versionadded:: 1.7.0\n    sparse : bool, optional\n        If True a sparse grid is returned in order to conserve memory.\n        Default is False.\n\n        .. versionadded:: 1.7.0\n    copy : bool, optional\n        If False, a view into the original arrays are returned in order to\n        conserve memory.  Default is True.  Please note that\n        ``sparse=False, copy=False`` will likely return non-contiguous\n        arrays.  Furthermore, more than one element of a broadcast array\n        may refer to a single memory location.  If you need to write to the\n        arrays, make copies first.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    X1, X2,..., XN : ndarray\n        For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi)`` ,\n        return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing='ij'\n        or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing='xy'\n        with the elements of `xi` repeated to fill the matrix along\n        the first dimension for `x1`, the second for `x2` and so on.\n\n    Notes\n    -----\n    This function supports both indexing conventions through the indexing\n    keyword argument.  Giving the string 'ij' returns a meshgrid with\n    matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.\n    In the 2-D case with inputs of length M and N, the outputs are of shape\n    (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case\n    with inputs of length M, N and P, outputs are of shape (N, M, P) for\n    'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is\n    illustrated by the following code snippet::\n\n        xv, yv = np.meshgrid(x, y, sparse=False, indexing='ij')\n        for i in range(nx):\n            for j in range(ny):\n                # treat xv[i,j], yv[i,j]\n\n        xv, yv = np.meshgrid(x, y, sparse=False, indexing='xy')\n        for i in range(nx):\n            for j in range(ny):\n                # treat xv[j,i], yv[j,i]\n\n    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.\n\n    See Also\n    --------\n    index_tricks.mgrid : Construct a multi-dimensional \"meshgrid\"\n                     using indexing notation.\n    index_tricks.ogrid : Construct an open multi-dimensional \"meshgrid\"\n                     using indexing notation.\n\n    Examples\n    --------\n    >>> nx, ny = (3, 2)\n    >>> x = np.linspace(0, 1, nx)\n    >>> y = np.linspace(0, 1, ny)\n    >>> xv, yv = np.meshgrid(x, y)\n    >>> xv\n    array([[0. , 0.5, 1. ],\n           [0. , 0.5, 1. ]])\n    >>> yv\n    array([[0.,  0.,  0.],\n           [1.,  1.,  1.]])\n    >>> xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays\n    >>> xv\n    array([[0. ,  0.5,  1. ]])\n    >>> yv\n    array([[0.],\n           [1.]])\n\n    `meshgrid` is very useful to evaluate functions on a grid.\n\n    >>> import matplotlib.pyplot as plt\n    >>> x = np.arange(-5, 5, 0.1)\n    >>> y = np.arange(-5, 5, 0.1)\n    >>> xx, yy = np.meshgrid(x, y, sparse=True)\n    >>> z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)\n    >>> h = plt.contourf(x,y,z)\n    >>> plt.show()\n\n    ","^0","^9"],["^ ","^7","datetime64","^8",null,"^0","^0"],["^ ","^7","copyto","^8","\n    copyto(dst, src, casting='same_kind', where=True)\n\n    Copies values from one array to another, broadcasting as necessary.\n\n    Raises a TypeError if the `casting` rule is violated, and if\n    `where` is provided, it selects which elements to copy.\n\n    .. versionadded:: 1.7.0\n\n    Parameters\n    ----------\n    dst : ndarray\n        The array into which values are copied.\n    src : array_like\n        The array from which values are copied.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur when copying.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n    where : array_like of bool, optional\n        A boolean array which is broadcasted to match the dimensions\n        of `dst`, and selects elements to copy from `src` to `dst`\n        wherever it contains the value True.\n    ","^0","^9"],["^ ","^7","polydiv","^8","\n    Returns the quotient and remainder of polynomial division.\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the \"numerator\" (dividend) and \"denominator\"\n    (divisor) polynomials, respectively.\n\n    Parameters\n    ----------\n    u : array_like or poly1d\n        Dividend polynomial's coefficients.\n\n    v : array_like or poly1d\n        Divisor polynomial's coefficients.\n\n    Returns\n    -------\n    q : ndarray\n        Coefficients, including those equal to zero, of the quotient.\n    r : ndarray\n        Coefficients, including those equal to zero, of the remainder.\n\n    See Also\n    --------\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub\n    polyval\n\n    Notes\n    -----\n    Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need\n    not equal `v.ndim`. In other words, all four possible combinations -\n    ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,\n    ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.\n\n    Examples\n    --------\n    .. math:: \\frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\n\n    >>> x = np.array([3.0, 5.0, 2.0])\n    >>> y = np.array([2.0, 1.0])\n    >>> np.polydiv(x, y)\n    (array([1.5 , 1.75]), array([0.25]))\n\n    ","^0","^9"],["^ ","^8","","^0","^<"],["^ ","^7","modf","^8","modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the fractional and integral parts of an array, element-wise.\n\nThe fractional and integral parts are negative if the given number is\nnegative.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny1 : ndarray\n    Fractional part of `x`.\n    This is a scalar if `x` is a scalar.\ny2 : ndarray\n    Integral part of `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nFor integer input the return values are floats.\n\nSee Also\n--------\ndivmod : ``divmod(x, 1)`` is equivalent to ``modf`` with the return values\n         switched, except it always has a positive remainder.\n\nExamples\n--------\n>>> np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n>>> np.modf(-0.5)\n(-0.5, -0)","^0","^;"],["^ ","^7","busdaycalendar","^8","busdaycalendar(weekmask='1111100', holidays=None)\n\n    A business day calendar object that efficiently stores information\n    defining valid days for the busday family of functions.\n\n    The default valid days are Monday through Friday (\"business days\").\n    A busdaycalendar object can be specified with any set of weekly\n    valid days, plus an optional \"holiday\" dates that always will be invalid.\n\n    Once a busdaycalendar object is created, the weekmask and holidays\n    cannot be modified.\n\n    .. versionadded:: 1.7.0\n\n    Parameters\n    ----------\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates, no matter which\n        weekday they fall upon.  Holiday dates may be specified in any\n        order, and NaT (not-a-time) dates are ignored.  This list is\n        saved in a normalized form that is suited for fast calculations\n        of valid days.\n\n    Returns\n    -------\n    out : busdaycalendar\n        A business day calendar object containing the specified\n        weekmask and holidays values.\n\n    See Also\n    --------\n    is_busday : Returns a boolean array indicating valid days.\n    busday_offset : Applies an offset counted in valid days.\n    busday_count : Counts how many valid days are in a half-open date range.\n\n    Attributes\n    ----------\n    Note: once a busdaycalendar object is created, you cannot modify the\n    weekmask or holidays.  The attributes return copies of internal data.\n    weekmask : (copy) seven-element array of bool\n    holidays : (copy) sorted array of datetime64[D]\n\n    Examples\n    --------\n    >>> # Some important days in July\n    ... bdd = np.busdaycalendar(\n    ...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n    >>> # Default is Monday to Friday weekdays\n    ... bdd.weekmask\n    array([ True,  True,  True,  True,  True, False, False])\n    >>> # Any holidays already on the weekend are removed\n    ... bdd.holidays\n    array(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')","^0","^0"],["^ ","^7","deg2rad","^8","deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from degrees to radians.\n\nParameters\n----------\nx : array_like\n    Angles in degrees.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding angle in radians.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nrad2deg : Convert angles from radians to degrees.\nunwrap : Remove large jumps in angle by wrapping.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\n``deg2rad(x)`` is ``x * pi / 180``.\n\nExamples\n--------\n>>> np.deg2rad(180)\n3.1415926535897931","^0","^;"],["^ ","^8","","^0","^<"],["^ ","^7","longlong","^8","Signed integer type, compatible with C ``long long``.\n    Character code: ``'q'``.","^0","^0"],["^ ","^7","numpy._distributor_init","^8"," Distributor init file\n\nDistributors: you can add custom code here to support particular distributions\nof numpy.\n\nFor example, this is a good place to put any checks for hardware requirements.\n\nThe numpy standard source distribution will not put code in this file, so you\ncan safely replace this file with your own version.\n","^0","^>"],["^ ","^7","add_docstring","^8","add_docstring(obj, docstring)\n\n    Add a docstring to a built-in obj if possible.\n    If the obj already has a docstring raise a RuntimeError\n    If this routine does not know how to add a docstring to the object\n    raise a TypeError","^0","^?"],["^ ","^7","median","^8","\n    Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {int, sequence of int, None}, optional\n        Axis or axes along which the medians are computed. The default\n        is to compute the median along a flattened version of the array.\n        A sequence of axes is supported since version 1.9.0.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       `median`. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. If `overwrite_input` is ``True`` and `a` is not already an\n       `ndarray`, an error will be raised.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `arr`.\n\n        .. versionadded:: 1.9.0\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result. If the input contains integers\n        or floats smaller than ``float64``, then the output data-type is\n        ``np.float64``.  Otherwise, the data-type of the output is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean, percentile\n\n    Notes\n    -----\n    Given a vector ``V`` of length ``N``, the median of ``V`` is the\n    middle value of a sorted copy of ``V``, ``V_sorted`` - i\n    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the\n    two middle values of ``V_sorted`` when ``N`` is even.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.median(a)\n    3.5\n    >>> np.median(a, axis=0)\n    array([6.5, 4.5, 2.5])\n    >>> np.median(a, axis=1)\n    array([7.,  2.])\n    >>> m = np.median(a, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.median(a, axis=0, out=m)\n    array([6.5,  4.5,  2.5])\n    >>> m\n    array([6.5,  4.5,  2.5])\n    >>> b = a.copy()\n    >>> np.median(b, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.median(b, axis=None, overwrite_input=True)\n    3.5\n    >>> assert not np.all(a==b)\n\n    ","^0","^9"],["^ ","^7","bitwise_xor","^8","bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``^``.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_xor\nbitwise_and\nbitwise_or\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 is represented by ``00001101``. Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise XOR of 13 and 17 is\ntherefore ``00011100``, or 28:\n\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'\n\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26,  6])\n\n>>> np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n>>> np.bitwise_xor([True, True], [False, True])\narray([ True, False])","^0","^;"]]]],["^ ","~:R",true]]],"~:map-keywords",true,"~:widget",true]]
;; <=

;; @@ [clj]
^:R [:p/pydoc (datafy-module numpy/linspace)]
;; @@
;; =>
;;; ["^ ","~:type","~:reagent","~:content",["^ ","~:hiccup",["~#with-meta",[["~:p/pydoc",["^ ","__eq__",["^ ","~:args",["self"],"~:varkw","kwargs","~:name","__eq__","~:varargs","args","^0","~:method-wrapper","~:kwonlydefaults",null,"~:defaults",null,"~:kwonlyargs",[],"~:str","<method-wrapper '__eq__' of function object at 0x7fa3d573b950>","~:annotations",["^ "],"~:arglists",[["~$self","~$&",["~$args",["^ ","~:as","~$kwargs"]]]],"~:flags",["~#set",["~:callable?"]],"~:doc","Return self==value."],"__globals__",["^ ","^0","~:dict","^I","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^?","{'implementation': <function linspace at 0x7fa3d573b7a0>, 'dispatcher': <function _linspace_dispatcher at 0x7fa3d5735d40>, 'functools': <module 'functools' from '/usr/lib64/python3.7/functools.py'>, 'implement_array_function': <built-in function implement_array_function>, '__builtins__': {'__name__': 'builtins', '__doc__': \"Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.\", '__package__': '', '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': ModuleSpec(name='builtins', loader=<class '_frozen_importlib.BuiltinImporter'>), '__build_class__': <built-in function __build_class__>, '__import__': <built-in function __import__>, 'abs': <built-in function abs>, 'all': <built-in function all>, 'any': <built-in function any>, 'ascii': <built-in function ascii>, 'bin': <built-in function bin>, 'breakpoint': <built-in function breakpoint>, 'callable': <built-in function callable>, 'chr': <built-in function chr>, 'compile': <built-in function compile>, 'delattr': <built-in function delattr>, 'dir': <built-in function dir>, 'divmod': <built-in function divmod>, 'eval': <built-in function eval>, 'exec': <built-in function exec>, 'format': <built-in function format>, 'getattr': <built-in function getattr>, 'globals': <built-in function globals>, 'hasattr': <built-in function hasattr>, 'hash': <built-in function hash>, 'hex': <built-in function hex>, 'id': <built-in function id>, 'input': <built-in function input>, 'isinstance': <built-in function isinstance>, 'issubclass': <built-in function issubclass>, 'iter': <built-in function iter>, 'len': <built-in function len>, 'locals': <built-in function locals>, 'max': <built-in function max>, 'min': <built-in function min>, 'next': <built-in function next>, 'oct': <built-in function oct>, 'ord': <built-in function ord>, 'pow': <built-in function pow>, 'print': <built-in function print>, 'repr': <built-in function repr>, 'round': <built-in function round>, 'setattr': <built-in function setattr>, 'sorted': <built-in function sorted>, 'sum': <built-in function sum>, 'vars': <built-in function vars>, 'None': None, 'Ellipsis': Ellipsis, 'NotImplemented': NotImplemented, 'False': False, 'True': True, 'bool': <class 'bool'>, 'memoryview': <class 'memoryview'>, 'bytearray': <class 'bytearray'>, 'bytes': <class 'bytes'>, 'classmethod': <class 'classmethod'>, 'complex': <class 'complex'>, 'dict': <class 'dict'>, 'enumerate': <class 'enumerate'>, 'filter': <class 'filter'>, 'float': <class 'float'>, 'frozenset': <class 'frozenset'>, 'property': <class 'property'>, 'int': <class 'int'>, 'list': <class 'list'>, 'map': <class 'map'>, 'object': <class 'object'>, 'range': <class 'range'>, 'reversed': <class 'reversed'>, 'set': <class 'set'>, 'slice': <class 'slice'>, 'staticmethod': <class 'staticmethod'>, 'str': <class 'str'>, 'super': <class 'super'>, 'tuple': <class 'tuple'>, 'type': <class 'type'>, 'zip': <class 'zip'>, '__debug__': True, 'BaseException': <class 'BaseException'>, 'Exception': <class 'Exception'>, 'TypeError': <class 'TypeError'>, 'StopAsyncIteration': <class 'StopAsyncIteration'>, 'StopIteration': <class 'StopIteration'>, 'GeneratorExit': <class 'GeneratorExit'>, 'SystemExit': <class 'SystemExit'>, 'KeyboardInterrupt': <class 'KeyboardInterrupt'>, 'ImportError': <class 'ImportError'>, 'ModuleNotFoundError': <class 'ModuleNotFoundError'>, 'OSError': <class 'OSError'>, 'EnvironmentError': <class 'OSError'>, 'IOError': <class 'OSError'>, 'EOFError': <class 'EOFError'>, 'RuntimeError': <class 'RuntimeError'>, 'RecursionError': <class 'RecursionError'>, 'NotImplementedError': <class 'NotImplementedError'>, 'NameError': <class 'NameError'>, 'UnboundLocalError': <class 'UnboundLocalError'>, 'AttributeError': <class 'AttributeError'>, 'SyntaxError': <class 'SyntaxError'>, 'IndentationError': <class 'IndentationError'>, 'TabError': <class 'TabError'>, 'LookupError': <class 'LookupError'>, 'IndexError': <class 'IndexError'>, 'KeyError': <class 'KeyError'>, 'ValueError': <class 'ValueError'>, 'UnicodeError': <class 'UnicodeError'>, 'UnicodeEncodeError': <class 'UnicodeEncodeError'>, 'UnicodeDecodeError': <class 'UnicodeDecodeError'>, 'UnicodeTranslateError': <class 'UnicodeTranslateError'>, 'AssertionError': <class 'AssertionError'>, 'ArithmeticError': <class 'ArithmeticError'>, 'FloatingPointError': <class 'FloatingPointError'>, 'OverflowError': <class 'OverflowError'>, 'ZeroDivisionError': <class 'ZeroDivisionError'>, 'SystemError': <class 'SystemError'>, 'ReferenceError': <class 'ReferenceError'>, 'MemoryError': <class 'MemoryError'>, 'BufferError': <class 'BufferError'>, 'Warning': <class 'Warning'>, 'UserWarning': <class 'UserWarning'>, 'DeprecationWarning': <class 'DeprecationWarning'>, 'PendingDeprecationWarning': <class 'PendingDeprecationWarning'>, 'SyntaxWarning': <class 'SyntaxWarning'>, 'RuntimeWarning': <class 'RuntimeWarning'>, 'FutureWarning': <class 'FutureWarning'>, 'ImportWarning': <class 'ImportWarning'>, 'UnicodeWarning': <class 'UnicodeWarning'>, 'BytesWarning': <class 'BytesWarning'>, 'ResourceWarning': <class 'ResourceWarning'>, 'ConnectionError': <class 'ConnectionError'>, 'BlockingIOError': <class 'BlockingIOError'>, 'BrokenPipeError': <class 'BrokenPipeError'>, 'ChildProcessError': <class 'ChildProcessError'>, 'ConnectionAbortedError': <class 'ConnectionAbortedError'>, 'ConnectionRefusedError': <class 'ConnectionRefusedError'>, 'ConnectionResetError': <class 'ConnectionResetError'>, 'FileExistsError': <class 'FileExistsError'>, 'FileNotFoundError': <class 'FileNotFoundError'>, 'IsADirectoryError': <class 'IsADirectoryError'>, 'NotADirectoryError': <class 'NotADirectoryError'>, 'InterruptedError': <class 'InterruptedError'>, 'PermissionError': <class 'PermissionError'>, 'ProcessLookupError': <class 'ProcessLookupError'>, 'TimeoutError': <class 'TimeoutError'>, 'open': <built-in function open>, 'quit': Use quit() or Ctrl-D (i.e. EOF) to exit, 'exit': Use exit() or Ctrl-D (i.e. EOF) to exit, 'copyright': Copyright (c) 2001-2019 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved., 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information., 'license': See https://www.python.org/psf/license/, 'help': Type help() for interactive help, or help(object) for help about object.}, 'linspace': <function linspace at 0x7fa3d573b950>}","^F",["^G",[]]],"__lt__",["^ ","^7",["self"],"^8","kwargs","^9","__lt__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__lt__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self<value."],"__call__",["^ ","^7",["self"],"^8","kwargs","^9","__call__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__call__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Call self as a function."],"__reduce__",["^ ","^7",["self"],"^8",null,"^9","__reduce__","^:",null,"^0","~:builtin-function-or-method","^<",null,"^=",null,"~:module",null,"^>",[],"^?","<built-in method __reduce__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B"]],"^F",["^G",["~:fn?","~:method?","^H"]],"^I","Helper for pickle."],"__setattr__",["^ ","^7",["self"],"^8","kwargs","^9","__setattr__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__setattr__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Implement setattr(self, name, value)."],"__ge__",["^ ","^7",["self"],"^8","kwargs","^9","__ge__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__ge__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self>=value."],"__str__",["^ ","^7",["self"],"^8","kwargs","^9","__str__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__str__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return str(self)."],"^9","linspace","__getattribute__",["^ ","^7",["self"],"^8","kwargs","^9","__getattribute__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__getattribute__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return getattr(self, name)."],"__ne__",["^ ","^7",["self"],"^8","kwargs","^9","__ne__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__ne__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self!=value."],"__hash__",["^ ","^7",["self"],"^8","kwargs","^9","__hash__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__hash__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return hash(self)."],"_implementation",["^ ","^7",["start","stop","num","endpoint","retstep","dtype","axis"],"^8",null,"^9","_implementation","^:",null,"^0","~:function","^<",null,"^=",[50,true,false,null,0],"^P","numpy.core.function_base","^>",[],"^?","<function linspace at 0x7fa3d573b7a0>","^@",["^ "],"^A",[["~$start","~$stop","~$&",[["^ ","~$num","~:num","~$endpoint","~:endpoint","~$retstep","~:retstep","~$dtype","~:dtype","~$axis","~:axis","~:or",["^ ","^11",50,"^13",true,"^15",false,"^17",null,"^19",0]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^17","^18","^1;",["^ ","^11",50,"^13",true,"^15",false,"^17",null]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^1;",["^ ","^11",50,"^13",true,"^15",false]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^1;",["^ ","^11",50,"^13",true]]]],["^[","^10","~$&",[["^ ","^11","^12","^1;",["^ ","^11",50]]]],["^[","^10"]],"^F",["^G",["^Q","^H"]],"^I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    "],"__code__",["^ ","^0","~:code","^I","code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,\n      constants, names, varnames, filename, name, firstlineno,\n      lnotab[, freevars[, cellvars]])\n\nCreate a code object.  Not for the faint of heart.","^?","<code object linspace at 0x7fa3d573b810, file \"<__array_function__ internals>\", line 2>","^F",["^G",[]]],"__annotations__",["^ ","^0","^K","^I","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^?","{}","^F",["^G",[]]],"__wrapped__",["^ ","^7",["start","stop","num","endpoint","retstep","dtype","axis"],"^8",null,"^9","__wrapped__","^:",null,"^0","^Z","^<",null,"^=",[50,true,false,null,0],"^P","numpy.core.function_base","^>",[],"^?","<function linspace at 0x7fa3d573b7a0>","^@",["^ "],"^A",[["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^17","^18","^19","^1:","^1;",["^ ","^11",50,"^13",true,"^15",false,"^17",null,"^19",0]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^17","^18","^1;",["^ ","^11",50,"^13",true,"^15",false,"^17",null]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^15","^16","^1;",["^ ","^11",50,"^13",true,"^15",false]]]],["^[","^10","~$&",[["^ ","^11","^12","^13","^14","^1;",["^ ","^11",50,"^13",true]]]],["^[","^10","~$&",[["^ ","^11","^12","^1;",["^ ","^11",50]]]],["^[","^10"]],"^F",["^G",["^Q","^H"]],"^I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    "],"__sizeof__",["^ ","^7",["self"],"^8",null,"^9","__sizeof__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __sizeof__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B"]],"^F",["^G",["^Q","^R","^H"]],"^I","Size of object in memory, in bytes."],"^0","^Z","__le__",["^ ","^7",["self"],"^8","kwargs","^9","__le__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__le__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self<=value."],"__gt__",["^ ","^7",["self"],"^8","kwargs","^9","__gt__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__gt__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return self>value."],"__reduce_ex__",["^ ","^7",["self","protocol"],"^8",null,"^9","__reduce_ex__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __reduce_ex__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$protocol"]],"^F",["^G",["^Q","^R","^H"]],"^I","Helper for pickle."],"__dir__",["^ ","^7",["self"],"^8",null,"^9","__dir__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __dir__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B"]],"^F",["^G",["^Q","^R","^H"]],"^I","Default dir() implementation."],"^P","numpy","__repr__",["^ ","^7",["self"],"^8","kwargs","^9","__repr__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__repr__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return repr(self)."],"__dict__",["^ ","^0","^K","^I","dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)","^?","{'__wrapped__': <function linspace at 0x7fa3d573b7a0>, '_implementation': <function linspace at 0x7fa3d573b7a0>}","^F",["^G",[]]],"__module__",["^ ","^0","^?","^I","","^?","numpy","^F",["^G",[]],"~:value","numpy"],"__init_subclass__",["^ ","^7",["self"],"^8","kwargs","^9","__init_subclass__","^:","args","^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __init_subclass__ of type object at 0x7fa3ea2d7700>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^Q","^R","^H"]],"^I","This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n"],"__qualname__",["^ ","^0","^?","^I","","^?","linspace","^F",["^G",[]],"^1I","linspace"],"^?","<function linspace at 0x7fa3d573b950>","__subclasshook__",["^ ","^7",["self"],"^8","kwargs","^9","__subclasshook__","^:","args","^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __subclasshook__ of type object at 0x7fa3ea2d7700>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^Q","^R","^H"]],"^I","Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n"],"__new__",["^ ","^7",["type"],"^8","kwargs","^9","__new__","^:","args","^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __new__ of type object at 0x7fa3ea2d7700>","^@",["^ "],"^A",[["~$type","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^Q","^R","^H"]],"^I","Create and return a new object.  See help(type) for accurate signature."],"__doc__",["^ ","^0","^?","^I","","^?","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    ","^F",["^G",[]],"^1I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    "],"^F",["^G",["^Q","^H"]],"^I","\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n\n    .. versionchanged:: 1.16.0\n        Non-scalar `start` and `stop` are now supported.\n\n    Parameters\n    ----------\n    start : array_like\n        The starting value of the sequence.\n    stop : array_like\n        The end value of the sequence, unless `endpoint` is set to False.\n        In that case, the sequence consists of all but the last of ``num + 1``\n        evenly spaced samples, so that `stop` is excluded.  Note that the step\n        size changes when `endpoint` is False.\n    num : int, optional\n        Number of samples to generate. Default is 50. Must be non-negative.\n    endpoint : bool, optional\n        If True, `stop` is the last sample. Otherwise, it is not included.\n        Default is True.\n    retstep : bool, optional\n        If True, return (`samples`, `step`), where `step` is the spacing\n        between samples.\n    dtype : dtype, optional\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n        .. versionadded:: 1.9.0\n\n    axis : int, optional\n        The axis in the result to store the samples.  Relevant only if start\n        or stop are array-like.  By default (0), the samples will be along a\n        new axis inserted at the beginning. Use -1 to get an axis at the end.\n\n        .. versionadded:: 1.16.0\n\n    Returns\n    -------\n    samples : ndarray\n        There are `num` equally spaced samples in the closed interval\n        ``[start, stop]`` or the half-open interval ``[start, stop)``\n        (depending on whether `endpoint` is True or False).\n    step : float, optional\n        Only returned if `retstep` is True\n\n        Size of spacing between samples.\n\n\n    See Also\n    --------\n    arange : Similar to `linspace`, but uses a step size (instead of the\n             number of samples).\n    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log\n                scale (a geometric progression).\n    logspace : Similar to `geomspace`, but with the end points specified as\n               logarithms.\n\n    Examples\n    --------\n    >>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. ,  2.2,  2.4,  2.6,  2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2, y + 0.5, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()\n\n    ","__format__",["^ ","^7",["self","format_spec"],"^8",null,"^9","__format__","^:",null,"^0","^O","^<",null,"^=",null,"^P",null,"^>",[],"^?","<built-in method __format__ of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$format_spec"]],"^F",["^G",["^Q","^R","^H"]],"^I","Default object formatter."],"__delattr__",["^ ","^7",["self"],"^8","kwargs","^9","__delattr__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__delattr__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Implement delattr(self, name)."],"__name__",["^ ","^0","^?","^I","","^?","linspace","^F",["^G",[]],"^1I","linspace"],"__init__",["^ ","^7",["self"],"^8","kwargs","^9","__init__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__init__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Initialize self.  See help(type(self)) for accurate signature."],"__class__",["^ ","^7",["self"],"^8","kwargs","^9","__class__","^:","args","^0","^0","^<",null,"^=",null,"^P","builtins","^>",[],"^?","builtins.function","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["~:pyclass?","^H"]],"^I","Create a function object.\n\n  code\n    a code object\n  globals\n    the globals dictionary\n  name\n    a string that overrides the name from the code object\n  argdefs\n    a tuple that specifies the default argument values\n  closure\n    a tuple that supplies the bindings for free variables"],"__get__",["^ ","^7",["self"],"^8","kwargs","^9","__get__","^:","args","^0","^;","^<",null,"^=",null,"^>",[],"^?","<method-wrapper '__get__' of function object at 0x7fa3d573b950>","^@",["^ "],"^A",[["^B","~$&",["^C",["^ ","^D","^E"]]]],"^F",["^G",["^H"]],"^I","Return an attribute of instance, which is of type owner."]]],["^ ","~:R",true]]],"~:map-keywords",true,"~:widget",true]]
;; <=

;; @@ [clj]
(frequencies (map :type (vals (datafy numpy))))
;; @@
;; =>
;;; ["^ ","~:type","~:list-like","~:open",["~:span",["^ ","~:class","clj-map"],"{"],"~:close",["^3",["^ ","^4","clj-map"],"}"],"~:separator",["^3",", "],"~:items",["~#list",[["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","~:html","~:content",["^3",["^ ","^4","clj-nil"],"nil"],"~:value","nil"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"5"],"^;","5"]]],"^;","[nil 5]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":int"],"^;",":int"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"26"],"^;","26"]]],"^;","[:int 26]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":c-class"],"^;",":c-class"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:c-class 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":builtin-function-or-method"],"^;",":builtin-function-or-method"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"21"],"^;","21"]]],"^;","[:builtin-function-or-method 21]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":dict"],"^;",":dict"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"5"],"^;","5"]]],"^;","[:dict 5]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":pytest-tester"],"^;",":pytest-tester"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:pytest-tester 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":float"],"^;",":float"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"14"],"^;","14"]]],"^;","[:float 14]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":no-value-type"],"^;",":no-value-type"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:no-value-type 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":type"],"^;",":type"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"103"],"^;","103"]]],"^;","[:type 103]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":tuple"],"^;",":tuple"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:tuple 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":py-capsule"],"^;",":py-capsule"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:py-capsule 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":function"],"^;",":function"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"302"],"^;","302"]]],"^;","[:function 302]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":module"],"^;",":module"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"22"],"^;","22"]]],"^;","[:module 22]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":module-spec"],"^;",":module-spec"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:module-spec 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":str"],"^;",":str"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"10"],"^;","10"]]],"^;","[:str 10]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":list"],"^;",":list"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"2"],"^;","2"]]],"^;","[:list 2]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":type-na-dict"],"^;",":type-na-dict"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"2"],"^;","2"]]],"^;","[:type-na-dict 2]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":source-file-loader"],"^;",":source-file-loader"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:source-file-loader 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":o-grid-class"],"^;",":o-grid-class"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:o-grid-class 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":m-grid-class"],"^;",":m-grid-class"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:m-grid-class 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":bool"],"^;",":bool"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"2"],"^;","2"]]],"^;","[:bool 2]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":feature"],"^;",":feature"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"3"],"^;","3"]]],"^;","[:feature 3]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":ufunc"],"^;",":ufunc"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"91"],"^;","91"]]],"^;","[:ufunc 91]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":index-expression"],"^;",":index-expression"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"2"],"^;","2"]]],"^;","[:index-expression 2]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":r-class"],"^;",":r-class"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"1"],"^;","1"]]],"^;","[:r-class 1]"],["^ ","^0","^1","^2",null,"^5",null,"^6",["^3"," "],"^7",["^8",[["^ ","^0","^9","^:",["^3",["^ ","^4","clj-keyword"],":typedict"],"^;",":typedict"],["^ ","^0","^9","^:",["^3",["^ ","^4","clj-long"],"2"],"^;","2"]]],"^;","[:typedict 2]"]]],"^;","{nil 5, :int 26, :c-class 1, :builtin-function-or-method 21, :dict 5, :pytest-tester 1, :float 14, :no-value-type 1, :type 103, :tuple 1, :py-capsule 1, :function 302, :module 22, :module-spec 1, :str 10, :list 2, :type-na-dict 2, :source-file-loader 1, :o-grid-class 1, :m-grid-class 1, :bool 2, :feature 3, :ufunc 91, :index-expression 2, :r-class 1, :typedict 2}"]
;; <=

;; @@ [clj]

;; @@

;; @@ [clj]

;; @@
